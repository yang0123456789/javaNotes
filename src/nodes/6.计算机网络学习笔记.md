# 1.计网常见问题

## 1.HTTP1.0、HTTP1.1 和 HTTP2.0 的区别

影响一个 HTTP 网络请求的因素主要有两个：**带宽和延迟。**

- **带宽：**如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。

- **延迟：**

- - 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。
  - DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。**Domain Name System**
  - 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。



#### 1.HTTP1.0和HTTP1.1的一些区别

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match**等更多可供选择的缓存头来控制缓存策略。**
2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持**断点续传功能**，**HTTP1.1则在请求头引入了range头域**，它允许只请求资源的某个部分，即返回码是**206**（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。
3. **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，**请求消息中的URL并没有传递主机名（hostname）。**但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。**HTTP1.1的请求消息和响应消息都应支持Host头域**，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。
5. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了**HTTP1.0每次请求都要创建连接的缺点。**

#### **2、HTTPS与HTTP的一些区别**

- HTTPS协议需要到CA**申请证书**，一般免费证书很少，需要交费。
- HTTP协议运行在**TCP之上，所有传输的内容都是明文**，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，**所有传输的内容都经过加密的**。
- HTTP和HTTPS使用的是完全不同的连接方式，**用的端口也不一样，前者是80，后者是443**。
- HTTPS可以有效的防止**运营商劫持**，解决了防劫持的一个大问题。

## 2 OSI与TCP/IP各层的结构与功能,都有哪些协议?

**OSI:开放式系统互联通信参考模型(Open System Interconnection)**:开放式系统互联是把[网络通信](https://baike.baidu.com/item/网络通信)的工作分为7层,分别是[物理层](https://baike.baidu.com/item/物理层),[数据链路层](https://baike.baidu.com/item/数据链路层),[网络层](https://baike.baidu.com/item/网络层/4329439),[传输层](https://baike.baidu.com/item/传输层),会话层,[表示层](https://baike.baidu.com/item/表示层)和[应用层](https://baike.baidu.com/item/应用层/4329788)。

学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。

![五层体系结构](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/%E4%BA%94%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png)

结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。

### 1.1 应用层

**应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。**应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如**域名系统DNS**，支持万维网应用的 **HTTP协议**，支持电子邮件的 **SMTP协议**等等。我们把应用层**交互的数据单元称为报文**。

**域名系统**

> 域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 [www.ibm.com、Oracle](http://www.ibm.xn--comoracle-xj3h/) 公司的域名是 [www.oracle.com、Cisco公司的域名是](http://www.oracle.xn--comcisco-hm3g8360a63fhh376bwz2c1gzc/) [www.cisco.com](http://www.cisco.com/) 等。

**HTTP协议**

> 超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）

### [1.2 传输层](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_12-运输层)

**传输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务**。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。

**传输层主要使用以下两种协议:**

1. **传输控制协议 TCP**（Transmission Control Protocol）--提供**面向连接**的，**可靠的**数据传输服务。
2. **用户数据协议 UDP**（User Datagram Protocol）--提供**无连接**的，尽最大努力的数据传输服务（**不保证数据传输的可靠性**）。

**TCP 与 UDP 的对比见问题三。**

### [1.3 网络层](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_13-网络层)

**在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。** 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 **IP 协议**，因此分组也叫 **IP 数据报** ，简称 **数据报**。

这里要注意：**不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混**。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。

这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.

互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做**网际层**或**IP层**。

### [1.4 数据链路层](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_14-数据链路层)

**数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。** 在两个相邻节点之间传送数据时，**数据链路层将网络层交下来的 IP 数据报组装成帧**，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。

在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。 控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。

### [1.5 物理层](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_15-物理层)

在物理层上所传送的数据单位是比特。 **物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。** 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。

在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。

### [1.6 总结一下](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_16-总结一下)

上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下（图片来源于网络）。

![七层体系结构图](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/%E4%B8%83%E5%B1%82%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84%E5%9B%BE.png)

## [二 TCP 三次握手和四次挥手(面试常客)](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=二-tcp-三次握手和四次挥手面试常客)

为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。

https://blog.csdn.net/zixiaomuwu/article/details/60965466

### [2.1 TCP 三次握手漫画图解](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_21-tcp-三次握手漫画图解)

如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。 ![TCP三次握手](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

**简单示意图：** ![TCP三次握手](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B2.png)

- 客户端–发送带有 SYN 标志的数据包–一次握手–服务端
- 服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端
- 客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端

### [2.2 为什么要三次握手](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_22-为什么要三次握手)

**三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。**

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。

### [2.3 第2次握手传回了ACK，为什么还要传回SYN？](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_23-第2次握手传回了ack，为什么还要传回syn？)

接收端传回发送端所发送的ACK是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传SYN则是为了建立并确认从服务端到客户端的通信。”

> SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。

### [2.5 为什么要四次挥手](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_25-为什么要四次挥手)

![TCP四次挥手](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/TCP%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

断开一个 TCP 连接则需要“四次挥手”：

- 客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送
- 服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号
- 服务器-关闭与客户端的连接，发送一个FIN给客户端
- 客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1

任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。

举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。

上面讲的比较概括，推荐一篇讲的比较细致的文章：https://blog.csdn.net/qzcsu/article/details/72861891

## [三 TCP,UDP 协议的区别](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=三-tcpudp-协议的区别)

![TCP、UDP协议的区别](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/tcp-vs-udp.jpg)

UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等， UDP 提供广播或多播服务。

TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。



## [四 TCP 协议如何保证可靠传输](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=四-tcp-协议如何保证可靠传输)

1. 应用数据被分割成 TCP 认为最适合发送的数据块。
2. TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。
3. **校验和：** TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。
4. TCP 的接收端会丢弃重复的数据。
5. **流量控制：** TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）
6. **拥塞控制：** 当网络拥塞时，减少数据的发送。
7. **ARQ协议：** 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。
8. **超时重传：** 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。

### [4.1 ARQ协议](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_41-arq协议)

**自动重传请求**（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。

#### [停止等待ARQ协议](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=停止等待arq协议)

- 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；
- 在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；

**优点：** 简单

**缺点：** 信道利用率低，等待时间长

**1) 无差错情况:**

发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。

**2) 出现差错情况（超时重传）:**

停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。**连续 ARQ 协议** 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。

**3) 确认丢失和确认迟到**

- **确认丢失** ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。
- **确认迟到** ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。

#### [连续ARQ协议](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=连续arq协议)

连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。

**优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。

**缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。

### [4.2 滑动窗口和流量控制](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_42-滑动窗口和流量控制)

**TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### [4.3 拥塞控制](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=_43-拥塞控制)

在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP的拥塞控制采用了四种算法，即 **慢开始** 、 **拥塞避免** 、**快重传** 和 **快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。

- **慢开始：** 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
- **拥塞避免：** 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.
- **快重传与快恢复：** 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

## [五 在浏览器中输入url地址 ->> 显示主页的过程(面试常客)](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=五-在浏览器中输入url地址-gtgt-显示主页的过程面试常客)

百度好像最喜欢问这个问题。

> 打开一个网页，整个过程会使用哪些协议？

图解（图片来源：《图解HTTP》）：

![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.jpg)

> 上图有一个错误，请注意，是OSPF不是OPSF。 OSPF（Open Shortest Path Fitst，ospf）开放最短路径优先协议,是由Internet工程任务组开发的路由选择协议

总体来说分为以下几个过程:

1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

具体可以参考下面这篇文章：

- https://segmentfault.com/a/1190000006879700

## [六 状态码](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=六-状态码)

![状态码](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/%E7%8A%B6%E6%80%81%E7%A0%81.png)

## [七 各种协议与HTTP协议之间的关系](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=七-各种协议与http协议之间的关系)

一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。

![各种协议与HTTP协议之间的关系](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/%E5%90%84%E7%A7%8D%E5%8D%8F%E8%AE%AE%E4%B8%8EHTTP%E5%8D%8F%E8%AE%AE%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png)

![image-20200804171402638](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804171402638.png)

这种把数据信息包装起来的做法称为封装（encapsulate）。

IP（Internet Protocol）网际协议位于网络层。

MAC 地址（Media Access Control Address）。 

IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定 地址。

用 ARP 协议（Address Resolution Protocol）。ARP 是一种用以解析地址的协议，根据通信方 的 IP 地址就可以反查出对应的 MAC 地址。 

没有人能够全面掌握互联网中的传输状况 在到达通信目标前的中转过程中，那些计算机和路由器等网络设备只 能获悉很粗略的传输路线。 这种机制称为路由选择（routing），

![image-20200804172037266](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804172037266.png)

TCP 位于传输层，提供可靠的字节流服务。字节流服务（Byte Stream Service）是指，为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。而可靠的传输服务是指，能够把数据准确可靠地传给对方。

TCP 协议采用了三次握手 （three-way handshaking）策略。用 TCP 协议把数据包送出去后，TCP 不会对传送后的情况置之不理，它一定会向对方确认是否成功送达。 握手过程中使用了 TCP 的标志（flag） —SYN（synchronize） 和 ACK（acknowledgement）。
 发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后， 回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发 送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发 送相同的数据包

![image-20200804172250377](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804172250377.png)

DNS（Domain Name System）服务是和 HTTP 协议一样位于应用层的 

协议。它提供域名到 IP 地址之间的解析服务。 

计算机既可以被赋予 IP 地址，也可以被赋予主机名和域名。DNS 服务应运而生。DNS 协议提供通过域名 

查找 IP 地址，或逆向从 IP 地址反查域名的服务。 

![image-20200804172907474](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804172907474.png)



## HTTP/1.1 中可使用的方法

**GET** ：获取资源 

GET 方法用来请求访问已被 URI 识别的资源。指定的资源经服务器 端解析后返回响应内容。也就是说，如果请求的资源是文本，那就保 持原样返回；如果是像 CGI（Common Gateway Interface，通用网关接 口）那样的程序，则返回经过执行后的输出结果。 

![image-20200804175832709](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804175832709.png)

**POST**：传输实体主体 

POST 方法用来传输实体的主体。 

虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行 

传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 

POST 的主要目的并不是获取响应的主体内容。 

![image-20200804175932412](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804175932412.png)

![image-20200804180055923](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804180055923.png)

**PUT**：传输文件 

PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。 但是，鉴于 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件 , 存在安全性问题，因此一般的 Web 网站不使用该方法。若配合 Web 应用程序的验证机制，或架构设计采用REST（REpresentational State Transfer，表征状态转移）标准的同类Web 网站，就可能会开放使用 PUT 方法。 

![image-20200804180215811](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804180215811.png)

**HEAD**：获得报文首部 

HEAD 方法和 GET 方法一样，只是不返回报文主体部分。用于确认 

URI 的有效性及资源更新的日期时间等。 

![image-20200804180319526](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804180319526.png)

**DELETE**：删除文件 

DELETE 方法用来删除文件，是与 PUT 相反的方法。DELETE 方法按 

请求 URI 删除指定的资源。 

但是，HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机 

制，所以一般的 Web 网站也不使用 DELETE 方法。当配合 Web 应用 

程序的验证机制，或遵守 REST 标准时还是有可能会开放使用的。

**OPTIONS**：询问支持的方法 

OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。

![image-20200804180413422](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804180413422.png)

**TRACE**：追踪路径 

TRACE 方法是让 Web 服务器端将之前的请求通信环回给客户端的方 

法。

发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服 

务器端就将该数字减 1，当数值刚好减到 0 时，就停止继续传输，最 

后接收到请求的服务器端则返回状态码 200 OK 的响应。 

客户端通过 TRACE 方法可以查询发送出去的请求是怎样被加工修改 

/ 篡改的。这是因为，请求想要连接到源目标服务器可能会通过代理 

中转，TRACE 方法就是用来确认连接过程中发生的一系列操作。 

但是，TRACE 方法本来就不怎么常用，再加上它容易引发 

XST（Cross-Site Tracing，跨站追踪）攻击，通常就更不会用到了。

**CONNECT**：要求用隧道协议连接代理 

CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协 议进行 TCP 通信。主要使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加 密后经网络隧道传输。 

![image-20200804180621891](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804180621891.png)









## [八 HTTP长连接,短连接](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=八-http长连接短连接)

在**HTTP/1.0**中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端没有明确提出断开连接，则保持 TCP 连接状态。 旨在建立 **1** 次 **TCP** 连接后进行多次请求和响应的交互

持久连接使得多数请求以管线化（pipelining）方式发送成为可能。从 前发送请求后需等待并收到响应，才能发送下一个请求。管线化技术出现后，不用等待响应亦可直接发送下一个请求。这样就能够做到同时并行发送多个请求，而不需要一个接一个地等待响应了。 



**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**

—— [《HTTP长连接、短连接究竟是什么？》](https://www.cnblogs.com/gotodsp/p/6366163.html)

## [九 HTTP是不保存状态的协议,如何保存用户状态?](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=九-http是不保存状态的协议如何保存用户状态)

HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

**Cookie 被禁用怎么办?**

最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。

![HTTP是无状态协议](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/HTTP%E6%98%AF%E6%97%A0%E7%8A%B6%E6%80%81%E7%9A%84.png)

## [十 Cookie的作用是什么?和Session有什么区别？](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=十-cookie的作用是什么和session有什么区别？)

HTTP协议是无状态的

Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。

**Cookie 一般用来保存用户信息** 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。
**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。

Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。

Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。



Cookie 技术通过在请求和响应报文中写入 Cookie 信 息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的 首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器 发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪一 个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前 的状态信息。

## **HTTP** 报文 

用于在基于HTTP 协议的客户端和服务器之间进行交互的信息被称为 HTTP 报文。请求端（客户端）的HTTP 报文叫做**请求报文**，响应端（服务器端）的叫做**响应报文**。 HTTP 报文本身是由多行（用 CR+LF 作换行符）数据构成的字符串文本。HTTP 报文大致可分为**报文首部和报文主体**两块。两者由最初出现的空行（CR+LF）来划分。通常，并不一定要有报文主体。 

![image-20200804214604511](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804214604511.png)

![image-20200804214707649](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804214707649.png)

## 请求报文和响应报文的组成

**首部内容**由以下数据组成。现在出现的各种首部字段及状态码稍后会进行阐述。 

请求行 

包含用于请求的方法，请求 URI 和 HTTP 版本。 

状态行 

包含表明响应结果的状态码，原因短语和 HTTP 版本。 

首部字段 

包含表示请求和响应的各种条件和属性的各类首部。 

一般有 4 种首部，分别是：通用首部、请求首部、响应首部和实体首部。

**HTTP 报文**的主体用于传输请求或响应的实体主体。 通常，报文主体等于实体主体。只有当传输中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。

## 内容编码

内容编码指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码。常用的内容编码有以下几种。 

**gzip**（**GNU zip**） 

**compress**（**UNIX** 系统的标准压缩） 

**deflate**（**zlib**） 

**identity**（不进行编码） 

把实体主体分块的功能称为分块传输编码（Chunked Transfer Coding）。分块传输编码会将实体主体分成多个部（块）。每一块都会用十六 进制来标记块的大小，而实体主体的最后一块会使用“0(CR+LF)”来标 记。

**多部分对象集合**包含的对象如下。 

**multipart/form-data** 

在 Web 表单文件上传时使用。 

**multipart/byteranges** 

## 范围请求（Range Request）

对一份 10 000 字节大小的资源，如果使用范围请求，可以只请求 5001~10 000 字节内的资源。执行范围请求时，会用到首部字段 Range 来指定资源的 byte 范围。 byte 范围的指定形式如下。
 **5001~10 000** 字节   Range: bytes=5001-10000 

从 **5001** 字节之后全部的  Range: bytes=5001- 

从一开始到 **3000** 字节和 **5000~7000** 字节的多重范围  Range: bytes=-3000, 5000-7000 

针对范围请求，响应会返回状态码为 206 Partial Content 的响应报文。另外，对于多重范围的范围请求，响应会在首部字段 Content- Type 标明 multipart/byteranges 后返回响应报文。 

## 内容协商（Content Negotiation）

当浏览器的默认语言为英语或中文，访问相同 URI 的 Web 页面时， 则会显示对应的英语版或中文版的 Web 页面。这样的机制称为内容协商（Content Negotiation）。 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言、字符集、编码方式等作为判断的基准。



## 虚拟服务器和代理服务器

HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。比如，提供Web 托管服务（Web Hosting Service）的供应商，可以用一台服务器为多位客户服务，也可以以每位客户持有的域名运行各自不同的网站。这是因为利用了虚拟主机（Virtual Host，又称虚拟服务器）的功 能.在相同的 IP 地址下，由于虚拟主机可以寄存多个不同主机名和域名 的 Web 网站，因此在发送 HTTP 请求时，必须在 Host首部内完整指定主机名或域名的 URI。 

![image-20200804222758935](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804222758935.png)



代理服务器的基本行为就是接收客户端发送的请求后转发给其他服务器。代理不改变请求 URI，会直接发送给前方持有资源的目标服务器。

![image-20200804223550098](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804223550098.png)

## 隧道 

隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全的通信。 

隧道本身不会去解析 HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。 网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提 供非 HTTP 协议服务。

  利用网关能提高通信的安全性，因为可以在客户端与网关之间的通信 线路上加密以确保连接的安全。比如，网关可以连接数据库，使用 SQL语句查询数据。另外，在 Web 购物网站上进行信用卡结算时，网关可以和信用卡结算系统联动。 





## [十一 HTTP 1.0和HTTP 1.1的主要区别是什么?](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=十一-http-10和http-11的主要区别是什么)

> 这部分回答引用这篇文章 https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A? 的一些内容。

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **长连接** : **在HTTP/1.0中，默认使用的是短连接**，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。**HTTP 1.1起，默认使用长连接** ,默认开启Connection： keep-alive。 **HTTP/1.1的持续连接有非流水线方式和流水线方式** 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。
2. **错误状态响应码** :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。
3. **缓存处理** :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。
4. **带宽优化及网络连接的使用** :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

## [十二 URI和URL](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=十二-uri和url的区别是什么)

- URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。
- URL(Uniform Resource Location) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。

URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。

与 URI（统一资源标识符）相比，我们更熟悉 URL（Uniform Resource Locator，统一资源定位符）。URL正是使用 Web 浏览器等 访问 Web 页面时需要输入的网页地址。统一资源标识符 URI 是 Uniform Resource Identifier 的缩写。RFC2396 分别对这 3 个单 词进行了如下定义。 

**Uniform** 规定统一的格式可方便处理多种不同类型的资源，而不用根据上下文 环境来识别资源指定的访问方式。另外，加入新增的协议方案（如 http: 或 ftp:）也更容易。 

**Resource** 资源的定义是“可标识的任何东西”。除了文档文件、图像或服务（例 如当天的天气预报）等能够区别于其他类型的，全都可作为资源。另 外，资源不仅可以是单一的，也可以是多数的集合体。 

**Identifier** 表示可标识的对象。也称为标识符。 

综上所述，URI 就是由**某个协议方案表示的资源的定位标识符**。协议方案是指访问资源所使用的协议类型名称。 采用 HTTP 协议时，协议方案就是 http。除此之外，还有 ftp、 mailto、telnet、file 等。

URI 用字符串标识某一互联网资源，而 URL表示资源的地点（互联网上所处的位置）。可见 URL是 URI 的子集。

![image-20200804173718935](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200804173718935.png)

服务器地址 

使用绝对 URI 必须指定待访问的服务器地址。地址可以是类似 hackr.jp 这种 DNS 可解析的名称，或是 192.168.1.1 这类 IPv4 地址 名，还可以是 [0:0:0:0:0:0:0:1] 这样用方括号括起来的 IPv6 地址名。 

片段标识符 

使用片段标识符通常可标记出已获取资源中的子资源（文档内的某个 位置）。但在 RFC 中并没有明确规定其使用方法。该项也为可选 项。 有一些用来制定 HTTP 协议技术标准的文档，它们被称为 RFC（Request for Comments，征求修正意见书）。有一些用来制定 HTTP 协议技术标准的文档，它们被称为 RFC（Request for Comments，征求修正意见书）。 



## [十三 HTTP 和 HTTPS 的区别？](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=十三-http-和-https-的区别？)

1. **端口** ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。

2. 安全性和资源消耗：

   HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。
   HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。

   

   

   

### 单工,半双工,全双工区别

1. 单工
   单工就是指A只能发信号，而B只能接收信号，通信是单向的，就象灯塔之于航船——灯塔发出光信号而航船只能接收信号以确保自己行驶在正确的航线上。
2. 半双工
   指一个时间段内只有一个动作发生，举个简单例子，一天窄窄的马路，同时只能有一辆车通过，当目前有两量车对开，这种情况下就只能一辆先过，等到头儿后另一辆再开，这个例子就形象的说明了半双工的原理。早期的对讲机、以及早期集线器等设备都是实行半双工的产品。随着技术的不断进步，半双工会逐渐退出历史舞台。
3. 全双工
   Full－Duplex Transmissions
   指**交换机**在发送数据的同时也能够接收数据，两者同步进行，这好像我们平时打电话一样，说话的同时也能够听到对方的声音。目前的交换机都支持全双工。

**串行通信**
在串行通信中,数据通常是在两个站(如终端和微机)之间进行传送,按照数据流的方向可分成三种基本的传送方式:全双工、半双工、和单工.但单工目前已很少采用,下面仅介绍前两种方式。

1. 全双工方式( full duplex )
   当数据的发送和接收分流,分别由**两根不同的传输线**传送时,通信双方都能在**同一时刻**进行发送和接收操作,这样的传送方式就是全双工制.在全双工方式下,通信系统的**每一端都设置了发送器和接收器**,因此,能控制数据同时在两个方向上传送.全双工方式无需进行方向的切换,因此,没有切换操作所产生的时间延迟,这对那些不能有时间延误的交互式应用(例如远程监测和控制系统)十分有利.这种方式要求通讯双方均有发送器和接收器,同时,需要 2 根数据线传送数据信号.(可能还需要控制线和状态线,以及地线).

举例：

比如,计算机主机用串行接口连接显示终端,而显示终端带有键盘.这样,一方面键盘上输入的字符送到主机内存;另一方面,主机内存的信息可以送到屏幕显示.通常,往键盘上打入 1 个字符以后,先不显示,计算机主机收到字符后,立即回送到终端,然后终端再把这个字符显示出来.这样,前一个字符的回送过程和后一个字符的输入过程是同时进行的,即工作于全双工方式.

（这个例子举得还行，如果举通信的例子更好。）

1. 半双式方式( half duplex )

若使用**同一根传输线**既作接收又作发送,虽然数据可以在两个方向上传送,但通信双方不能同时收发数据,这样的传送方式就是半双工制.采用半双工方式时,通信系统每一端的发送器和接收器,通过收 / 发开关转接到通信线上,进行方向的切换,因此,会产生时间延迟.收 / 发开关实际上是由软件控制的电子开关.

当计算机主机用串行接口连接显示终端时,在半双工方式中,输入过程和输出过程使用同一通路.有些计算机和显示终端之间采用半双工方式工作,这时,从键盘打入的字符在发送到主机的同时就被送到终端上显示出来,而不是用回送的办法,所以避免了接收过程和发送过程同时进行的情况.

目前多数终端和串行接口都为半双工方式提供了换向能力,也为全双工方式提供了两条独立的引脚.在实际使用时,一般并不需要通信双方同时既发送又接收,像打印机这类的单向传送设备,半双工甚至单工就能胜任,也无需倒向.

全双工模式下，网线最大可以达到100兆以上的速度；
在半双工模式下，网线能达到的速度通常为10兆左右。

全双工模式的网线既可以工作于全双工模式，也可以工作于半双工模式；
但半双工模式的网线不能工作于全双工模式。

在半双工模式下，多出来的两组线可以用来接电话线，比如：把“白蓝、蓝” 这组线分出来当电话线使用。
在局域网网络布线中，用这种方式可以节省布线成本，一根双绞线同时当网线和电话线使用。

### TDD和FDD区别

1. 什么是4G/LTE-FDD/LTE-TDD
       4G故名思议就是第四代移动电话行动通信标准，指的是第四代移动通信技术，包括TD-LTE和FDD-LTE两种制式。那么我们所说的LTE又是什么意思呢？LTE即长期演进技术，是英文Long Term Evolution的缩写。LTE在技术上被认为是3.9G。但是我们通常还是把它们称为4G，因为它们具有100Mbps的数据下载能力(指cat3下行带宽)，是现在3G网速的10倍左右。同时也是3G向技术4G演进的关键过程。
       LTE标准由TDD和FDD两种不同的双工模式组成，TDD代表时分双工，也就是说上下行在同一频段上按照时间分配交叉进行;而FDD则是上下行分处不同频段同时进行。这两种制式虽然名义上是由TD-SCDMA和WCDMA演进而来，但实际上LTE(包括TDD和FDD)采用的是OFDM(正交频分复用)方式调制下行，SC-OFDM(单载波正交频分复用)。这已经和3G时代的标准天差地别了，其所继承的，你甚至可以认为只是时分与频分两种双工模式罢了。
       同时，这两种制式，都采用了MIMO(多发多收)天线技术，并且也都能支持1.4、3、5、10、15 和20 MHz信号带宽，支持对已使用频率资源的重复利用。
   　　总的来说，LTE具备高速上下行，高效频谱利用率，系统布置灵活，无线接入延时更低等优点。其表现是，下载快了，信号好了，玩游戏ping低了，某些场合你不用拉有线宽带了。
2. LTE-FDD和LTE-TDD的区别
       这两种制式的不同点，也是各自的优缺点在于，TDD因为上下行在同一频段上，所以可以更好利用频谱资源，更易于布置;而FDD因为上下行在不同频段同时进行，各行其是，所以数据传输能力更强，可是也对频谱资源的要求更高!在频谱资源日益紧张的今天，这是一件让所有运营商都蛋疼的事情。
       如果FDD理论下行速度会快一些，这就让很多潜在4G用户心动，并且下定决心用联通的LTE-FDD，小编在此保持沉默，毕竟FDD并没有放牌商用。其实一张网络好坏，并不是看理论速度就行了的，还要看覆盖质量，用户承载能力，实际传输速度等。毕竟理想是丰满的，现实是骨干的。大规模商用以后，用户使用量大，实际下行带宽估计都是半斤八两，再宽的马路都会有早晚高峰的时候，同样的道理，再宽的带宽也经不起大规模种子下载。
   　　目前来看，工信部给中国移动分配了130Mhz的TDD-LTE带宽使用，可以覆盖更多移动客户，提供更好的接入服务，而移动的布局策略就是低发射功率，高覆盖密度，他们所使用射频模块也从最初的8天线，每天线5W，发展到了现在的8天线，每天线20W。最起码现阶段的表现还是给力的，2014春节期间，许多小县城就已经具备移动4G网络了。从当前的现状来看，中国移动在未来4G竞争方面并不占下风。
3. 什么时候用FDD-LTE

​    现在中国电信和中国联通均已经宣布4G数据业务商用，而中国联通现在名义上TD-LTE商用，实际上还是会在热点地区采用TDD覆盖，本身从技术层面来讲，中国联通只需要升级现有基站模块就能轻松过度到FDD，目前，FDD牌照迟迟不发，业内人士猜测，主要是为了平衡三大运营商的竞争格局，给中国人自己主导的4G标准TD-LTE足够的发展空间。
![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20161104102334537)



**二、拥塞控制**
**`1.什么是拥塞控制`**

> too many sources sending too much data too fast for network to handle
> 防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞
> \###**`2.拥塞控制使用的机制：AIMD\slow start`**
> **`slow start: 慢启动`**
> A: additive（加法的）
> I: increase（增加）
> M: multiplicative（乘法的）
> D: decrease（减少）
> 即就是加法增加，乘法减少---->加增乘减

**`加法增加`**

> 是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞

**`乘法减少`**

> 出现一次超时（即出现一次网络拥塞），就把慢开始门限值ssthresh设置为当前的拥塞窗口值乘以0.5

ps：当网络频繁出现拥塞时，ssthresh值就下降的很快，以大大减少注入到网络中的分组数

**`3.发送端如何知道已经丢包？`**
![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20180801101712872)
**`4.为什么会有拥塞控制？`**

> 流量控制虽然可以高效可靠的传送大量的数据，但是如果在刚开始阶段就发送大量的数据，可能会导致网络拥堵，因为网络上的计算机太多了

**`5.拥塞控制的表现？`**

> 丢包
> 延时变长

**`6.拥塞控制的工作过程`**
**`初始化阶段`**
![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20180808112720118)
**`慢开始阶段`**
阶段（一）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808114749982)
阶段（二）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123534347)
阶段（三）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123554689)
阶段（四）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123619362)
**`拥塞避免阶段`**
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123721264)
**`拥塞调整阶段`**
阶段（一）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123806958)
阶段（二）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/2018080812382978)
阶段（三）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/2018080812385281)

**三、流量控制和拥塞控制的区别**
**`1.相同点`**

> （1）现象都是丢包；
> （2）实现机制都是让发送方发的慢一点，发的少一点

**`2.不同点`**

> **（1）`丢包位置不同`**
> 流量控制丢包位置是在接收端上
> 拥塞控制丢包位置是在路由器上
> **（2）`作用的对象不同`**
> 流量控制的对象是接收方，怕发送方发的太快，使得接收方来不及处理
> 拥塞控制的对象是网络，怕发送发发的太快，造成网络拥塞，使得网络来不及处理
> **`3.联系`**

```
拥塞控制
     拥塞控制通常表示的是一个全局性的过程，它会涉及到网络中所有的主机、
     所有的路由器和降低网络传输性能的所有因素
流量控制
     流量控制发生在发送端和接收端之间，只是点到点之间的控制

123456
```

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20180801095806107)

觉得自己有收获的小伙伴，可以打赏一下博主哦，让小姐姐去买个零食，哈哈哈哈
![在这里插入图片描述](https://img-blog.csdnimg.cn/2019081916584613.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2Rhbmd6aGFuZ2ppbmc5Nw==,size_16,color_FFFFFF,t_70)



## 快速重传算法

快速重传算法在之前的文章中有介绍，如果收到一个out-of-order的报文段时， TCP需要立刻产生一个ACK，这个ACK不应该被延时，目的在于让对方知道收到一个失序的报文，并告诉对方自己希望收到的报文seq，我们不知道这个重复的ACK的原因，因为还是会等待少量的重复ACK到来，如果连续收到3个或者3个以上的dup ACK，就被判断这个报文被丢失了，于是就需要立即重传丢失的数据段，这个地方不用等待定时器溢出。更详细的介绍可以参考：[**TCP-IP详解：超时重传机制**](http://blog.csdn.net/wdscq1234/article/details/52476231)



### 快速恢复算法

TCP Reno这个算法定义在[RFC5681](http://tools.ietf.org/html/rfc5681)。快速重传和快速恢复算法一般同时使用。快速恢复算法是认为，你还有3个Duplicated Acks说明网络也不那么糟糕

## 一、快速重传机制

上一篇讲到了TCP 的超时重传，但是超时重传往往会带来许多微妙的问题，比如说：

- 当一个报文段丢失时，会等待一定的超时周期然后才重传分组，增加了端到端的时延。
- 当一个报文段丢失时，在其等待超时的过程中，可能会出现这种情况：其后的报文段已经被接收端接收但却迟迟得不到确认，发送端会认为也丢失了，从而引起不必要的重传，既浪费资源也浪费时间。

幸运的是，由于TCP采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）。
如图所示，报文段1成功接收并被确认ACK 2，接收端的期待序号为2，当报文段2丢失，报文段3失序到来，与接收端的期望不匹配，接收端重复发送冗余ACK 2。

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20180710115206319)

## 三、快速重传应用实例

快速重传机制比较好理解，这里贴上笔者做的两幅图供大家学习参考，若有建议可以提出。第一幅图是在某报文段的超时重传定时器溢出前重传丢失报文段，第二幅图是对应的接收端缓存队列的窗口移动示意。
![快速重传：在某报文段的超时重传定时器溢出前重传丢失报文段](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20180710142127806)

![接收端缓存队列的窗口移动示意](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/2018071014224330)

## TCP/IP：tcp快速重传和快速恢复

1.重传会分为超时和3次重复确认后重传两种。快速重传就是指接收方重复3次确认同一个序号时，发送方立即重传。第1次不算在重复里面，所以一共发了4次ACK。

2.《tcp/ip 协议》描述的快速恢复有点乱。简单来讲，就是快速重传后执行拥塞避免算法，而不是慢启动算法。通过控制慢启动窗口ssthresh和拥塞窗口cwnd的值就可以实现。具体如下
（1）接收方发送第1次数据确认ACK。这里假设序号6657，表示前6676全部接受完。

（2）接收方重复发送多3次同样的数据确认ACK。这重复的3次ACK，前两次cwnd保持不变，第3次时，ssthresh变为cwnd的一半。这里假设cwnd原来为2426，于是ssthresh=2426/2=1213.但是ssthresh必须要=报文段大小整数倍。于是ssthresh=256*4=1024.注意不能=256*5；同时cwnd=ssthresh+3×报文段大小=1024+3*256=1792；3次重复确认的行为结束。

（3）发送方会重传丢失的6675报文段。但是在重传期间，未必能立即到达接收方。在这期间，接收方会继续重复确认6657。与（2）中的不同，（2）中前2个重复确认cwnd保持不变。在这里，每次重复ACK，cwnd增加一个报文段长度（相当于慢启动的增长速度）。

（4）最后接收方接收到丢失的分组，然后发送一个更大的ACK，因为在丢失期间，有接收到其他更大序号的报文段。这时，cwnd调整=ssthresh，并且立即执行一次慢启动（当cwnd<=ssthresh会执行慢启动），调整=ssthresh+1个报文段=1280。之后会采取拥塞避免算法。
![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170205193617864)

3.快速恢复过程中，cwnd经历了 降升降 的过程。

4.从图可以得出一个小结论是，发送方 拥塞窗口大小可能 < 未确认数据大小。

5.慢启动每次增加1个报文段。拥塞避免每次增加1/cwnd大小。这就意味着，之后的报文段，最后一个报文段可能以 < MSS的长度发送。报文段长度是由TCP层决定的，而不是应用程序决定的。

## [五 在浏览器中输入url地址 ->> 显示主页的过程(面试常客)](https://snailclimb.gitee.io/javaguide/#/docs/network/计算机网络?id=五-在浏览器中输入url地址-gtgt-显示主页的过程面试常客)

https://segmentfault.com/a/1190000006879700

**1. HTTP协议与TCP/IP协议的关系**

HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。 IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠地传递数据包，使得网络上接收端收到发送端所发出的所有包，并且顺序与发送顺序一致。TCP协议是可靠的、面向连接的。

## 2. 如何理解HTTP协议是无状态的

HTTP协议是无状态的，指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。

## 3. 什么是长连接、短连接？

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。

### 3.2. TCP短连接

模拟一下TCP短连接的情况：client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次请求就完成了。这时候双方任意都可以发起close操作，不过一般都是client先发起close操作。上述可知，短连接一般只会在 client/server间传递一次请求操作。

短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段。

### 3.3. TCP长连接

我们再模拟一下长连接的情况：client向server发起连接，server接受client连接，双方建立连接，client与server完成一次请求后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。

TCP的保活功能主要为服务器应用提供。如果客户端已经消失而连接未断开，则会使得服务器上保留一个半开放的连接，而服务器又在等待来自客户端的数据，此时服务器将永远等待客户端的数据。保活功能就是试图在服务端器端检测到这种半开放的连接。

如果一个给定的连接在两小时内没有任何动作，服务器就向客户发送一个探测报文段，根据客户端主机响应探测4个客户端状态：

- 客户主机依然正常运行，且服务器可达。此时客户的TCP响应正常，服务器将保活定时器复位。
- 客户主机已经崩溃，并且关闭或者正在重新启动。上述情况下客户端都不能响应TCP。服务端将无法收到客户端对探测的响应。服务器总共发送10个这样的探测，每个间隔75秒。若服务器没有收到任何一个响应，它就认为客户端已经关闭并终止连接。
- 客户端崩溃并已经重新启动。服务器将收到一个对其保活探测的响应，这个响应是一个复位，使得服务器终止这个连接。
- 客户机正常运行，但是服务器不可达。这种情况与第二种状态类似。

## 4. 长连接和短连接的优点和缺点

由上可以看出，长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间。对于频繁请求资源的客户端适合使用长连接。在长连接的应用场景下，client端一般不会主动关闭连接，当client与server之间的连接一直不关闭，随着客户端连接越来越多，server会保持过多连接。这时候server端需要采取一些策略，如关闭一些长时间没有请求发生的连接，这样可以避免一些恶意连接导致server端服务受损；如果条件允许则可以限制每个客户端的最大长连接数，这样可以完全避免恶意的客户端拖垮整体后端服务。

短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户请求频繁，将在TCP的建立和关闭操作上浪费较多时间和带宽。

长连接和短连接的产生在于client和server采取的关闭策略。不同的应用场景适合采用不同的策略。

由上可以看出，**长连接**可以**省去较多的TCP建立和关闭的操作，减少浪费，节约时间**。对于频繁请求资源的客户来说，较适用长连接。不过这里**存在一个问题**，**存活功能的探测周期太长**，还有就是它只是探测TCP连接的存活，属于比较斯文的做法，遇到恶意的连接时，保活功能就不够使了。在长连接的应用场景下，client端一般不会主动关闭它们之间的连接，**Client与server之间的连接如果一直不关闭的话，会存在一个问题，随着客户端连接越来越多，server早晚有扛不住的时候**，这时候server端需要采取一些策略，如关闭一些长时间没有读写事件发生的连接，这样可 以避免一些恶意连接导致server端服务受损；如果条件再允许就可以以客户端机器为颗粒度，限制每个客户端的最大长连接数，这样可以完全避免某个蛋疼的客户端连累后端服务。

**短连接**对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。但如果客户**请求频繁**，将在**TCP的建立和关闭操作上浪费时间和带宽**。

长连接和短连接的产生在于client和server采取的关闭策略，具体的应用场景采用具体的策略，没有十全十美的选择，只有合适的选择。

## **长连接短连接操作过程**

```
短连接的操作步骤是：
建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连接
长连接的操作步骤是：
建立连接——数据传输...（保持连接）...数据传输——关闭连接
```

## **什么时候用长连接，短连接？** 　　

**长连接**多用于操作频繁，点对点的通讯，而且连接数不能太多情况，。每个TCP连接都需要三步握手，这需要时间，如果每个操作都是先连接，再操作的话那么处理速度会降低很多，所以每个操作完后都不断开，次处理时直接发送数据包就OK了，不用建立TCP连接。例如：数据库的连接用长连接， 如果用短连接频繁的通信会造成socket错误，而且频繁的socket 创建也是对资源的浪费。 

　　而像WEB网站的http服务一般都用**短链接**，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。

 

## http和socket之长连接和短连接区别

http://www.jianshu.com/p/b68d2b26f5f4

 发送接收方式

1、异步

报文发送和接收是分开的，相互独立的，互不影响。这种方式又分两种情况：

(1)异步双工：接收和发送在同一个程序中，由两个不同的子进程分别负责发送和接收

(2)异步单工：接收和发送是用两个不同的程序来完成。

2、同步

报文发送和接收是同步进行，既报文发送后等待接收返回报文。 同步方式一般需要考虑超时问题，即报文发出去后不能无限等待，需要设定超时时间，超过该时间发送方不再等待读返回报文，直接通知超时返回。

在长连接中一般是没有条件能够判断读写什么时候结束，所以必须要加长度报文头。读函数先是读取报文头的长度，再根据这个长度去读相应长度的报文。

Socket是什么

Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

![img](https:////upload-images.jianshu.io/upload_images/1091437-475037aac5cef32c.png?imageMogr2/auto-orient/strip|imageView2/2/w/545/format/webp)

通信过程：

![img](https:////upload-images.jianshu.io/upload_images/1091437-0e0c53e792187d6f.png?imageMogr2/auto-orient/strip|imageView2/2/w/552/format/webp)

主机 A 的应用程序要能和主机 B 的应用程序通信，必须通过 Socket 建立连接，而建立 Socket 连接必须需要底层 TCP/IP 协议来建立 TCP 连接。建立 TCP 连接需要底层 IP 协议来寻址网络中的主机。我们知道网络层使用的 IP 协议可以帮助我们根据 IP 地址来找到目标主机，但是一台主机上可能运行着多个应用程序，如何才能与指定的应用程序通信就要通过 TCP 或 UPD 的地址也就是端口号来指定。这样就可以通过一个 Socket 实例唯一代表一个主机上的一个应用程序的通信链路了。

建立通信链路

当客户端要与服务端通信，客户端首先要创建一个 Socket 实例，操作系统将为这个 Socket 实例分配一个没有被使用的本地端口号，并创建一个包含本地和远程地址和端口号的套接字数据结构，这个数据结构将一直保存在系统中直到这个连接关闭。在创建 Socket 实例的构造函数正确返回之前，将要进行 TCP 的三次握手协议，TCP 握手协议完成后，Socket 实例对象将创建完成，否则将抛出 IOException 错误。

与之对应的服务端将创建一个 ServerSocket 实例，ServerSocket 创建比较简单只要指定的端口号没有被占用，一般实例创建都会成功，同时操作系统也会为 ServerSocket 实例创建一个底层数据结构，这个数据结构中包含指定监听的端口号和包含监听地址的通配符，通常情况下都是“*”即监听所有地址。之后当调用 accept() 方法时，将进入阻塞状态，等待客户端的请求。当一个新的请求到来时，将为这个连接创建一个新的套接字数据结构，该套接字数据的信息包含的地址和端口信息正是请求源地址和端口。这个新创建的数据结构将会关联到 ServerSocket 实例的一个未完成的连接数据结构列表中，注意这时服务端与之对应的 Socket 实例并没有完成创建，而要等到与客户端的三次握手完成后，这个服务端的 Socket 实例才会返回，并将这个 Socket 实例对应的数据结构从未完成列表中移到已完成列表中。所以 ServerSocket 所关联的列表中每个数据结构，都代表与一个客户端的建立的 TCP 连接。

备注：

Windows 下单机最大TCP连接数

调整系统参数来调整单机的最大TCP连接数，Windows 下单机的TCP连接数有多个参数共同决定：

以下都是通过修改注册表[HKEY_LOCAL_MACHINE \System \CurrentControlSet \Services \Tcpip \Parameters]

1.最大TCP连接数   TcpNumConnections

2.TCP关闭延迟时间  TCPTimedWaitDelay  (30-240)s

3.最大动态端口数  MaxUserPort (Default = 5000, Max = 65534) TCP客户端和服务器连接时，客户端必须分配一个动态端口，默认情况下这个动态端口的分配范围为 1024-5000 ，也就是说默认情况下，客户端最多可以同时发起3977 Socket 连接

4.最大TCB 数量  MaxFreeTcbs

系统为每个TCP 连接分配一个TCP 控制块(TCP control block or TCB)，这个控制块用于缓存TCP连接的一些参数，每个TCB需要分配 0.5 KB的pagepool 和 0.5KB 的Non-pagepool，也就说，每个TCP连接会占用 1KB 的系统内存。

非Server版本，MaxFreeTcbs 的默认值为1000 （64M 以上物理内存）Server 版本，这个的默认值为 2000。也就是说，默认情况下，Server 版本最多同时可以建立并保持2000个TCP 连接。

\5. 最大TCB Hash table 数量  MaxHashTableSize TCB 是通过Hash table 来管理的。

这个值指明分配 pagepool 内存的数量，也就是说，如果MaxFreeTcbs = 1000 , 则 pagepool 的内存数量为 500KB那么 MaxHashTableSize 应大于 500 才行。这个数量越大，则Hash table 的冗余度就越高，每次分配和查找 TCP 连接用时就越少。这个值必须是2的幂，且最大为65536.

IBM WebSphere Voice Server 在windows server 2003 下的典型配置

MaxUserPort = 65534 (Decimal)

MaxHashTableSize = 65536 (Decimal)

MaxFreeTcbs = 16000 (Decimal)

这里我们可以看到 MaxHashTableSize 被配置为比MaxFreeTcbs 大4倍，这样可以大大增加TCP建立的速度



## HTTP 的长连接和短连接

http://blog.jobbole.com/104108/

 

## HTTP持久连接

https://zh.wikipedia.org/wiki/HTTP%E6%8C%81%E4%B9%85%E8%BF%9E%E6%8E%A5

 

长连接

http://baike.baidu.com/view/2831907.htm

## HTTP1.0、HTTP1.1 和 HTTP2.0 的区别

**二、HTTP的基本优化**

影响一个 HTTP 网络请求的因素主要有两个：**带宽和延迟。**

- **带宽：**如果说我们还停留在拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，但是现在网络基础建设已经使得带宽得到极大的提升，我们不再会担心由带宽而影响网速，那么就只剩下延迟了。

- **延迟：**

- - 浏览器阻塞（HOL blocking）：浏览器会因为一些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（这个根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。

  - DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。这个通常可以利用DNS缓存结果来达到减少这个时间的目的。

  - 建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能捎带 HTTP 请求报文，达到真正的建立连接，但是这些连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类大请求影响较大。

    

**三、HTTP1.0和HTTP1.1的一些区别**

HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：

1. **缓存处理**，在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

2. **带宽优化及网络连接的使用**，HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持**断点续传**功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

3. **错误通知的管理**，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

4. **Host头处理**，在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

5. **长连接**，HTTP 1.1支持长连接（PersistentConnection）和请求的流水线（Pipelining）处理，在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟，在HTTP1.1中默认开启Connection： keep-alive，一定程度上弥补了HTTP1.0每次请求都要创建连接的缺点。

   

**四、HTTPS与HTTP的一些区别**

- HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
- HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
- HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
- HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。



![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/640)



**五、SPDY：HTTP1.x的优化**

2012年google如一声惊雷提出了SPDY的方案，优化了HTTP1.X的请求延迟，解决了HTTP1.X的安全性，具体如下：

1. **降低延迟**，针对HTTP高延迟的问题，SPDY优雅的采取了多路复用（multiplexing）。多路复用通过多个请求stream共享一个tcp连接的方式，解决了HOL blocking的问题，降低了延迟同时提高了带宽的利用率。
2. **请求优先级**（request prioritization）。多路复用带来一个新的问题是，在连接共享的基础之上有可能会导致关键请求被阻塞。SPDY允许给每个request设置优先级，这样重要的请求就会优先得到响应。比如浏览器加载首页，首页的html内容应该优先展示，之后才是各种静态资源文件，脚本文件等加载，这样可以保证用户能第一时间看到网页内容。
3. **header压缩。**前面提到HTTP1.x的header很多时候都是重复多余的。选择合适的压缩算法可以减小包的大小和数量。
4. **基于HTTPS的加密协议传输**，大大提高了传输数据的可靠性。
5. **服务端推送**（server push），采用了SPDY的网页，例如我的网页有一个sytle.css的请求，在客户端收到sytle.css数据的同时，服务端会将sytle.js的文件推送给客户端，当客户端再次尝试获取sytle.js时就可以直接从缓存中获取到，不用再发请求了。SPDY构成图：



![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/640)



SPDY位于HTTP之下，TCP和SSL之上，这样可以轻松兼容老版本的HTTP协议(将HTTP1.x的内容封装成一种新的frame格式)，同时可以使用已有的SSL功能。



**六、HTTP2.0性能惊人**

**HTTP/2: the Future of the Internet** https://link.zhihu.com/?target=https://http2.akamai.com/demo 是 Akamai 公司建立的一个官方的演示，用以说明 HTTP/2 相比于之前的 HTTP/1.1 在性能上的大幅度提升。 同时请求 379 张图片，从Load time 的对比可以看出 HTTP/2 在速度上的优势。



![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/640)



**七、HTTP2.0：SPDY的升级版**

HTTP2.0可以说是SPDY的升级版（其实原本也是基于SPDY设计的），但是，HTTP2.0 跟 SPDY 仍有不同的地方，如下：


**HTTP2.0和SPDY的区别：**

1. HTTP2.0 支持明文 HTTP 传输，而 SPDY 强制使用 HTTPS
2. HTTP2.0 消息头的压缩算法采用 **HPACK** http://http2.github.io/http2-spec/compression.html，而非 SPDY 采用的 **DEFLATE** http://zh.wikipedia.org/wiki/DEFLATE



**八、HTTP2.0和HTTP1.X相比的新特性**

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

- **header压缩**，如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。

  

**十、附注**

**HTTP2.0的多路复用和HTTP1.X中的长连接复用有什么区别？**

- HTTP/1.* 一次请求-响应，建立一个连接，用完关闭；每一个请求都要建立一个连接；

- HTTP/1.1 Pipeling解决方式为，若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，毫无办法，也就是人们常说的线头阻塞；

- HTTP/2多个请求可同时在一个连接上并行执行。某个请求任务耗时严重，不会影响到其它连接的正常执行；
  具体如图：

  ![image-20200912220146988](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200912220146988.png)







### **服务器推送到底是什么？**

服务端推送能把客户端所需要的资源伴随着index.html一起发送到客户端，省去了客户端重复请求的步骤。正因为没有发起请求，建立连接等操作，所以静态资源通过服务端推送的方式可以极大地提升速度。具体如下：

- 普通的客户端请求过程：

![image-20200912220220088](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200912220220088.png)



- 服务端推送的过程：



![image-20200912220229967](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200912220229967.png)





**为什么需要头部压缩？**
假定一个页面有100个资源需要加载（这个数量对于今天的Web而言还是挺保守的）, 而每一次请求都有1kb的消息头（这同样也并不少见，因为Cookie和引用等东西的存在）, 则至少需要多消耗100kb来获取这些消息头。HTTP2.0可以维护一个字典，差量更新HTTP头部，大大降低因头部传输产生的流量。具体参考：HTTP/2 头部压缩技术介绍



**HTTP2.0多路复用有多好？**
HTTP 性能优化的关键并不在于高带宽，而是低延迟。TCP 连接会随着时间进行自我「调谐」，起初会限制连接的最大速度，如果数据成功传输，会随着时间的推移提高传输的速度。这种调谐则被称为 TCP 慢启动。由于这种原因，让原本就具有突发性和短时性的 HTTP 连接变的十分低效。
HTTP/2 通过让所有数据流共用同一个连接，可以更有效地使用 TCP 连接，让高带宽也能真正的服务于 HTTP 的性能提升。

## 物理层和信道复用（频分、时分、码分）技术

物理层考虑的是怎样才能在各种媒介上传输数据，而并非具体的传输媒体，物理层的主要任务是确定与传输媒体接口有关的一些特性，即：

1. 机械特性：尺寸、形状等
2. 电气特性：线路上电压范围
3. 功能特性：线路上电压高低表示的意义
4. 过程特性：各种事件的顺序



## 2.数据通信系统

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170124205302438)

上图是一个比较常用的通信系统的模型，PC产生的数字比特流经调制解调器转换成模拟信号再经过公用电话网进行传输，到达目的系统后经调制解调器产生数字比特流最终由PC转换为有用的信息。

其中调制解调器的作用就是在两种信号之间做转换，这两种信号就是：

1. 模拟信号：连续信号，消息参数的取值是连续的
2. 数字信号：离散信号，消息参数的取值是离散的

上述两种信号都是在信道上传输的，在信道上双方交互信息主要有以下三种基本方式：

1. 单向通信：单工通信，只有一个方向的通信，没有反方向的交互
2. 双向交替通信：半双工通信，双方都可以发送信息，但不能同时发送
3. 双向同时通信：全双工通信，通信双方可以同时发送和接收信息

有关信道的最高[码元](https://www.baidu.com/baidu?wd=码元&tn=monline_dg&ie=utf-8)传输速率和信道的极限信息传输速率分别由[奈式准则和香农公式](http://blog.csdn.net/yangzhanghui/article/details/6480509)给出定义。

接下来是物理层下的传输媒体，传输媒体分为**导向传输媒体**和**非导向传输媒体**，在目前个人来看，所谓导向和非导向传输媒体的区别实质就是有线和无线的区别。

导向传输媒体包括：

1. 双绞线
2. 同轴电缆
3. 光缆

非导向传输媒体就是自由空间，也就是常说的无线传输，无线传输是按照波段（或波长）进行分类的，这里不做赘述。

## 3.信道复用技术

“复用”是一种将若干个彼此独立的信号，合并为一个可在同一信道上同时传输的复合信号的方法

如下是复用的示意图：

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170204200603644)

复用技术常见以下几种：

1. 频分复用
2. 时分复用（统计时分复用）
3. 波分复用
4. 码分复用

### 3.1 频分复用

频分复用就是每个用户分配到一定的频带后，通信时一直占据着自己的频带，即就是每个用户占用的是不同的带宽资源（这里的带宽资源指的是频率带宽而不是数据的发送速率）。所以说，这种方法就是将不同频率的数据合成在同一信道发送，在接收端再将其分开。合成示意图如下：

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170206121152863)

### 3.2 时分复用

时分复用则是将时间划分为一段段等长的时分复用帧，再将每个帧划分等分给用户使用，每个时分复用的用户占用固定序号的时隙，每个用户所占的时隙是周期性地出现，其周期就是时分复用帧的长度，相比较频分复用，时分复用的所有用户是在不同的时间占用相同的频带宽度。

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170206121944948)

由时分复用的概念可知，当某段时间内，时分复用的某个用户暂时无数据传输时，则会让分配到的子信道（从时分复用帧中分配的时间片）空闲，这样就会浪费线路资源，如下图：

![时分复用造成线路资源的浪费](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170206123339561)

为了弥补线路资源浪费的缺点，对时分复用进行了改进，产生了统计时分复用。如下图是统计时分复用的工作原理：

![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170206124247612)

统计时分复用的每个帧中的时隙数小于连接在集中器上的用户数，每个用户有了数据后随时发送到集中器的输入缓存当中，集中器按顺序扫描输入缓存，将数据集中起来组成每个STDM帧，对于没有输入缓存的就略过，所以STDM帧并不是固定分配间隙，而是由集中器按顺序扫描之后将存在数据组成STDM帧然后发送出去。由于每个用户的时隙序列并不固定，所以在分用器上将数据分用时就需要别的数据帮助分用，那就是上图中帧中红色部分的开销，这部分数据放入地址（序号）顺序，帮助分用器分用数据。

### 3.3 波分复用

波分复用WDM(Wavelength Division Multiplexing)是将两种或多种不同波长的光载波信号（携带各种信息）在发送端经复用器(亦称合波器，Multiplexer)汇合在一起，并耦合到光线路的同一根光纤中进行传输的技术

波分复用就是光的频分复用，原理与频分复用大致相同，这里不再赘述。

### 3.4 码分复用

码分复用（CDM，常用CDMA（码分多址））：用一组包含互相正交的码字的码组携带多路信号，每一个用户可以在同样的时间使用同样的频带进行通信，由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰

在CDMA中，每个比特时间再划分为m个短的间隔，成为码片，通常m值为64或128，这里使用m = 8来举个例子说明码分复用：

规则如下：

1. 使用CDMA的每一个站被指派一个唯一的m bit码片序列，一个站如果要发送比特1，则发送它自己的m bit码片序列，如果要发送0，则发送该码片序列的二进制反码，按照惯例将码片中的0写成-1，将1写成+1
2. CDMA给每一个站分配的码片序列不仅必须各不相同，并且还必须互相正交，用数学公式表示为，令向量S表示站S的码片向量，再令T表示其他任何站的码片向量，两个不同站的码片序列正交，就是向量S和T的规格化内积为0

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170227121210021)

1. 任何一个码片向量和该码片向量自己的规格化内积都是1
2. 任何一个码片向量和该码片的反码的向量的规格化内积都是-1

如下图是一个例子：

![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170206152553126)

要发送的数据为110，S站分配的码片序列为-1 -1 -1 1 1 -1 1 1，则-1 -1 -1 1 1 -1 1 1表示1，1 1 1 -1 -1 1 -1 -1 -1表示0。则根据分配的码片序列和要发送的数据可以得到S站点最终发送的信号为-1 -1 -1 1 1 -1 1 1（1） -1 -1 -1 1 1 -1 1 1（1） 1 1 1 -1 -1 1 -1 -1（0），与此同时当T站要发送的信号为-1 -1 1 -1 1 1 1 -1 -1 -1 1 -1 1 1 1 -1 1 1 -1 1 -1 -1 -1 1时，总的发送信号为-2 -2 0 0 2 0 2 0 -2 -2 0 0 2 0 2 0 2 2 0 0 -2 0 -2 0。

在接收端，当打算接收S站发送的信号时，就根据总的发送信号和S站分配的码片序列进行规格化内积得到S站发送的数据：

（-1 * -2 + -1 * -2 + -1 * 0 + 1 * 0 + 1 * 2 + -1 * 0 + 1 * 2 + 1 * 0）/8 = 1

（-1 * -2 + -1 * -2 + -1 * 0 + 1 * 0 + 1 * 2 + -1 * 0 + 1 * 2 + 1 * 0）/8 = 1

（-1 * 2 + -1 * 2 + -1 * 0 + 1 * 0 + 1 * -2 + -1 * 0 + 1 * -2 + 1 * 0）/8 = -1（表示数据0）

如上，即可通过总的信号和S站的码片得到S站点发送的数据。

有关物理层接入技术还有很多，像宽带接入使用的XDSL技术、HFC网等等，有兴趣可自行百度！

初识，不足之处还望指正！！

## RIP路由协议及工作原理

https://blog.csdn.net/lycb_gz/article/details/1612254



## HTTPS



HTTP 主要有这些不足，例举如下。
1.通信使用明文（不加密），内容可能会被窃听
2.不验证通信方的身份，因此有可能遭遇伪装HTTP 协议中的请求和响应不会对通信方进行确认。也就是说存在“服务器是否就是发送请求中 URI 真正指定的主机，返回的响应是否真的返回到实际提出请求的客户端”等类似问题。
3.无法证明报文的完整性，所以有可能已遭篡改
虽然有使用 HTTP 协议确定报文完整性的方法，但事实上并不便捷、可靠。其中常用的是 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。

HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或TLS（Transport Layer Security，安全层传输协议）的组合使用，
加密 HTTP 的通信内容。
用 SSL 建立安全通信线路之后，就可以在这条线路上进行 HTTP通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTPSecure，超文本传输安全协议）或 HTTP over SSL。

虽然使用 HTTP 协议无法确定通信方，但如果使用 SSL 则可以。SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。证书由值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。另外，伪造证书从技术角度来说是异常困难的一件事。所以只要能够确认通信方（服务器或客户端）持有的证书，即可判断通信方的真实意图。

HTTP+ 加密 + 认证 + 完整性保护=HTTPS

HTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用SSL（Secure Socket Layer）和 TLS（Transport Layer Security）协议代替而已。当使用 SSL 时，则演变成先和 SSL 通信，再由 SSL 和 TCP 通信了。简言之，所谓 HTTPS，其实就是身披SSL 协议这层外壳的 HTTP。

![image-20200912150517251](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200912150517251.png)



HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。
所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。
![image-20200912151446954](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200912151446954.png)

由数字证书认证机构（CA，CertificateAuthority）和其相关机关颁发的公开密钥证书。我们来介绍一下数字证书认证机构的业务流程。首先，服务器
的运营人员向数字证书认证机构提出公开密钥的申请。数字证书认证机构在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起。服务器会将这份由数字证书认证机构颁发的公钥证书发送给客户端，以进行公开密钥加密方式通信。公钥证书也可叫做数字证书或直接称为证书。接到证书的客户端可使用数字证书认证机构的公开密钥，对那张证书上的数字签名进行验证，一旦验证通过，客户端便可明确两件事：
一，认证服务器的公开密钥的是真实有效的数字证书认证机构。二，服务器的公开密钥是值得信赖的。
此处认证机关的公开密钥必须安全地转交给客户端。使用通信方式时，如何安全转交是一件很困难的事，因此，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。
![image-20200912152835329](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200912152835329.png)



## HTTPS 的通信步骤

![image-20200912153020531](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200912153020531.png)





1.SSL 第一次握手

步骤 1： 客户端通过发送 Client Hello 报文开始 SSL 通信。报文中包含客户端支持的 SSL 的指定版本、加密组件（Cipher Suite）列表（所使用的加密算法及密钥长度等）。
步骤 2： 服务器可进行 SSL 通信时，会以 Server Hello 报文作为应答。和客户端一样，在报文中包含 SSL 版本以及加密组件。服务器的加密组件内容是从接收到的客户端加密组件内筛选出来的。
步骤 3： 之后服务器发送 Certificate 报文。报文中包含公开密钥证书。
步骤 4： 最后服务器发送 Server Hello Done 报文通知客户端，最初阶段的 SSL 握手协商部分结束。

步骤 5： SSL 第一次握手结束之后，客户端以 Client Key Exchange 报文作为回应。报文中包含通信加密中使用的一种被称为 Pre-master secret 的随机密码串。该报文已用步骤 3 中的公开密钥进行加密。
步骤 6： 接着客户端继续发送 Change Cipher Spec 报文。该报文会提示服务器，在此报文之后的通信会采用 Pre-master secret 密钥加密。
步骤 7： 客户端发送 Finished 报文。该报文包含连接至今全部报文的整体校验值。这次握手协商是否能够成功，要以服务器是否能够正确
解密该报文作为判定标准。
步骤 8： 服务器同样发送 Change Cipher Spec 报文。
步骤 9： 服务器同样发送 Finished 报文。
步骤 10： 服务器和客户端的 Finished 报文交换完毕之后，SSL 连接就算建立完成。当然，通信会受到 SSL 的保护。从此处开始进行应用层协议的通信，即发送 HTTP 请求。
步骤 11： 应用层协议通信，即发送 HTTP 响应。
步骤 12： 最后由客户端断开连接。断开连接时，发送 close_notify 报文。上图做了一些省略，这步之后再发送 TCP FIN 报文来关闭与 TCP的通信。

在以上流程中，应用层发送数据时会附加一种叫做 MAC（Message Authentication Code）的报文摘要。MAC 能够查知报文是否遭到篡改，从而保护报文的完整性。
下面是对整个流程的图解。图中说明了从仅使用服务器端的公开密钥证书（服务器证书）建立 HTTPS 通信的整个过程。

![image-20200912161306114](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200912161306114.png)

## SSL 和 TLS

HTTPS 使用 SSL（Secure Socket Layer） 和 TLS（Transport LayerSecurity）这两个协议。

SSL 是独立于 HTTP 的协议

加密技术

SSL 采用一种叫做**公开密钥加密**（Public-key cryptography）的加密处理方式。近代的加密方法中加密算法是公开的，而密钥却是保密的。通过这种方式得以保持加密方法的安全性。

![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/8776693-cdb3f7cd595ae1c4.png)

**SSL**：（Secure Socket Layer，安全套接字层），为Netscape所研发，用以保障在Internet上数据传输之安全，利用数据加密(Encryption)技术，可确保数据在网络上之传输过程中不会被截取。当前版本为3.0。它已被广泛地用于Web浏览器与服务器之间的身份认证和加密数据传输。

SSL协议位于TCP/IP协议与各种应用层协议之间，为数据通讯提供安全支持。

SSL协议可分为两层：

- SSL记录协议（SSL Record Protocol）：它建立在可靠的传输协议（如TCP）之上，为高层协议提供数据封装、压缩、加密等基本功能的支持，定义了传输的格式。
- SSL握手协议（SSL Handshake Protocol）：它建立在SSL记录协议之上，用于在实际的数据传输开始前，通讯双方进行身份认证、协商加密算法、交换加密密钥等。

**TLS**：(Transport Layer Security，传输层安全协议)，用于两个应用程序之间提供保密性和数据完整性。
 TLS 1.0是IETF（Internet Engineering Task Force，Internet工程任务组）制定的一种新的协议，它建立在SSL 3.0协议规范之上，是SSL 3.0的后续版本，可以理解为SSL 3.1，它是写入了 [RFC](http://tools.ietf.org/html/rfc5246) 的。

该协议由两层组成：

- TLS 记录协议（TLS Record）较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。
- TLS 握手协议（TLS Handshake）。

SSL/TLS协议提供的服务主要有：

1. 认证用户和服务器，确保数据发送到正确的客户机和服务器；
2. 加密数据以防止数据中途被窃取；
3. 维护数据的完整性，确保数据在传输过程中不被改变



#### SSL 加密套件

加密套件（CipherList）是指在ssl通信中，服务器和客户端所使用的加密算法的组合。

- 密钥交换 用于决定客户端与服务器之间在握手的过程中如何认证。使用非对称加密算法来生成会话密钥，因为非对称算法不会将重要数据在通信中传输用到的算法包括RSA，Diffie-Hellman，ECDH，PSK等

- 加密算法 主要是对传输的数据进行加密传输用的。一般有对称加和非对称加密；所以真正要传输的数据会使用对称加密来进行加密。算法名称后通常会带有两个数字，分别表示密钥的长度和初始向量的长度，比如DES 56/56, RC2 56/128, RC4 128/128, AES 128/128, AES 256/256；

- 会话校验（MAC）算法，为了防止握手本身被窜改（这里极容易和证书签名算法混淆）。算法包括MD5，SHA等

- 第四部分是PRF（伪随机数函数），用于生成“master secret”

  

  ```undefined
  TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA
  从其名字可知，它是：
  基于TLS协议的；
  使用ECDHE、RSA作为密钥交换算法；
  加密算法是AES（密钥和初始向量的长度都是256）；
  MAC算法（这里就是哈希算法）是SHA。
  ```

  

### 2.TLS与SSL的差异

1. 版本号 : TLS记录格式与SSL记录格式相同，但版本号的值不同，TLS的版本1.0使用的版本号为SSLv3.1。
2. 报文鉴别码
3. 伪随机函数
4. 报警代码
5. 密文族和客户证书
6. certificate_verify和finished消息
7. 加密计算
8. 填充

### 3.TLS主要增强内容

**TLS的主要增强内容**

TLS的主要目标是使SSL更安全，并使协议的规范更精确和完善。TLS 在SSL v3.0 的基础上，提供了以下增强内容：

1. 更安全的MAC算法
2. 更严密的警报
3. “灰色区域”规范的更明确的定义

### 4. 密钥协商过程——TLS握手

由于非对称加密的速度比较慢，所以它一般用于密钥交换，双方通过公钥算法协商出一份密钥，然后通过对称加密来通信，当然，为了保证数据的完整性，在加密前要先经过HMAC的处理。

SSL缺省只进行server端的认证，客户端的认证是可选的



![img](https:////upload-images.jianshu.io/upload_images/8776693-a701a81e4d2569f7.png?imageMogr2/auto-orient/strip|imageView2/2/w/849/format/webp)

SSL.png

#### 4.1 客户端发出请求（ClientHello）

1. 支持的协议版本，比如TLS 1.0版
2. 一个客户端生成的随机数random_C，稍后用于生成”对话密钥”
3. 支持的加密方法，比如RSA公钥加密（密码套件）
4. 支持的压缩方法

#### 4.2 服务器回应(SeverHello)

1. 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信
2. 一个服务器生成的随机数random_S，稍后用于生成”对话密钥”
3. 确认使用的加密方法，比如RSA公钥加密
4. 服务器证书

**注**：在服务端向客户端发送的证书中没有提供足够的信息（证书公钥）的时候，还可以向客户端发送一个 Server Key Exchange，此外，对于非常重要的保密数据，服务端还需要对客户端进行验证，以保证数据传送给了安全的合法的客户端。服务端可以向客户端发出 Cerficate Request 消息，要求客户端发送证书对客户端的合法性进行验证。

最后服务端会发送一个Server Hello Done消息给客户端，表示Server Hello消息结束了。

#### 4.3 客户端回应（Certificate Verify）

1.**Client Key Exchange**：首先需要向服务端发送客户端的证书，让服务端来验证客户端的合法性。

2.**Certificate Verify**：客户端需要对服务端的证书进行检查，如果证书不是可信机构颁布、或者证书中的域名与实际域名不一致、或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从服务器证书中取出服务器的公钥。然后，向服务器发送下面三项信息：

1. **一个随机数**。该随机数用服务器公钥加密，防止被窃听（产生一个48个字节的Key，客户端使用一些加密算法(例如：RSA, Diffie-Hellman)产生一个48个字节的PreMaster Secret.

   **此时客户端已经获取全部的计算协商密钥需要的信息：两个明文随机数 random_C 和  random_S 与自己计算产生的 Pre-master，计算得到协商密钥: **

   

   ```bash
   master_secret =PRF(pre_master_secret, "master secret", ClientHello.random +ServerHello.random)
   
   pre_master_secret就是我们之前传送的随机密码串，”mastersecret”是一串ASCII码，再加上之前提到的random1和random2。PRF是在规范中约定的伪随机函数，它将密钥、ASCII码标签、哈希值整合在一起。各有一半的参数分别使用MD5和SHA-1获取哈希值。这是一种十分明智的做法，即使是想要单单破解相对简单MD5和SHA-1也不是那么容易的事情。而且这个函数会将返回值传给自身直至迭代到我们需要的位数
     客户端得到master_secret后，根据协议约定，我们需要利用PRF生成这个会话中所需要的各种密钥，称之为“密钥块”（key block）
   ```

   

2. **编码改变通知**，表示随后的信息都将用双方商定的加密方法和密钥发送（**ChangeCipherSpec**是一个独立的协议，体现在数据包中就是一个字节的数据，用于告知服务端，客户端已经切换到之前协商好的加密套件（Cipher Suite）的状态，准备使用之前协商好的加密套件加密数据并传输了

3. **客户端握手结束通知**，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的hash值，用来供服务器校验（在ChangecipherSpec传输完毕之后，客户端会使用之前协商好的加密套件和Session Secret加密一段 Finish 的数据传送给服务端，此数据是为了在正式传输应用数据之前对刚刚握手建立起来的加解密通道进行验证。）

   

#### 4.4 服务器的最后回应（Server Finish）

1. 使用私钥解密加密的Pre-master数据，基于之前交换的两个明文随机数 random_C 和 random_S，计算得到协商密钥:enc_key=Fuc(random_C, random_S, Pre-Master);
2. 计算之前所有接收信息的 hash 值，然后解密客户端发送的 encrypted_handshake_message，验证数据和密钥正确性;
3. 发送一个 ChangeCipherSpec（告知客户端已经切换到协商过的加密套件状态，准备使用加密套件和 Session Secret加密数据了）
4. 服务端也会使用 Session Secret 加密一段 Finish 消息发送给客户端，以验证之前通过握手建立起来的加解密通道是否成功。

根据之前的握手信息，如果客户端和服务端都能对Finish信息进行正常加解密且消息正确的被验证，则说明握手通道已经建立成功，接下来，双方可以使用上面产生的Session Secret对数据进行加密传输了。

#### 4.5  几个secret

**1. PreMaster secret**

PreMaster Secret是在客户端使用RSA或者Diffie-Hellman等加密算法生成的。它将用来跟服务端和客户端在Hello阶段产生的随机数结合在一起生成 Master Secret。PreMaster secret前两个字节是TLS的版本号，这是一个比较重要的用来核对握手数据的版本号。*服务端需要对密文中解密出来对的PreMaster版本号跟之前Client Hello阶段的版本号进行对比，如果版本号变低，则说明被串改，则立即停止发送任何消息*。

**2. Master secret**
 上面已经提到，由于服务端和客户端都有一份相同的PreMaster secret和随机数，这个随机数将作为后面产生Master secret的种子，结合PreMaster secret，客户端和服务端将计算出同样的Master secret。

Master secret是有系列的hash值组成的，它将作为数据加解密相关的secret的 Key Material 的一部分。Key Material最终解析出来的数据如下：

![img](https:////upload-images.jianshu.io/upload_images/8776693-671616dc6eecf06a.png?imageMogr2/auto-orient/strip|imageView2/2/w/244/format/webp)

MasterSecret.png

- write MAC key，就是session secret或者说是session key。
- Client write MAC key是客户端发数据的session secret，
- Server write MAC secret是服务端发送数据的session key。
- MAC(Message Authentication Code)，是一个数字签名，用来验证数据的完整性，可以检测到数据是否被串改。

### 5.应用数据传输

在所有的握手阶段都完成之后，就可以开始传送应用数据了。应用数据在传输之前，首先要附加上MAC secret，然后再对这个数据包使用write encryption key进行加密。在服务端收到密文之后，使用Client write encryption key进行解密，客户端收到服务端的数据之后使用Server write encryption key进行解密，然后使用各自的write MAC key对数据的完整性包括是否被串改进行验证。

### 6.会话缓存握手过程

### 6.1概述

为了加快建立握手的速度，减少协议带来的性能降低和资源消耗(具体分析在后文)，TLS 协议有两类会话缓存机制：

- 会话标识 session ID: 由服务器端支持，协议中的标准字段，因此基本所有服务器都支持，服务器端保存会话ID以及协商的通信信息，Nginx 中1M 内存约可以保存4000个 session ID 机器相关信息，占用服务器资源较多;
- 会话记录 session ticket :t需要服务器和客户端都支持，属于一个扩展字段，支持范围约60%(无可靠统计与来源)，将协商的通信信息加密之后发送给客户端保存，密钥只有服务器知道，占用服务器资源很少。
- 二者对比，主要是保存协商信息的位置与方式不同，类似与 http 中的 session 与 cookie。二者都存在的情况下，(nginx 实现)优先使用 session_ticket。

### 6.2 会话标识 session ID

​    (a) 如果客户端和服务器之间曾经建立了连接，服务器会在握手成功后返回 session ID，并保存对应的通信参数在服务器中;
 (b) 如果客户端再次需要和该服务器建立连接，则在 client_hello 中 session ID 中携带记录的信息，发送给服务器;
 (c) 服务器根据收到的 session ID 检索缓存记录，如果没有检索到货缓存过期，则按照正常的握手过程进行;
 (d) 如果检索到对应的缓存记录，则返回 change_cipher_spec 与 encrypted_handshake_message 信息，两个信息作用类似，encrypted_handshake_message 是到当前的通信参数与 master_secret的hash 值;
 (f) 如果客户端能够验证通过服务器加密数据，则客户端同样发送 change_cipher_spec 与 encrypted_handshake_message 信息;
 (g) 服务器验证数据通过，则握手建立成功，开始进行正常的加密数据通信。

### 6.3 会话记录 session ticket

​    (a) 如果客户端和服务器之间曾经建立了连接，服务器会在 new_session_ticket 数据中携带加密的 session_ticket 信息，客户端保存;
 (b) 如果客户端再次需要和该服务器建立连接，则在 client_hello 中扩展字段 session_ticket 中携带加密信息，一起发送给服务器;
 (c) 服务器解密 sesssion_ticket 数据，如果能够解密失败，则按照正常的握手过程进行;
 (d) 如果解密成功，则返回 change_cipher_spec 与 encrypted_handshake_message 信息，两个信息作用与 session ID 中类似;
 (f)如果客户端能够验证通过服务器加密数据，则客户端同样发送 change_cipher_spec与encrypted_handshake_message 信息;
 (g) 服务器验证数据通过，则握手建立成功，开始进行正常的加密数据通信。

### 7.总结

SSL客户端（也是TCP的客户端）在TCP链接建立之后，发出一个ClientHello来发起握手，这个消息里面包含了自己可实现的算法列表和其它一些需要的消息，SSL的服务器端会回应一个ServerHello，这里面确定了这次通信所需要的算法，然后发过去自己的证书（里面包含了身份和自己的公钥）。Client在收到这个消息后会生成一个秘密消息，用SSL服务器的公钥加密后传过去，SSL服务器端用自己的私钥解密后，会话密钥协商成功，双方可以用同一份会话密钥来通信了。





## 公开密钥加密

公开密钥加密使用一对非对称的密钥。一把叫做私有密钥（private key），另一把叫做公开密钥（public key）。顾名思义，私有密钥不能让其他任何人知道，而公开密钥则可以随意发布，任何人都可以获得。
使用公开密钥加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，再使用自己的私有密钥进行解密。利用这种方式，不需要发送用来解密的私有密钥，也不必担心密钥被攻击者窃听而盗走。另外，要想根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这并非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望的。但就目前的技术来看是
不太现实的。

![image-20200912151236130](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200912151236130.png)







## 对称加密和非对称加密

- 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
- 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

## [一计算机概述](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=一计算机概述)

### [（1），基本术语](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（1），基本术语)

#### [结点 （node）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-结点-（node）：)

```
网络中的结点可以是计算机，集线器，交换机或路由器等。Copy to clipboardErrorCopied
```

#### [链路（link ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-链路（link-）：)

```
从一个结点到另一个结点的一段物理线路。中间没有任何其他交点。Copy to clipboardErrorCopied
```

#### [主机（host）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-主机（host）：)

```
连接在因特网上的计算机.Copy to clipboardErrorCopied
```

#### [ISP（Internet Service Provider）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-isp（internet-service-provider）：)

```
因特网服务提供者（提供商）.Copy to clipboardErrorCopied
```

#### [IXP（Internet eXchange Point）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-ixp（internet-exchange-point）：)

```
互联网交换点IXP的主要作用就是允许两个网络直接相连并交换分组，而不需要再通过第三个网络来转发分组。.Copy to clipboardErrorCopied
```

#### [RFC(Request For Comments)](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-rfcrequest-for-comments)

```
意思是“请求评议”，包含了关于Internet几乎所有的重要的文字资料。Copy to clipboardErrorCopied
```

#### [广域网WAN（Wide Area Network）](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-广域网wan（wide-area-network）)

```
任务是通过长距离运送主机发送的数据Copy to clipboardErrorCopied
```

#### [城域网MAN（Metropolitan Area Network）](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-城域网man（metropolitan-area-network）)

```
用来将多个局域网进行互连Copy to clipboardErrorCopied
```

#### [局域网LAN（Local Area Network）](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-局域网lan（local-area-network）)

```
 学校或企业大多拥有多个互连的局域网Copy to clipboardErrorCopied
```

#### [个人区域网PAN（Personal Area Network）](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-个人区域网pan（personal-area-network）)

```
在个人工作的地方把属于个人使用的电子设备用无线技术连接起来的网络  Copy to clipboardErrorCopied
```

#### [端系统（end system）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-端系统（end-system）：)

```
处在因特网边缘的部分即是连接在因特网上的所有的主机.Copy to clipboardErrorCopied
```

#### [分组（packet ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-分组（packet-）：)

```
因特网中传送的数据单元。由首部header和数据段组成。分组又称为包，首部可称为包头。Copy to clipboardErrorCopied
```

#### [存储转发（store and forward ）:](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-存储转发（store-and-forward-）)

```
路由器收到一个分组，先存储下来，再检查其首部，查找转发表，按照首部中的目的地址，找到合适的接口转发出去。Copy to clipboardErrorCopied
```

#### [带宽（bandwidth）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-带宽（bandwidth）：)

```
在计算机网络中，表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”。常用来表示网络的通信线路所能传送数据的能力。单位是“比特每秒”，记为b/s。Copy to clipboardErrorCopied
```

#### [吞吐量（throughput ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-吞吐量（throughput-）：)

```
表示在单位时间内通过某个网络（或信道、接口）的数据量。吞吐量更经常地用于对现实世界中的网络的一种测量，以便知道实际上到底有多少数据量能够通过网络。吞吐量受网络的带宽或网络的额定速率的限制。Copy to clipboardErrorCopied
```

### [（2），重要知识点总结](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（2），重要知识点总结)

1，计算机网络（简称网络）把许多计算机连接在一起，而互联网把许多网络连接在一起，是网络的网络。

2，小写字母i开头的internet（互联网）是通用名词，它泛指由多个计算机网络相互连接而成的网络。在这些网络之间的通信协议（即通信规则）可以是任意的。

大写字母I开头的Internet（互联网）是专用名词，它指全球最大的，开放的，由众多网络相互连接而成的特定的互联网，并采用TCP/IP协议作为通信规则，其前身为ARPANET。Internet的推荐译名为因特网，现在一般流行称为互联网。

3，路由器是实现分组交换的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能。分组交换采用存储转发技术，表示把一个报文（要发送的整块数据）分为几个分组后再进行传送。在发送报文之前，先把较长的报文划分成为一个个更小的等长数据段。在每个数据端的前面加上一些由必要的控制信息组成的首部后，就构成了一个分组。分组又称为包。分组是在互联网中传送的数据单元，正是由于分组的头部包含了诸如目的地址和源地址等重要控制信息，每一个分组才能在互联网中独立的选择传输路径，并正确地交付到分组传输的终点。

4，互联网按工作方式可划分为边缘部分和核心部分。主机在网络的边缘部分，其作用是进行信息处理。由大量网络和连接这些网络的路由器组成核心部分，其作用是提供连通性和交换。

5，计算机通信是计算机中进程（即运行着的程序）之间的通信。计算机网络采用的通信方式是客户-服务器方式（C/S方式）和对等连接方式（P2P方式）。

6，客户和服务器都是指通信中所涉及的应用进程。客户是服务请求方，服务器是服务提供方。

7，按照作用范围的不同，计算机网络分为广域网WAN，城域网MAN，局域网LAN，个人区域网PAN。

8，计算机网络最常用的性能指标是：速率，带宽，吞吐量，时延（发送时延，处理时延，排队时延），时延带宽积，往返时间和信道利用率。

9，网络协议即协议，是为进行网络中的数据交换而建立的规则。计算机网络的各层以及其协议集合，称为网络的体系结构。

10，五层体系结构由应用层，运输层，网络层（网际层），数据链路层，物理层组成。运输层最主要的协议是TCP和UDP协议，网络层最重要的协议是IP协议。

## [二物理层](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=二物理层)

### [（1），基本术语](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（1），基本术语-1)

#### [数据（data）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33数据（data）：)

```
运送消息的实体。Copy to clipboardErrorCopied
```

#### [信号（signal）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33信号（signal）：)

```
数据的电气的或电磁的表现。或者说信号是适合在传输介质上传输的对象。Copy to clipboardErrorCopied
```

#### [码元（ code）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33码元（-code）：-)

```
在使用时间域（或简称为时域）的波形来表示数字信号时，代表不同离散数值的基本波形。Copy to clipboardErrorCopied
```

#### [单工（simplex ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33单工（simplex-）：)

```
只能有一个方向的通信而没有反方向的交互。Copy to clipboardErrorCopied
```

#### [半双工（half duplex ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33半双工（half-duplex-）：)

```
通信的双方都可以发送信息，但不能双方同时发送(当然也就不能同时接收)。Copy to clipboardErrorCopied
```

#### [全双工（full duplex）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33全双工（full-duplex）：-)

```
通信的双方可以同时发送和接收信息。Copy to clipboardErrorCopied
```

#### [奈氏准则：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33奈氏准则：)

```
在任何信道中，码元的传输的效率是有上限的，传输速率超过此上限，就会出现严重的码间串扰问题，使接收端对码元的判决（即识别）成为不可能。Copy to clipboardErrorCopied
```

#### [基带信号（baseband signal）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33基带信号（baseband-signal）：)

```
来自信源的信号。指没有经过调制的数字信号或模拟信号。Copy to clipboardErrorCopied
```

#### [带通（频带）信号（bandpass signal）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-带通（频带）信号（bandpass-signal）：)

```
把基带信号经过载波调制后，把信号的频率范围搬移到较高的频段以便在信道中传输（即仅在一段频率范围内能够通过信道），这里调制过后的信号就是带通信号。Copy to clipboardErrorCopied
```

#### [调制（modulation ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-调制（modulation-）：)

```
对信号源的信息进行处理后加到载波信号上，使其变为适合在信道传输的形式的过程。Copy to clipboardErrorCopied
```

#### [信噪比（signal-to-noise ratio ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33信噪比（signal-to-noise-ratio-）：)

```
指信号的平均功率和噪声的平均功率之比，记为S/N。信噪比（dB）=10*log10（S/N）Copy to clipboardErrorCopied
```

#### [信道复用（channel multiplexing ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33信道复用（channel-multiplexing-）：)

```
指多个用户共享同一个信道。（并不一定是同时）Copy to clipboardErrorCopied
```

#### [比特率（bit rate ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33比特率（bit-rate-）：)

```
单位时间（每秒）内传送的比特数。Copy to clipboardErrorCopied
```

#### [波特率（baud rate）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33波特率（baud-rate）：)

```
单位时间载波调制状态改变的次数。针对数据信号对载波的调制速率。Copy to clipboardErrorCopied
```

#### [复用（multiplexing）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33复用（multiplexing）：)

```
共享信道的方法Copy to clipboardErrorCopied
```

#### [ADSL（Asymmetric Digital Subscriber Line ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33adsl（asymmetric-digital-subscriber-line-）：-)

```
非对称数字用户线。Copy to clipboardErrorCopied
```

#### [光纤同轴混合网（HFC网）:](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33光纤同轴混合网（hfc网）)

```
在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网Copy to clipboardErrorCopied
```

### [（2），重要知识点总结](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（2），重要知识点总结-1)

1，物理层的主要任务就是确定与传输媒体接口有关的一些特性，如机械特性，电气特性，功能特性，过程特性。

2，一个数据通信系统可划分为三大部分，即源系统，传输系统，目的系统。源系统包括源点（或源站，信源）和发送器，目的系统包括接收器和终点。

3，通信的目的是传送消息。如话音，文字，图像等都是消息，数据是运送消息的实体。信号则是数据的电器或电磁的表现。

4，根据信号中代表消息的参数的取值方式不同，信号可分为模拟信号（或连续信号）和数字信号（或离散信号）。在使用时间域（简称时域）的波形表示数字信号时，代表不同离散数值的基本波形称为码元。

5，根据双方信息交互的方式，通信可划分为单向通信（或单工通信），双向交替通信（或半双工通信），双向同时通信（全双工通信）。

6，来自信源的信号称为基带信号。信号要在信道上传输就要经过调制。调制有基带调制和带通调制之分。最基本的带通调制方法有调幅，调频和调相。还有更复杂的调制方法，如正交振幅调制。

7，要提高数据在信道上的传递速率，可以使用更好的传输媒体，或使用先进的调制技术。但数据传输速率不可能任意被提高。

8，传输媒体可分为两大类，即导引型传输媒体（双绞线，同轴电缆，光纤）和非导引型传输媒体（无线，红外，大气激光）。

9，为了有效利用光纤资源，在光纤干线和用户之间广泛使用无源光网络PON。无源光网络无需配备电源，其长期运营成本和管理成本都很低。最流行的无源光网络是以太网无源光网络EPON和吉比特无源光网络GPON。

### [（3），最重要的知识点](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（3），最重要的知识点)

#### [**①，物理层的任务**](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333①，物理层的任务)

透明地传送比特流。也可以将物理层的主要任务描述为确定与传输媒体的接口的一些特性，即：机械特性（接口所用接线器的一些物理属性如形状尺寸），电气特性（接口电缆的各条线上出现的电压的范围），功能特性（某条线上出现的某一电平的电压的意义），过程特性（对于不同功能能的各种可能事件的出现顺序）。

#### [拓展：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=拓展：)

物理层考虑的是怎样才能在连接各种计算机的传输媒体上传输数据比特流，而不是指具体的传输媒体。现有的计算机网络中的硬件设备和传输媒体的种类非常繁多，而且通信手段也有许多不同的方式。物理层的作用正是尽可能地屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异，这样就可以使数据链路层只考虑完成本层的协议和服务，而不必考虑网络的具体传输媒体和通信手段是什么。

#### [**②，几种常用的信道复用技术**](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333②，几种常用的信道复用技术)

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1627f7a170ec6611)

### [**③，几种常用的宽带接入技术，主要是ADSL和FTTx**](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333③，几种常用的宽带接入技术，主要是adsl和fttx)

用户到互联网的宽带接入方法有非对称数字用户线ADSL（用数字技术对现有的模拟电话线进行改造，而不需要重新布线。ASDL的快速版本是甚高速数字用户线VDSL。），光纤同轴混合网HFC（是在目前覆盖范围很广的有线电视网的基础上开发的一种居民宽带接入网）和FTTx（即光纤到······）。

## [三数据链路层](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=三数据链路层)

### [（1），基本术语](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（1），基本术语-2)

#### [链路（link）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-链路（link）：)

```
一个结点到相邻结点的一段物理链路Copy to clipboardErrorCopied
```

#### [数据链路（data link）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-数据链路（data-link）：)

```
把实现控制数据运输的协议的硬件和软件加到链路上就构成了数据链路Copy to clipboardErrorCopied
```

#### [循环冗余检验CRC（Cyclic Redundancy Check）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-循环冗余检验crc（cyclic-redundancy-check）：)

```
为了保证数据传输的可靠性，CRC是数据链路层广泛使用的一种检错技术Copy to clipboardErrorCopied
```

#### [帧（frame）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-帧（frame）：)

```
一个数据链路层的传输单元，由一个数据链路层首部和其携带的封包所组成协议数据单元。Copy to clipboardErrorCopied
```

#### [MTU（Maximum Transfer Uint ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-mtu（maximum-transfer-uint-）：)

```
最大传送单元。帧的数据部分的的长度上限。Copy to clipboardErrorCopied
```

#### [误码率BER（Bit Error Rate ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-误码率ber（bit-error-rate-）：)

```
在一段时间内，传输错误的比特占所传输比特总数的比率。Copy to clipboardErrorCopied
```

#### [PPP（Point-to-Point Protocol ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-ppp（point-to-point-protocol-）：)

```
点对点协议。即用户计算机和ISP进行通信时所使用的数据链路层协议。以下是PPP帧的示意图:Copy to clipboardErrorCopied
```

![PPP](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1627f8291c6b032c)

#### [MAC地址（Media Access Control或者Medium Access Control）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-mac地址（media-access-control或者medium-access-control）：)

```
意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。
在OSI模型中，第三层网络层负责 IP地址，第二层数据链路层则负责 MAC地址。
因此一个主机会有一个MAC地址，而每个网络位置会有一个专属于它的IP地址  。
地址是识别某个系统的重要标识符，“名字指出我们所要寻找的资源，地址指出资源所在的地方，路由告诉我们如何到达该处”Copy to clipboardErrorCopied
```

#### [网桥（bridge）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-网桥（bridge）：)

```
 一种用于数据链路层实现中继，连接两个或多个局域网的网络互连设备。Copy to clipboardErrorCopied
```

#### [交换机（switch ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-交换机（switch-）：)

```
广义的来说，交换机指的是一种通信系统中完成信息交换的设备。这里工作在数据链路层的交换机指的是交换式集线器，其实质是一个多接口的网桥Copy to clipboardErrorCopied
```

### [（2），重要知识点总结](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（2），重要知识点总结-2)

1，链路是从一个结点到相邻节点的一段物理链路，数据链路则在链路的基础上增加了一些必要的硬件（如网络适配器）和软件（如协议的实现）

2，数据链路层使用的主要是**点对点信道**和**广播信道**两种。

3，数据链路层传输的协议数据单元是帧。数据链路层的三个基本问题是：**封装成帧**，**透明传输**和**差错检测**

4，**循环冗余检验CRC**是一种检错方法，而帧检验序列FCS是添加在数据后面的冗余码

5，**点对点协议PPP**是数据链路层使用最多的一种协议，它的特点是：简单，只检测差错而不去纠正差错，不使用序号，也不进行流量控制，可同时支持多种网络层协议

6，PPPoE是为宽带上网的主机使用的链路层协议

7，局域网的优点是：具有广播功能，从一个站点可方便地访问全网；便于系统的扩展和逐渐演变；提高了系统的可靠性，可用性和生存性。

8，共向媒体通信资源的方法有二：一是静态划分信道(各种复用技术)，而是动态媒体接入控制，又称为多点接入（随即接入或受控接入）

9，计算机与外接局域网通信需要通过通信适配器（或网络适配器），它又称为网络接口卡或网卡。**计算器的硬件地址就在适配器的ROM中**。

10，以太网采用的无连接的工作方式，对发送的数据帧不进行编号，也不要求对方发回确认。目的站收到有差错帧就把它丢掉，其他什么也不做

11，以太网采用的协议是具有冲突检测的**载波监听多点接入CSMA/CD**。协议的特点是：**发送前先监听，边发送边监听，一旦发现总线上出现了碰撞，就立即停止发送。然后按照退避算法等待一段随机时间后再次发送。** 因此，每一个站点在自己发送数据之后的一小段时间内，存在这遭遇碰撞的可能性。以太网上的各站点平等的争用以太网信道

12，以太网的适配器具有过滤功能，它只接收单播帧，广播帧和多播帧。

13，使用集线器可以在物理层扩展以太网（扩展后的以太网仍然是一个网络）

### [（3），最重要的知识点](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（3），最重要的知识点-1)

#### [① 数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（PPP协议以及CSMA/CD协议）的特点](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=①-font-color999999数据链路层的点对点信道和广播信道的特点，以及这两种信道所使用的协议（ppp协议以及csmacd协议）的特点)

#### [② 数据链路层的三个基本问题：**封装成帧**，**透明传输**，**差错检测**](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=②-font-color999999数据链路层的三个基本问题：封装成帧，透明传输，差错检测)

#### [③ 以太网的MAC层硬件地址](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=③-font-color999999以太网的mac层硬件地址)

#### [④ 适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=④-font-color999999适配器，转发器，集线器，网桥，以太网交换机的作用以及适用场合)

## [四网络层](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333-id4四网络层)

### [（1），基本术语](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（1），基本术语-3)

#### [虚电路（Virtual Circuit）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33虚电路（virtual-circuit）：)

```
在两个终端设备的逻辑或物理端口之间，通过建立的双向的透明传输通道。虚电路表示这只是一条逻辑上的连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。Copy to clipboardErrorCopied
```

#### [IP（Internet Protocol ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33ip（internet-protocol-）：)

```
网际协议 IP 是 TCP/IP体系中两个最主要的协议之一，是TCP/IP体系结构网际层的核心。配套的有ARP，RARP，ICMP，IGMP。Copy to clipboardErrorCopied
```

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1627f92f98436286)

#### [ARP（Address Resolution Protocol）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33arp（address-resolution-protocol）：)

```
地址解析协议Copy to clipboardErrorCopied
```

#### [ICMP（Internet Control Message Protocol ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33icmp（internet-control-message-protocol-）：)

```
网际控制报文协议  （ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。）Copy to clipboardErrorCopied
```

#### [子网掩码（subnet mask ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33子网掩码（subnet-mask-）：)

```
它是一种用来指明一个IP地址的哪些位标识的是主机所在的子网以及哪些位标识的是主机的位掩码。子网掩码不能单独存在，它必须结合IP地址一起使用。Copy to clipboardErrorCopied
```

#### [CIDR（ Classless Inter-Domain Routing ）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-cidr（-classless-inter-domain-routing-）：)

```
无分类域间路由选择  （特点是消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，并使用各种长度的“网络前缀”(network-prefix)来代替分类地址中的网络号和子网号）Copy to clipboardErrorCopied
```

#### [默认路由（default route）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33默认路由（default-route）：)

```
当在路由表中查不到能到达目的地址的路由时，路由器选择的路由。默认路由还可以减小路由表所占用的空间和搜索路由表所用的时间。Copy to clipboardErrorCopied
```

#### [路由选择算法（Virtual Circuit）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33路由选择算法（virtual-circuit）：)

```
路由选择协议的核心部分。因特网采用自适应的，分层次的路由选择协议。Copy to clipboardErrorCopied
```

### [（2），重要知识点总结](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（2），重要知识点总结-3)

1，TCP/IP协议中的网络层向上只提供简单灵活的，无连接的，尽最大努力交付的数据报服务。网络层不提供服务质量的承诺，不保证分组交付的时限所传送的分组可能出错，丢失，重复和失序。进程之间通信的可靠性由运输层负责

2，在互联网的交付有两种，一是在本网络直接交付不用经过路由器，另一种是和其他网络的间接交付，至少经过一个路由器，但最后一次一定是直接交付

3，分类的IP地址由网络号字段（指明网络）和主机号字段（指明主机）组成。网络号字段最前面的类别指明IP地址的类别。IP地址是一种分等级的地址结构。IP地址管理机构分配IP地址时只分配网络号，主机号由得到该网络号的单位自行分配。路由器根据目的主机所连接的网络号来转发分组。一个路由器至少连接到两个网络，所以一个路由器至少应当有两个不同的IP地址

4，IP数据报分为首部和数据两部分。首部的前一部分是固定长度，共20字节，是所有IP数据包必须具有的（源地址，目的地址，总长度等重要地段都固定在首部）。一些长度可变的可选字段固定在首部的后面。IP首部中的生存时间给出了IP数据报在互联网中所能经过的最大路由器数。可防止IP数据报在互联网中无限制的兜圈子。

5，地址解析协议ARP把IP地址解析为硬件地址。ARP的高速缓存可以大大减少网络上的通信量。因为这样可以使主机下次再与同样地址的主机通信时，可以直接从高速缓存中找到所需要的硬件地址而不需要再去广播方式发送ARP请求分组

6，无分类域间路由选择CIDR是解决目前IP地址紧缺的一个好办法。CIDR记法把IP地址后面加上斜线“/”，然后写上前缀所所占的位数。前缀（或网络前缀用来指明网络），前缀后面的部分是后缀，用来指明主机。CIDR把前缀都相同的连续的IP地址组成一个“CIDR地址块”，IP地址分配都以CIDR地址块为单位。

7， 网际控制报文协议是IP层的协议.ICMP报文作为IP数据报的数据，加上首部后组成IP数据报发送出去。使用ICMP数据报并不是为了实现可靠传输。ICMP允许主机或路由器报告差错情况和提供有关异常情况的报告。ICMP报文的种类有两种 ICMP差错报告报文和ICMP询问报文。

8，要解决IP地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本IP协议-IPv6。IPv6所带来的变化有①更大的地址空间（采用128位地址）②灵活的首部格式③改进的选项④支持即插即用⑤支持资源的预分配⑥IPv6的首部改为8字节对齐。另外IP数据报的目的地址可以是以下三种基本类型地址之一：单播，多播和任播

9，虚拟专用网络VPN利用公用的互联网作为本机构专用网之间的通信载体。VPN内使用互联网的专用地址。一个VPN至少要有一个路由器具有合法的全球IP地址，这样才能和本系统的另一个VPN通过互联网进行通信。所有通过互联网传送的数据都需要加密

10， MPLS的特点是：①支持面向连接的服务质量②支持流量工程，平衡网络负载③有效的支持虚拟专用网VPN。MPLS在入口节点给每一个IP数据报打上固定长度的“标记”，然后根据标记在第二层（链路层）用硬件进行转发（在标记交换路由器中进行标记交换），因而转发速率大大加快。

### [（3），最重要知识点](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（3），最重要知识点)

#### [① 虚拟互联网络的概念](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=①-font-color999999虚拟互联网络的概念)

#### [② IP地址和物理地址的关系](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=②-font-color999999ip地址和物理地址的关系)

#### [③ 传统的分类的IP地址（包括子网掩码）和无分类域间路由选择CIDR](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=③-font-color999999-传统的分类的ip地址（包括子网掩码）和无分类域间路由选择cidr)

#### [④ 路由选择协议的工作原理](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=④-font-color999999-路由选择协议的工作原理)

## [五运输层](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333-id5五运输层)

### [（1），基本术语](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（1），基本术语-4)

#### [进程（process）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33进程（process）：)

```
指计算机中正在运行的程序实体Copy to clipboardErrorCopied
```

#### [应用进程互相通信：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33应用进程互相通信：)

```
一台主机的进程和另一台主机中的一个进程交换数据的过程（另外注意通信真正的端点不是主机而是主机中的进程，也就是说端到端的通信是应用进程之间的通信）Copy to clipboardErrorCopied
```

#### [传输层的复用与分用：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33传输层的复用与分用：)

```
复用指发送方不同的进程都可以通过统一个运输层协议传送数据。分用指接收方的运输层在剥去报文的首部后能把这些数据正确的交付到目的应用进程。 Copy to clipboardErrorCopied
```

#### [TCP（Transmission Control Protocol）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33tcp（transmission-control-protocol）：)

```
传输控制协议Copy to clipboardErrorCopied
```

#### [UDP（User Datagram Protocol）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33udp（user-datagram-protocol）：)

```
用户数据报协议Copy to clipboardErrorCopied
```

#### [端口（port）（link）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33端口（port）（link）：)

```
端口的目的是为了确认对方机器是那个进程在于自己进行交互，比如MSN和QQ的端口不同，如果没有端口就可能出现QQ进程和MSN交互错误。端口又称协议端口号。 Copy to clipboardErrorCopied
```

#### [停止等待协议（link）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33停止等待协议（link）：)

```
指发送方每发送完一个分组就停止发送，等待对方确认，在收到确认之后在发送下一个分组。Copy to clipboardErrorCopied
```

#### [流量控制（link）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33流量控制（link）：)

```
就是让发送方的发送速率不要太快，既要让接收方来得及接收，也不要使网络发生拥塞。Copy to clipboardErrorCopied
```

#### [拥塞控制（link）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33拥塞控制（link）：)

```
防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。Copy to clipboardErrorCopied
```

### [（2），重要知识点总结](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（2），重要知识点总结-4)

1，运输层提供应用进程之间的逻辑通信，也就是说，运输层之间的通信并不是真正在两个运输层之间直接传输数据。运输层向应用层屏蔽了下面网络的细节（如网络拓补，所采用的路由选择协议等），它使应用进程之间看起来好像两个运输层实体之间有一条端到端的逻辑通信信道。

2，网络层为主机提供逻辑通信，而运输层为应用进程之间提供端到端的逻辑通信。

3，运输层的两个重要协议是用户数据报协议UDP和传输控制协议TCP。按照OSI的术语，两个对等运输实体在通信时传送的数据单位叫做运输协议数据单元TPDU（Transport Protocol Data Unit）。但在TCP/IP体系中，则根据所使用的协议是TCP或UDP，分别称之为TCP报文段或UDP用户数据报。

4，UDP在传送数据之前不需要先建立连接，远地主机在收到UDP报文后，不需要给出任何确认。虽然UDP不提供可靠交付，但在某些情况下UDP确是一种最有效的工作方式。 TCP提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。TCP不提供广播或多播服务。由于TCP要提供可靠的，面向连接的传输服务，这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。

5，硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层各种协议进程与运输实体进行层间交互的一种地址。UDP和TCP的首部格式中都有源端口和目的端口这两个重要字段。当运输层收到IP层交上来的运输层报文时，就能够 根据其首部中的目的端口号把数据交付应用层的目的应用层。（两个进程之间进行通信不光要知道对方IP地址而且要知道对方的端口号(为了找到对方计算机中的应用进程)）

6，运输层用一个16位端口号标志一个端口。端口号只有本地意义，它只是为了标志计算机应用层中的各个进程在和运输层交互时的层间接口。在互联网的不同计算机中，相同的端口号是没有关联的。协议端口号简称端口。虽然通信的终点是应用进程，但只要把所发送的报文交到目的主机的某个合适端口，剩下的工作（最后交付目的进程）就由TCP和UDP来完成。

7，运输层的端口号分为服务器端使用的端口号（0~~1023指派给熟知端口，1024~~49151是登记端口号）和客户端暂时使用的端口号（49152~65535）

8，UDP的主要特点是①无连接②尽最大努力交付③面向报文④无拥塞控制⑤支持一对一，一对多，多对一和多对多的交互通信⑥首部开销小（只有四个字段：源端口，目的端口，长度和检验和）

9，TCP的主要特点是①面向连接②每一条TCP连接只能是一对一的③提供可靠交付④提供全双工通信⑤面向字节流

10，TCP用主机的IP地址加上主机上的端口号作为TCP连接的端点。这样的端点就叫做套接字（socket）或插口。套接字用（IP地址：端口号）来表示。每一条TCP连接唯一被通信两端的两个端点所确定。

11，停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

12，为了提高传输效率，发送方可以不使用低效率的停止等待协议，而是采用流水线传输。流水线传输就是发送方可连续发送多个分组，不必每发完一个分组就停下来等待对方确认。这样可使信道上一直有数据不间断的在传送。这种传输方式可以明显提高信道利用率。

13，停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重转时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为自动重传请求ARQ。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。连续ARQ协议可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。

14，TCP报文段的前20个字节是固定的，后面有4n字节是根据需要增加的选项。因此，TCP首部的最小长度是20字节。

15，TCP使用滑动窗口机制。发送窗口里面的序号表示允许发送的序号。发送窗口后沿的后面部分表示已发送且已收到确认，而发送窗口前沿的前面部分表示不允许发送。发送窗口后沿的变化情况有两种可能，即不动（没有收到新的确认）和前移（收到了新的确认）。发送窗口的前沿通常是不断向前移动的。一般来说，我们总是希望数据传输更快一些。但如果发送方把数据发送的过快，接收方就可能来不及接收，这就会造成数据的丢失。所谓流量控制就是让发送方的发送速率不要太快，要让接收方来得及接收。

16，在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

17，为了进行拥塞控制，TCP发送方要维持一个拥塞窗口cwnd的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

18，TCP的拥塞控制采用了四种算法，即慢开始，拥塞避免，快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。

19，运输连接的三个阶段，即：连接建立，数据传送和连接释放。

20，主动发起TCP连接建立的应用进程叫做客户，而被动等待连接建立的应用进程叫做服务器。TCP连接采用三报文握手机制。服务器要确认用户的连接请求，然后客户要对服务器的确认进行确认。

21，TCP的连接释放采用四报文握手机制。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发送连接释放通知，对方确认后就完全关闭了TCP连接

### [（3），最重要的知识点](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（3），最重要的知识点-2)

#### [① 端口和套接字的意义](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=①-font-color999999端口和套接字的意义)

#### [② 无连接UDP的特点](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=②-font-color999999无连接udp的特点)

#### [③ 面向连接TCP的特点](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=③-font-color999999面向连接tcp的特点)

#### [④ 在不可靠的网络上实现可靠传输的工作原理，停止等待协议和ARQ协议](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=④-font-color999999在不可靠的网络上实现可靠传输的工作原理，停止等待协议和arq协议)

#### [① TCP的滑动窗口，流量控制，拥塞控制和连接管理](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=①-font-color999999tcp的滑动窗口，流量控制，拥塞控制和连接管理)

## [六应用层](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333-id6六应用层)

### [（1）基本术语](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（1），基本术语-5)

#### [域名系统（DNS）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-域名系统（dns）：)

```
DNS（Domain Name System，域名系统），万维网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。DNS协议运行在UDP协议之上，使用端口号53。在RFC文档中RFC 2181对DNS有规范说明，RFC 2136对DNS的动态更新进行说明，RFC 2308对DNS查询的反向缓存进行说明。Copy to clipboardErrorCopied
```

#### [文件传输协议（FTP）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-文件传输协议（ftp）：)

```
 FTP 是File TransferProtocol（文件传输协议）的英文简称，而中文简称为“文传协议”。用于Internet上的控制文件的双向传输。同时，它也是一个应用程序（Application）。
 基于不同的操作系统有不同的FTP应用程序，而所有这些应用程序都遵守同一种协议以传输文件。在FTP的使用当中，用户经常遇到两个概念："下载"（Download）和"上传"（Upload）。
 "下载"文件就是从远程主机拷贝文件至自己的计算机上；"上传"文件就是将文件从自己的计算机中拷贝至远程主机上。用Internet语言来说，用户可通过客户机程序向（从）远程主机上传（下载）文件。Copy to clipboardErrorCopied
```

#### [简单文件传输协议（TFTP）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-简单文件传输协议（tftp）：)

```
TFTP（Trivial File Transfer Protocol,简单文件传输协议）是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。端口号为69。Copy to clipboardErrorCopied
```

#### [远程终端协议（TELENET）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-远程终端协议（telenet）：)

```
Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的能力。
在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。
可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。Copy to clipboardErrorCopied
```

#### [万维网（WWW）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-万维网（www）：)

```
WWW是环球信息网的缩写，（亦作“Web”、“WWW”、“'W3'”，英文全称为“World Wide Web”），中文名字为“万维网”，"环球网"等，常简称为Web。分为Web客户端和Web服务器程序。
WWW可以让Web客户端（常用浏览器）访问浏览Web服务器上的页面。是一个由许多互相链接的超文本组成的系统，通过互联网访问。在这个系统中，每个有用的事物，称为一样“资源”；并且由一个全局“统一资源标识符”（URI）标识；这些资源通过超文本传输协议（Hypertext Transfer Protocol）传送给用户，而后者通过点击链接来获得资源。
万维网联盟（英语：World Wide Web Consortium，简称W3C），又称W3C理事会。1994年10月在麻省理工学院（MIT）计算机科学实验室成立。万维网联盟的创建者是万维网的发明者蒂姆·伯纳斯-李。
万维网并不等同互联网，万维网只是互联网所能提供的服务其中之一，是靠着互联网运行的一项服务。Copy to clipboardErrorCopied
```

#### [万维网的大致工作工程：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-万维网的大致工作工程：)

![万维网的大致工作工程](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/1627ff96a96087af)

#### [统一资源定位符（URL）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-统一资源定位符（url）：)

```
统一资源定位符是对可以从互联网上得到的资源的位置和访问方法的一种简洁的表示，是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。 Copy to clipboardErrorCopied
```

#### [超文本传输协议（HTTP）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-超文本传输协议（http）：)

```
超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。
设计HTTP最初的目的是为了提供一种发布和接收HTML页面的方法。1960年美国人Ted Nelson构思了一种通过计算机处理文本信息的方法，并称之为超文本（hypertext）,这成为了HTTP超文本传输协议标准架构的发展根基。Copy to clipboardErrorCopied
```

#### [代理服务器（Proxy Server）：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-代理服务器（proxy-server）：)

```
 代理服务器（Proxy Server）是一种网络实体，它又称为万维网高速缓存。
 代理服务器把最近的一些请求和响应暂存在本地磁盘中。当新请求到达时，若代理服务器发现这个请求与暂时存放的的请求相同，就返回暂存的响应，而不需要按URL的地址再次去互联网访问该资源。
 代理服务器可在客户端或服务器工作，也可以在中间系统工作。 Copy to clipboardErrorCopied
```

#### [http请求头：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33-http请求头：)

```
http请求头，HTTP客户程序（例如浏览器），向服务器发送请求的时候必须指明请求类型（一般是GET或者POST）。如有必要，客户程序还可以选择发送其他的请求头。
- Accept：浏览器可接受的MIME类型。
- Accept-Charset：浏览器可接受的字符集。
- Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。
- Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。
- Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。
- Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。
- Content-Length：表示请求消息正文的长度。
- Cookie：这是最重要的请求头信息之一
- From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。
- Host：初始URL中的主机和端口。
- If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。
- Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。
- Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。
- User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。Copy to clipboardErrorCopied
```

#### [简单邮件传输协议(SMTP)：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33简单邮件传输协议smtp：)

```
 SMTP（Simple Mail Transfer Protocol）即简单邮件传输协议,它是一组用于由源地址到目的地址传送邮件的规则，由它来控制信件的中转方式。
 SMTP协议属于TCP/IP协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。
 通过SMTP协议所指定的服务器,就可以把E-mail寄到收信人的服务器上了，整个过程只要几分钟。SMTP服务器则是遵循SMTP协议的发送邮件服务器，用来发送或中转发出的电子邮件。Copy to clipboardErrorCopied
```

#### [搜索引擎：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33搜索引擎：)

```
 搜索引擎（Search Engine）是指根据一定的策略、运用特定的计算机程序从互联网上搜集信息，在对信息进行组织和处理后，为用户提供检索服务，将用户检索相关的信息展示给用户的系统。
 搜索引擎包括全文索引、目录索引、元搜索引擎、垂直搜索引擎、集合式搜索引擎、门户搜索引擎与免费链接列表等。Copy to clipboardErrorCopied
```

#### [全文索引：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33全文索引：)

```
 全文索引技术是目前搜索引擎的关键技术。
试想在1M大小的文件中搜索一个词，可能需要几秒，在100M的文件中可能需要几十秒，如果在更大的文件中搜索那么就需要更大的系统开销，这样的开销是不现实的。
所以在这样的矛盾下出现了全文索引技术，有时候有人叫倒排文档技术。Copy to clipboardErrorCopied
```

#### [目录索引：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33目录索引：)

```
目录索引（ search index/directory)，顾名思义就是将网站分门别类地存放在相应的目录中，因此用户在查询信息时，可选择关键词搜索，也可按分类目录逐层查找。Copy to clipboardErrorCopied
```

#### [垂直搜索引擎：](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color99cc33垂直搜索引擎：)

```
垂直搜索引擎是针对某一个行业的专业搜索引擎，是搜索引擎的细分和延伸，是对网页库中的某类专门的信息进行一次整合，定向分字段抽取出需要的数据进行处理后再以某种形式返回给用户。
垂直搜索是相对通用搜索引擎的信息量大、查询不准确、深度不够等提出来的新的搜索引擎服务模式，通过针对某一特定领域、某一特定人群或某一特定需求提供的有一定价值的信息和相关服务。
其特点就是“专、精、深”，且具有行业色彩，相比较通用搜索引擎的海量信息无序化，垂直搜索引擎则显得更加专注、具体和深入。Copy to clipboardErrorCopied
```

### [（2）重要知识点总结](https://snailclimb.gitee.io/javaguide/#/docs/network/干货：计算机网络知识总结?id=font-color003333（2），重要知识点总结-5)

1，文件传输协议（FTP）使用TCP可靠的运输服务。FTP使用客户服务器方式。一个FTP服务器进程可以同时为多个用户提供服务。在进进行文件传输时，FTP的客户和服务器之间要先建立两个并行的TCP连接:控制连接和数据连接。实际用于传输文件的是数据连接。

2，万维网客户程序与服务器之间进行交互使用的协议是超文本传输协议HTTP。HTTP使用TCP连接进行可靠传输。但HTTP本身是无连接、无状态的。HTTP/1.1协议使用了持续连接（分为非流水线方式和流水线方式）

3，电子邮件把邮件发送到收件人使用的邮件服务器，并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器读取，相当于电子邮箱。

4，一个电子邮件系统有三个重要组成构件：用户代理、邮件服务器、邮件协议（包括邮件发送协议，如SMTP，和邮件读取协议，如POP3和IMAP）。用户代理和邮件服务器都要运行这些协议。



### ① 域名系统-从域名解析出IP地址



### ② 访问一个网站大致的过程

在介绍游览器访问一个网址的全过程之前,先来介绍一下网络连接的一些常识,方便大家阅读.

- MAC地址：在设备与设备之间数据通信时用来标记收发双方（网卡的序列号）
- IP地址：在逻辑上标记一台电脑，用来指引数据包的收发方向（相当于电脑的序列号）
- 网络掩码：用来区分ip地址的网络号和主机号
- 默认网关：当需要发送的数据包的目的ip不在本网段内时，就会发送给默认的一台电脑，成为网关
- 集线器：已过时，用来连接多态电脑，缺点：每次收发数据都进行广播，网络会变的拥堵
- 交换机：集线器的升级版，有学习功能知道需要发送给哪台设备，根据需要进行单播、广播
- 路由器：连接多个不同的网段，让他们之间可以进行收发数据，每次收到数据后，ip不变，但是MAC地址会变化
- DNS：用来解析出IP（类似电话簿）
- http服务器：提供浏览器能够访问到的数据

下面以浏览器访问www.Baidu.com为例进行说明.

1. 先要通过dns服务器解析出www.Baidu.com对应的ip地址  

   1. 解析出主机名和端口号
   2. 查询浏览器或者操作系统的DNS缓存，如果命中缓存，则使用缓存的IP地址，否则，使用DNS解析出IP地址
          在DNS协议中，先向本地DNS服务器求助（一般是路由器），希望从本地DNS服务器那里得到主机名对应的IP，得到就好，得不到还得向更高层次的DNS服务器求助，直到解析出主机名对应的IP。
   3. 使用IP, ARP, RARP, OSPF协议获取目标IP的MAC地址（唯一标示机器的地址），知道MAC地址后才能进行TCP连接

   1)	使用arp获取默认网关的mac地址 
   2)	组织数据发送给默认网关
   3)	默认网关把数据转发给在同一网段的路由器
   4)	路由器根据自己的路由协议,选择一个合适的较快的路径转发数据给目的网关
   5)	目的网关(dns服务器所在的网关)把数据转发给dns服务器
   6)	dns服务器根据游览器的请求解析出www.Baidu.com对应的ip,并将ip原路返回给客户端

2. 游览器和得到的ip地址所在的服务器进行tcp的三次握手

3. 3次握手成功后,使用http协议发送请求数据给web服务器(即百度所对应的服务器)

4. web服务器收到请求之后,通过查询自己的服务器得到相应的数据,然后原路返回给游览器

5. 游览器接收到数据之后,通过游览器自己的渲染功能来显示这个网页

6. 游览器关闭tcp连接,即4次挥手



### ③ 系统调用和应用编程接口概念

## TCP可靠传输的工作原理-停止等待&连续的ARQ

在网络传输中，我们认为最理想的传输状态就是：

  1、传输信道不产生差错。

  2、不管发送方以多块的速度发送数据，接收方都能来得及接受以及处理这些数据。

当然，这种只是理想状态，在实际运用中，几乎是不可能的。因此，我们需要采取一些可靠的传输协议。

  1、当出现差错时，让发送发重传该差错数据。

  2、接受方来不及处理数据时，及时告知发送方适当的降低发送速度。

那么，要做到上述第一点，就需要采用：**停止等待协议** 

一、停止等待协议。

  所谓停止等待协议就是没发送完一组数据后，等待对方确认并且收到确认后，再发送下一组数据。

  我将它简单的理解为以下过程：发送数据，收到数据，发送确认，收到确认。

  那么这样，就分为了以下4种情况。（无差错、出现差错、确认丢失、确认迟到）

  1、无差错

​    ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170626192644085)

​    

​    所谓无差错，就是数据能够正常发送，正常接收，正常确认，正常收到确认的一个过程。也是最理想，最好的一种状态。

  2、出现差错

![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170626192651143)

​    所谓出现差错，就是数据在发送的过程中部分或全部丢失（如上图左）。

​    A发送M1并出现差错，B在收到M1时（全部丢失，不会收到）检测出了差错，就丢弃M1，其他什么也不做（不会通知A数据出现了差错，因为有可能全部丢失，B并不知道）。在这两种情况下，B都不会发送任何的信息。那么，怎么办？

​    A只要超过一段时间仍然没有收到确认，就认为刚才所发送的数据丢失，然后重传前面发送的数据。这就叫做超时重传。当前需要一个计时器来完成。

​    因此，有如下三点要求：

​    1>、A在发送完一组数据后，必须暂时保留自己已发送的数据的副本（供超时重传使用）。只有收到确认后，才会删除该副本。

​    2>、每一组数据和确认数据都必须编号（TCP头部有该字段）。这样才能明确是哪一个发送出去的数据收到了确认，哪一个没有收到。

​    3>、超时计时器设定的时间应该要长于数据平均往返时间。

  3、确认丢失

​    ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170626194544005)

​    所谓确认丢失，其实就是确认消息在传输过程丢失。那么，该如何处理？

​    当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：

​    1>、丢弃这个重复的M1消息，不向上层交付。

​    2>、向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。

  4、确认迟到

​    ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170626195526710)

​    所谓确认迟到，就是B发送的确认消息没有丢失，但是却迟到（过了很长一段时间才到）。那么该如何处理？

​    A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：

​    1>、A收到重复的确认后，直接丢弃。

​    2>、B收到重复的M1后，也直接丢弃重复的M1。



  至此，就是停止等待协议中所出现的所有的可能情况。也一一解决。像这种可靠的传输协议通常称为**自动重传请求ARQ**（Automatic Repeat reQuest）。意思就是，重传的请求是自动进行的，不需要接受方请求发送某一个丢失或出错的消息。

  但是，很显然。我们发现，其信道的利用率很低。

  那该怎么办？

  那就是利用**连续ARQ请求协议**。自动重发请求（Automatic Repeat Request）

二、**连续的ARQ协议** 

  先看一张信道利用率图：

![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170626210912836)

  这两张图的差异很明显。使用连续的ARQ协议可以大大的提高信道利用率。

  吧后者这张图的工作模式又叫做流水线传输。

  其原理如下：

  ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20170626210917545)

   其实现的基础是建立在滑动窗口之上。而滑动窗口乃是TCP的精髓所在（下一篇详解）。

   连续ARQ规定，发送方每收到一个确认就将滑动窗口向前（时间增大方向）滑动一格。如上图表示收到一个确认。

   接受方采用**累积确认**的方式：**接收方不必每收到一个消息，就发送一个确认。而是在收到几条消息后，对按序到达的最后一条消息发送确认**。表示，这个消息之前的所有消息全部收到。

  

  当然，这两个方式都有自己的优缺点：

  1、自动重传请求ARQ协议

   优点：简单

   缺点：信道利用率低

  2、连续的ARQ协议

  优点：信道利用率高，容易实现，即使确认丢失，也不必重传。

  缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息。

  比如：发送方发送了5条消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫

Go-Back-N（回退N），表示需要退回来重传已经发送过的N个消息。



## TCP之滑动窗口

概述

**`.什么是流量控制`**

 （防止发送方发的太快，耗尽接收方的资源，从而使接收方来不及处理）

**`2.流量控制的一些知识点`**

> （1）接收端抑制发送端的依据：接收端缓冲区的大小
> （2）流量控制的目标是接收端，是怕接收端来不及处理
> （3）流量控制的机制是丢包

**`3.怎么样实现流量控制？`**

> 使用滑动窗口
> **滑动窗口**
> **`1.滑动窗口是什么？`**
> 滑动窗口是类似于一个窗口一样的东西，是用来告诉发送端可以发送数据的大小或者说是窗口标记了接收端缓冲区的大小，这样就可以实现
> ps：窗口指的是一次批量的发送多少数据

**`2.为什么会出现滑动窗口？`**

> 在确认应答策略中，对每一个发送的数据段，都要给一个ACK确认应答，收到ACK后再发送下一个数据段，这样做有一个比较大的缺点，就是`性能比较差`，尤其是数据往返的时间长的时候
>
> > 使用滑动窗口，就可以一次发送多条数据，从而就提高了性能

**`3.滑动窗口的一些知识点`**

> （1）接收端将自己可以接收的缓冲区大小放入TCP首部中的“窗口大小”字段，通过ACK来通知发送端
> （2）窗口大小字段越大，说明网络的吞吐率越高
> （3）窗口大小指的是无需等待确认应答而可以继续发送数据的最大值，即就是说不需要接收端的应答，可以一次连续的发送数据
> （4）操作系统内核为了维护滑动窗口，需要开辟发送缓冲区，来记录当前还有那些数据没有应答，只有确认应答过的数据，才能从缓冲区删掉
>
> >  

（5）接收端一旦发现自己的缓冲区快满了，就会将窗口大小设置成一个更小的值通知给发送端，发送端收到这个值后，就会减慢自己的发送速度
（6）如果接收端发现自己的缓冲区满了，就会将窗口的大小设置为0，此时发送端将不再发送数据，但是需要定期发送一个窗口探测数据段，使接收端把窗口大小告诉发送端
ps：在TCP的首部中，有一个16为窗口字段，此字段就是用来存放窗口大小信息的

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20180801095105145)

**`4.滑动窗口的优点`**

> 可以高效可靠的发送大量的数据




滑动窗口实现了TCP流控制。首先明确**滑动窗口**的范畴：TCP是双工的协议，会话的双方都可以同时接收和发送数据。TCP会话的双方都各自维护一个`发送窗口`和一个`接收窗口`。各自的`接收窗口`大小取决于应用、系统、硬件的限制（TCP传输速率不能大于应用的数据处理速率）。各自的`发送窗口`则要求取决于对端通告的`接收窗口`，要求相同。

滑动窗口解决的是**流量控制**的的问题，就是如果接收端和发送端对数据包的处理速度不同，如何让双方达成一致。接收端的缓存传输数据给应用层，但这个过程不一定是即时的，如果发送速度太快，会出现接收端数据overflow，流量控制解决的是这个问题。

窗口的概念

发送方的发送缓存内的数据都可以被分为4类:
\1. 已发送，已收到ACK
\2. 已发送，未收到ACK
\3. 未发送，但允许发送
\4. 未发送，但不允许发送

其中类型2和3都属于发送窗口。

接收方的缓存数据分为3类：
\1. 已接收
\2. 未接收但准备接收
\3. 未接收而且不准备接收

其中类型2属于接收窗口。

窗口大小代表了设备一次能从对端处理多少数据，之后再传给应用层。缓存传给应用层的数据不能是乱序的，窗口机制保证了这一点。现实中，应用层可能无法立刻从缓存中读取数据。



### 滑动机制

1. 发送窗口只有收到发送窗口内字节的ACK确认，才会移动发送窗口的左边界。
2. 接收窗口只有在前面所有的段都确认的情况下才会移动左边界。当在前面还有字节未接收但收到后面字节的情况下，窗口不会移动，并不对后续字节确认。以此确保对端会对这些数据重传。
3. 遵循快速重传、累计确认、选择确认等规则。
4. 发送方发的window size = 8192;就是接收端最多发送8192字节，这个8192一般就是发送方接收缓存的大小。

### 模拟动画

### 模拟特点

找到了一个模拟TCP窗口发送的[动画的地址](http://www.exa.unicen.edu.ar/catedras/comdat1/material/Filminas3_Practico3.swf)，稍微有缺陷：1. 丢包率如果设得太高，有时无论重发多少次都不能恢复正常 2. 窗口最大可为10，其实应该为9

明确发送端和接收端，发送A~S数据包，我们不会从头到尾分析，因为过程比较长。
\1. 简化了窗口大小，双方窗口大小都一直是4
\2. 设置一定的丢包率，否则没什么值得分析的，包括sender发送的数据包和receiver回复的ACK包。
\3. 简化重传机制，出现丢包则直接重传，不等3个冗余ACK和超时。
\4. 既不是选择重传也不是退回N步，重传的包是随机的

### 分析滑动窗口机制

1. 首先发送端发送A,B,C,D四个包，但是A,B丢失，只有C,D到达接收端。
   ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/42138740462_ed4ce64c1b_b.jpg)
2. 接收端没有收到A，所以不回复ACK包。发送端重传A,B,C,D四个包，这次全都到达了。
   ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/42138740402_dbbbf52c8c_b.jpg)
3. 接收端先获得A，发ACK包A，但是中途丢失；获得B后，根据累计确认的原则，发D的ACK包，然后窗口滑动。再次获得C,D后，连续回复2个D的ACK包，其中C对应的ACK包丢失。
   ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/27313728687_a5673da755_b.jpg)
4. 发送端连收2个D的ACK包，说明4个包对方都已收到，窗口滑动，发E,F,G,H包，其中G包丢失。现在整个序列的状态：ABCD是已发送已确认，EFGH是已发送未确认，I~S是不能发送。
   ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/27313728577_04e0867716_b.jpg)
5. 接收端先收到E，发ACK包；收到F后发F的ACK包；未收到G，还是发F的ACK包；收到H，还是发F的ACK包。不幸的是，三个ACK包全都丢失。
   ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/27313728427_a5b7d4b107_b.jpg)
6. 发送端收到E的ACK包，窗口向右滑动一位；然后再发送F,G,H,I，其中F丢失。
   ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/27313728297_65698014e9_b.jpg)
7. 接收端获得I，因为没有G，只好回复F的ACK包。相继收到G,H包。
   ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/28312507728_96c5813bee_b.jpg)
8. 接收端根据累计确认，连发两个I包，其中H对应的丢失。窗口向右滑动。
   ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/41284211495_31f906941b_b.jpg)
9. 发送端接收I的ACK包后，向右滑动四位。发送J,K,L,M四个包，后面不再分析。
   ![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/27313728077_b406cc3293_b.jpg)

从上面的过程中，我们可以得到以下结论：
\1. TCP连接是通过数据包和ACK实现的，我们作为第三者可以看到双方发包的过程，但接受者在收到之前不知道发送方发的是什么，同样的，发送方在收到ACK前也不知道对方是否成功接收。

1. 发送方没有收到接收方发回的ACK，就不能向右滑动。假设发送方向接收方发了ABCD就滑动，只要对方没收到A，就不能滑动，那么就会出现二者不同步的局面。
2. 滑动窗口提高了信道利用率，TCP是发送报文段为单位的，假如每发一个报文就要等ACK，那么对于大数据包，等待时间就太长了。只要发送的报文在滑动窗口里面，不用等每个ACK回来就可以向右滑动。本例中，开始接收端空着AB，只有CD，此时不能滑动；之后接收到EF和H，直接向右滑动2位，不必等G到位。
3. 窗口大小不能大于序号空间大小的一半。目的是为了不让两个窗口出现交迭，比如总大小为7，窗口大小都为4，接收窗口应当滑动4，但只剩3个序号，导致两个窗口交迭。
4. 有一种情况没出现：发送方发ABCD，接收方都收到然后向右滑动，但回复的ACK包全丢了。发送方未收到任何ACK， timeout后会重发ABCD，此时的接收方按累计确认的原则，收到ABCD后只会重发D的ACK，发送方收到后向右滑动。

### 对比滑动窗口和拥塞窗口

滑动窗口是控制接收以及同步数据范围的，通知发送端目前接收的数据范围，用于流量控制，接收端使用。拥塞窗口是控制发送速率的，避免发的过多，发送端使用。因为tcp是全双工，所以两边都有滑动窗口。
两个窗口的维护是独立的，滑动窗口主要由接收方反馈缓存情况来维护，拥塞窗口主要由发送方的拥塞控制算法检测出的网络拥塞程度来决定的。

拥塞窗口控制sender向connection传输数据的速率，使这个速率为网络拥堵状况的函数。

## **拥塞控制**

**`1.什么是拥塞控制`**

> too many sources sending too much data too fast for network to handle
> 防止发送方发的太快，使得网络来不及处理，从而导致网络拥塞
> \###**`2.拥塞控制使用的机制：AIMD\slow start`**
> **`slow start: 慢启动`**
> A: additive（加法的）
> I: increase（增加）
> M: multiplicative（乘法的）
> D: decrease（减少）
> 即就是加法增加，乘法减少---->加增乘减

**`加法增加`**

> 是指执行拥塞避免算法后，在收到对所有报文段的确认后（即经过一个往返时间），就把拥塞窗口cwnd增加一个MSS大小，使拥塞窗口缓慢增大，以防止网络过早出现拥塞

**`乘法减少`**

> 出现一次超时（即出现一次网络拥塞），就把慢开始门限值ssthresh设置为当前的拥塞窗口值乘以0.5

ps：当网络频繁出现拥塞时，ssthresh值就下降的很快，以大大减少注入到网络中的分组数

**`3.发送端如何知道已经丢包？`**
![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20180801101712872-1605616950489)
**`4.为什么会有拥塞控制？`**

> 流量控制虽然可以高效可靠的传送大量的数据，但是如果在刚开始阶段就发送大量的数据，可能会导致网络拥堵，因为网络上的计算机太多了

**`5.拥塞控制的表现？`**

> 丢包
> 延时变长

**`6.拥塞控制的工作过程`**
**`初始化阶段`**
![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20180808112720118-1605616950489)
**`慢开始阶段`**
阶段（一）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808114749982)
阶段（二）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123534347)
阶段（三）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123554689)
阶段（四）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123619362)
**`拥塞避免阶段`**
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123721264)
**`拥塞调整阶段`**
阶段（一）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/20180808123806958)
阶段（二）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/2018080812382978)
阶段（三）
![这里写图片描述](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/4.%25E9%259D%25A2%25E8%25AF%2595%25E6%258A%2580%25E6%259C%25AF%25E9%2597%25AE%25E9%25A2%2598.assets/2018080812385281)

**三、流量控制和拥塞控制的区别**
**`1.相同点`**

> （1）现象都是丢包；
> （2）实现机制都是让发送方发的慢一点，发的少一点

**`2.不同点`**

> **（1）`丢包位置不同`**
> 流量控制丢包位置是在接收端上
> 拥塞控制丢包位置是在路由器上
> **（2）`作用的对象不同`**
> 流量控制的对象是接收方，怕发送方发的太快，使得接收方来不及处理
> 拥塞控制的对象是网络，怕发送发发的太快，造成网络拥塞，使得网络来不及处理
> **`3.联系`**

```
拥塞控制
     拥塞控制通常表示的是一个全局性的过程，它会涉及到网络中所有的主机、
     所有的路由器和降低网络传输性能的所有因素
流量控制
     流量控制发生在发送端和接收端之间，只是点到点之间的控制

123456
```

![这里写图片描述](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/20180801095806107-1605616950490)

## arp协议

 地址解析协议

![image-20200807103607968](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200807103607968.png)

这个放的就是网络层确定的下一跳的网关或者目的ip的网卡地址， 也就是硬件Mac地址

也就是一个数据包内既有传输控制层的端口号，又有网络层的ip地址，还有链路层的网卡地址硬件Mac地址，

Mac地址怎么来的，就是主机通过arp协议在局域网进行广播IP地址，对应ip地址给返回的自己的Mac地址

端点间通信，通过中间的路由网关等节点进行传递的

![image-20200807111415501](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/image-20200807111415501.png)

ip地址一直不变，但是Mac地址一直在变，像一个链表，Mac地址可以改，只要在局域网内保持唯一就好

首先本机进行arp广播，寻找这个ip对应的Mac地址，然后得到那个ip地址的回答以后，本机将该Mac地址加入对应的arp表中

**地址解析协议**，即 ARP（Address Resolution Protocol），是根据IP地址获取物理地址的一个TCP/IP协议。 它是IPv4中网络层必不可少的协议，不过在IPv6中已不再适用，并被邻居发现协议（NDP）所替代。

主机发送信息时将包含目标IP地址的ARP请求广播到网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机**ARP缓存**中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。**地址解析协议是建立在网络中各个主机互相信任的基础上的**，网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存；由此攻击者就可以向某一主机发送伪ARP应答报文，使其发送的信息无法到达预期的主机或到达错误的主机，这就构成了一个ARP欺骗。ARP命令可用于查询本机ARP缓存中IP地址和MAC地址的对应关系、添加或删除静态对应关系等。相关协议有RARP、代理ARP。

网络层使用的是 IP 地址，但在实际网络的链路上传输数据帧时，最终还必须使用该网络的硬件地址。但 **IP 地址和下面的网络的硬件地址由于格式不同而不存在简单的映射关系**。此外，**一个网络上可能会经常会有新主机加入进来，或撤走一些主机。更换网络适配器也会使主机的硬件地址改变**。地址解析协议 ARP 解决的方法是：在主机ARP高速缓存中应存放一个从IP地址到硬件地址的映射表，并且这个映射表还经常动态更新（新增或超时删除）。

注意：ARP是解决**同一局域网**中主机或者路由器的**IP地址和硬件地址的映射问题**，在每一台主机中都有一个**ARP高速缓存**（ARP cache）,里面存储本主机所知道**本局域网中**其他主机的IP地址与硬件地址的映射表

##### 2. ARP 协议工作原理



当主机 A 向本局域网上的某台主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。如有，就在 ARP 高速缓存中查出其对应的硬件地址，再把这个硬件地址写入 MAC 帧，然后通过局域网把该 MAC 帧发往此硬件地址。
也有可能查不到主机 B 的 IP 地址。这可能主机 B 才入网，或者主机 A 刚刚加电，其高速缓存还是空的。这种情况下，主机 A 自动运行 ARP，然后按照以下步骤找出主机 B 的硬件地址。

1. ARP进程在本局域网上广播一个ARP请求分组。ARP请求报文中的发送端IP地址和发送端MAC地址为主机A的IP地址和MAC地址，目标IP地址和目标MAC地址为主机B的IP地址和全0的MAC地址。
2. 本局域网所有主机运行的ARP进程收到此ARP请求分组。
3. 主机B的IP与请求分组里面的IP一致，将ARP请求报文中的发送端（即主机A）的IP地址和MAC地址存入自己的ARP表中。之后向A发送ARP响应分组（单播）；其他主机则不理睬
4. 主机 A 收到从主机 B 发来的 ARP 响应分组时，就在其 ARP 高速缓存中写入主机 B 的 IP 地址到硬件地址的映射。本机缓存是有生存期的，生存期结束后，将再次重复上面的过程。主机B的MAC地址一旦确定，主机A就能向主机B发送IP通信了。

如果所要找的主机和源主机不在同一个局域网，则源主机发送 ARP 请求分组，找到本局域网上的一个路由器 R1 的硬件地址。剩下的工作由 R1 完成。

##### 7. ARP 代理

![img](6.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.assets/611089-20190619181612433-771985853.png)

如果 ARP 请求是从一个网络的主机发往另一个网络上的主机，那么连接这两个网络的路由器就可以回答该请求，这个过程称作**委托 ARP** 或 **ARP 代理(Proxy ARP)**。 这样可以欺骗发起 ARP 请求的发送端，使它误以为路由器就是目的主机，而事实上目的主机是在路由器的“另一边”。路由器的功能相当于目的主机的代理，把分组从其他主机转发给它。
ARP 代理也称作混合 ARP（promiscuous ARP）或ARP 出租(ARP hack)。这些名字来自于 ARP 代理的其他用途：**通过两个物理网络之间的路由器可以互相隐藏物理网络**。在这种情况下，两个物理网络可以使用相同的网络号，只要把中间的路由器设置成一个 ARP 代理，以响应一个网络到另一个网络主机的 ARP 请求。这种技术在过去用来隐藏一组在不同物理电缆上运行旧版 TCP/IP 的主机。分开这些旧主机有两个共同的理由，其一是它们不能处理子网划分，其二是它们使用旧的广播地址（所有比特值为 0 的主机号，而不是目前使用的所有比特值为 1 的主机号）。

**ARP 代理的优点：**

1. 最主要的一个优点就是能 够在不影响其他router的路由表的情况下在网络上添加一个新的router,这样使得子网的变化对主机是透明的
2. ARP 代理应该使用在主机**没有配置默认网关或没有任何路由策略**的网络上

**ARP 代理的缺点：**

1. 增加了某一网段上ARP流量
2. 主机需要更大的ARP table来处理IP地址到MAC地址的映射
3. 安全问题,比如ARP欺骗(spoofing)
4. 不会为不使用ARP来解析地址的网络工作
5. 不能够概括和推广网络拓扑

##### 8. ARP 攻击

ARP 协议的基本功能就是通过目标设备的 IP 地址，查询目标设备的 MAC 地址，以保证通信的进行。 基于 ARP 协议的这一工作特性，黑客向对方计算机不断发送有欺诈性质的 ARP 数据包，数据包内包含有与当前设备重复的 Mac 地址，使对方在回应报文时，由于简单的地址重复错误而导致不能进行正常的网络通信。

一般情况下，受到ARP攻击的计算机会出现两种现象：

1. 不断弹出“本机的XXX段硬件地址与网络中的XXX段地址冲突”的对话框。
2. 计算机不能正常上网，出现网络中断的症状。

因为这种攻击是利用ARP请求报文进行“欺骗”的，所以防火墙会误以为是正常的请求数据包，不予拦截。因此普通的防火墙很难抵挡这种攻击。