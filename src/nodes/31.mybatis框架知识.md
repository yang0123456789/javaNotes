```mysql
CREATE DATABASE mybatis;
USE mybatis;
 CREATE TABLE `users` 	(
id INT(20) NOT NULL PRIMARY KEY,
`name` VARCHAR(30) DEFAULT NULL,
pwd VARCHAR(30) DEFAULT NULL
 )ENGINE=INNODB DEFAULT CHARSET=utf8;

 INSERT INTO `users`(id,`name`,pwd) VALUES 
 (5,"yang5","123"),
 (2,"yang","123"),
 (3,"yang4","123")
```

![image-20200323222928337](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323222928337.png)





# 1.第一个Mybatis程序

## 第一步：项目：Mybatyis(删除src)，模块：mybatis-01

- 创建Mybatis的maven项目(父项目要把src删掉) 父pom.xml导包 和 子maven项目，不用导包

- **<u>在父，子pom.xml里都需要加入一下代码</u>**

- ```xml
  <!--依赖如下-->
  <dependencies>
  
      <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.16</version>
      </dependency>
      <!--
       https://mvnrepository.com/artifact/org.mybatis/mybatis
      -->
      <dependency>
          <groupId>org.mybatis</groupId>
          <artifactId>mybatis</artifactId>
          <version>3.5.3</version>
      </dependency>
  
      <!--  https://mvnrepository.com/artifact/junit/junit  -->
      <dependency>
          <groupId>junit</groupId>
          <artifactId>junit</artifactId>
          <version>4.12</version>
          <scope>test</scope>
      </dependency>
  
  </dependencies>         
  
  
  <!--    所有的maven项目都需要加进去这个文件，在父，子pom.xml里都需要加入一下代码   -->   
  <!--在build中配置resources，来防止我们资源导出失败的问题-->
      <build>
          <resources>
              <resource>
                  <directory>src/main/resources</directory>
                  <includes>
                      <include>**/*.properties</include>
                      <include>**/*.xml</include>
                  </includes>
                  <filtering>true</filtering>
              </resource>
  
              <resource>
                  <directory>src/main/java</directory>
                  <includes>
                      <include>**/*.properties</include>
                      <include>**/*.xml</include>
                  </includes>
                  <filtering>true</filtering>
              </resource>
  
          </resources>
      </build>
  ```

  maven默认的配置文件放在resource文件夹下，放在别的地方不会自动扫描加载，这个叫约定大于配置

  ![image-20200323113159242](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323113159242.png)

## 第二步

- 根据

[Mybatis文档]: https://mybatis.org/mybatis-3/zh/getting-started.html

- 编写resources资源文件里的mybatis-config.xml核心配置文件

- ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE configuration
          PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
          "http://mybatis.org/dtd/mybatis-3-config.dtd">
  
          <!-- configuration核心配置文件 -->
  
  <configuration>
      <environments default="development">
          <environment id="development">
              <transactionManager type="JDBC"/>
              <dataSource type="POOLED">
                  <property name="driver" value="com.mysql.jdbc.Driver"/>
                  <property name="url" value="jdbc:mysql://localhost:3306/mybatis?useSSL=true&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=Asia/Shanghai"/>
                  <property name="username" value="root"/>
                  <property name="password" value="3105311"/>
              </dataSource>
          </environment>
      </environments>
      
      <!--每一个Mapper.xml都需要在mybatis-config.xml核心配置文件中注册-->
      <mappers>
          <mapper resource="com/it/Dao/UserMapper.xml"/>
      </mappers>
      
  </configuration>
  ```

  

## 第三步：

- 在java下创建一个com.it.utils的工具包，根据文档写号工具类

- ```java
  package com.it.utils;
  
  //通过 sqlSessionFactory →→→→拿到→→→→ SqlSession
  
  import org.apache.ibatis.io.Resources;
  import org.apache.ibatis.jdbc.SQL;
  import org.apache.ibatis.session.SqlSession;
  import org.apache.ibatis.session.SqlSessionFactory;
  import org.apache.ibatis.session.SqlSessionFactoryBuilder;
  
  import java.io.IOException;
  import java.io.InputStream;
  
  public class MybaticUtils {
      private static SqlSessionFactory sqlSessionFactory;
  //    使用Mabatis的第一步，获取sqlSessionFactory对象
      static {
          try {
              String resource = "mybatis-config.xml";
              InputStream inputStream = Resources.getResourceAsStream(resource);
              sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
          } catch (IOException e) {
              e.printStackTrace();
          }
      }
  
  //    既然有了 SqlSessionFactory，顾名思义，我们就可以从中获得 SqlSession 的实例了。
  //     SqlSession 完全包含了面向数据库执行 org.apache.ibatis.jdbc.SQL 命令所需的所有方法。你可以通过 SqlSession 实例来直接执行已映射的 SQL 语句。
      public static SqlSession getSqlSession() {
  //        SqlSession sqlSession = //sqlSessionFactory.openSession();
  //        return sqlSession;
          return sqlSessionFactory.openSession();
      }
  }
  ```

  ![image-20200323113752274](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323113752274.png)

![image-20200323113837789](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323113837789.png)

## 第四步：

- 创建com.it.pojo包，编写数据库表的关系映射(例如:user表对应user类)

  *POJO*（Plain Ordinary Java Object）简单的Java对象，实际就是普通JavaBeans，

- ```java
  package com.it.pojo;
  
  public class User {
      private int id;
      private String name;
      private String pwd;
  
      public User() {
      }
  
      public User(int id, String name, String pwd) {
          this.id = id;
          this.name = name;
          this.pwd = pwd;
      }
  
      public int getId() {
          return id;
      }
  
      public void setId(int id) {
          this.id = id;
      }
  
      public String getName() {
          return name;
      }
  
      public void setName(String name) {
          this.name = name;
      }
  
      public String getPwd() {
          return pwd;
      }
  
      public void setPwd(String pwd) {
          this.pwd = pwd;
      }
  
      @Override
      public String toString() {
          return "User{" +
                  "id=" + id +
                  ", name='" + name + '\'' +
                  ", pwd='" + pwd + '\'' +
                  '}';
      }
  }
  
  ```

## 第五步：

- 创建com.it.Dao包，编写UserMapper接口(填写增删改查)

- ```java
  package com.it.Dao;
  
  import com.it.pojo.User;
  
  import java.util.List;
  
  public interface UserMapper {
      List<User> getUserList();
  }
  
  ```

## 第六步：

- 在com.it.Dao包，中创建UserMapper.xml配置文件(Dao=Mapper)。(由原来的UserDaoImpl.java实现类 转换 为UserMapper.xml配置文件)

- namespace 命名空间命名空间的作用有两个，一个是利用更长的全限定名来将不同的语句隔离开来，同时也实现了你上面见到的**接口绑定**。就算你觉得暂时用不到接口绑定，你也应该遵循这里的规定，以防哪天你改变了主意。 长远来看，只要将命名空间置于合适的 Java 包命名空间之中，你的代码会变得更加整洁，也有利于你更方便地使用 MyBatis。

  **命名解析：**为了减少输入量，MyBatis 对所有具有名称的配置元素（包括语句，结果映射，缓存等）使用了如下的命名解析规则。

  - 全限定名（比如 “com.mypackage.MyMapper.selectAllThings）将被直接用于查找及使用。
  - 短名称（比如 “selectAllThings”）如果全局唯一也可以作为一个单独的引用。 如果不唯一，有两个或两个以上的相同名称（比如 “com.foo.selectAllThings” 和 “com.bar.selectAllThings”），那么使用时就会产生“短名称不唯一”的错误，这种情况下就必须使用全限定名。

- ```xml
  <?xml version="1.0" encoding="UTF-8" ?>
  <!DOCTYPE mapper
          PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
          "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
  <!--namespace 绑定一对应的Dao/Mapper接口 -->
  <mapper namespace="com.it.Dao.UserMapper">
  
  <!--select查询 id就是UserDao接口里面的方法的名字 resultType/Map是返回一个/多个结果集
  路径就写表的映射的路径-->
   <select id="getUserList" resultType="com.it.pojo.User">
    select * from mybatis.user;
   </select>
  </mapper>
  ```

## 第七步

- 编写测试类

- Junit测试类代码

  ```java
  package com.it.Dao;
  
  //test的路径尽量要跟要测试的类的路径匹配
  
  import com.it.pojo.User;
  import com.it.utils.MybatisUtils;
  import org.apache.ibatis.session.SqlSession;
  import org.junit.Test;
  
  import java.util.List;
  
  public class UserDaoTest {
      @Test
      public void test(){
  //        第一步获取SqlSession对象
          SqlSession sqlSession = MybatisUtils.getSqlSession();
  //        执行sql：方法一
          UserMapper mapper = sqlSession.getMapper(UserMapper.class);
          List<User> userList = mapper.getUserList();
         //方法二
          //List<User> userList = session.selectList("com.yang.dao.UserMapper.getUserList");
          for (User user : userList) {
              System.out.println(user);
          }
  //        关闭sqlSession
          sqlSession.close();
      }
  }
  
  ```

  ![image-20200323114628724](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323114628724.png)

- 错误一:

  org.apache.ibatis.binding.BindingException: Type interface com.it.Dao.UserMapper is not known to the MapperRegistry.

   **<**!--每一个Mapper.xml都需要在mybatis-config.xml核心配置文件中注册-->**
      **<mappers>**
          **<mapper resource="com/it/Dao/UserMapper.xml"/>**
      </mappers>**

- 错误二：

  The error may exist in org/mybatis/example/BlogMapper.xml

  Cause: org.apache.ibatis.builder.BuilderException: Error parsing SQL Mapper Configuration. 

  Cause: java.io.IOException: Could not find resource org/mybatis/example/BlogMapper.xml

  ```xml
     <!--    所有的maven项目都需要加进去这个文件，在父，子pom.xml里都需要加入一下代码   -->   
  <!--在build中配置resources，来防止我们资源导出失败的问题-->
      <build>
          <resources>
  
              <resource>
                  <directory>src/main/resources</directory>
                  <includes>
                      <include>**/*.properties</include>
                      <include>**/*.xml</include>
                  </includes>
                  <filtering>true</filtering>
              </resource>
  
              <resource>
                  <directory>src/main/java</directory>
                  <includes>
                      <include>**/*.properties</include>
                      <include>**/*.xml</include>
                  </includes>
                  <filtering>true</filtering>
              </resource>
  
          </resources>
      </build>
  ```

- 错误三：

- 错误四：**value="com.mysql.cj.jdbc.Driver"  要有 cj** 

- 错误五：时区设置。

  1. 进入命令窗口（Win + R），连接数据库 mysql -hlocalhost -uroot -p，回车，输入密码，回车
  2. 继续输入 show variables like'%time_zone';  （注意不要漏掉后面的分号），显示 SYSTEM 就是没有设置时区啦。
  3. 输入set global time_zone = '+8:00'; 注意不要漏掉后面的分号）





# 2.Mybatis-CRUD

## <u>*增删改must提交事务，模块mybatis-02*</u>

## 1.namespace

- namespace中的名要和UserMapper.xml的接口一致


## 2.Select

- 此时表格映射(pojo)，工具类(utiles)，resources-mybatis-config.xml(配置文件)都已经建立好了。只需要改接口和接口实现.xml和测试类就可以了。

- 带参数的查询：根据id查询用户

  1.接口(UserMapper)：

  ```java
  User getUserById(int id)；
  ```

  2.接口实现.xml(UserMapper.xml)：

  id：接口里的方法名；resultType：返回值类型是User，要写权限路径；parameterType：要传入的参数的类型；where id = #{id}：要传入的参数，书写格式

  ```xml
  <select id="getUserById" resultType="com.it.pojo.User" parameterType="int">
          select * from mybatis.user where id = #{id}
  </select>
  ```

  3.测试：

  第一步和最后一步不变，只改中间即可

  ```java
      @Test
      public void getUserById(){
          //        第一步获取SqlSession对象
          SqlSession sqlSession = MybatisUtils.getSqlSession();
  
          UserMapper mapper = sqlSession.getMapper(UserMapper.class);
          User user = mapper.getUserById(1);
          System.out.println(user);
  
          //        最后一步关闭sqlSession
          sqlSession.close();
  ```

## 3.Insert

1. 接口：

2. ```java
   //    insert一个用户
       int addUser(User user);
   ```

3. 接口实现.xml(UserMapper.xml)：

4. ```xml
   <!--    对象中的属性可以直接取出来 -->
   <insert id="addUser" parameterType="com.it.pojo.User">
       insert into mybatis.user(id,name,pwd) values (#{id},#{name},#{pwd})
   </insert>
   ```

5. 测试：

6. ```java
   @Test
      public void addUser(){
          //        第一步获取SqlSession对象
          SqlSession sqlSession = MybatisUtils.getSqlSession();
     
          UserMapper mapper = sqlSession.getMapper(UserMapper.class);
          int user = mapper.addUser(new User(4, "wc", "444"));
          if (user>0){
              System.out.println("insert success !");
          }
     
          //增删改都需要提交事务 !!!
          sqlSession.commit();
          
          //        最后一步关闭sqlSession
          sqlSession.close();
      }
   ```

## 4.Update

1. 接口：

2. ```java
   //    修改用户
       int updateUser(User user);
   ```

3. 接口实现.xml(UserMapper.xml)：

4. ```xml
   <update id="updateUser" parameterType="com.it.pojo.User">
           update mybatis.user set name = #{name},pwd =  #{pwd} where id = #{id} ;
   </update>
   ```

5. 测试：

6. ```java
   @Test
       public void updateUser(){
           //        第一步获取SqlSession对象
           SqlSession sqlSession = MybatisUtils.getSqlSession();
   
           UserMapper mapper = sqlSession.getMapper(UserMapper.class);
           int user = mapper.updateUser(new User(4, "haha", "123123"));
           if (user>0){
               System.out.println("insert success !");
           }
   
           //增删改都需要提交事务 !!!
           sqlSession.commit();
   
           //        最后一步关闭sqlSession
           sqlSession.close();
       }
   ```

## 5.Delete

1. 接口：

2. ```java
   //    删除用户
       int deleteUser(int id);
   ```

3. 接口实现.xml(UserMapper.xml)：

4. ```xml
   <delete id="deleteUser" parameterType="int">
         delete from mybatis.user where id = #{id}
     </delete>
   ```

5. 测试：

6. ```java
   @Test
       public void deleteUser(){
           //        第一步获取SqlSession对象
           SqlSession sqlSession = MybatisUtils.getSqlSession();
   
           UserMapper mapper = sqlSession.getMapper(UserMapper.class);
           int user = mapper.deleteUser(4);
           if (user>0){
               System.out.println("insert success !");
           }
   
           //增删改都需要提交事务 !!!
           sqlSession.commit();
   
           //        最后一步关闭sqlSession
           sqlSession.close();
       }
   ```

## 6.万能的Map

1. 例子：使用update,只修改pwd

2. 接口：

3. ```java
   //    万能的Map，当数据或者属性很多的时候，可以选择性的单独改变密码或者用户名等等。
       int updateUserByMap(Map<String,Object> map);
   ```

4. 接口实现.xml(UserMapper.xml)：

5. ```xml
   <!--    利用Map进行的update,只修改pwd。如果是User对象的话则所有的属性都需要写入。使用Map可以写你需要修改的-->
       <update id="updateUserByMap" parameterType="map">
           update mybatis.user set pwd = #{userpwd} where id = #{userid} ;
       </update>
   ```

6. 测试：

7. ```java
   @Test
      public void updateUserByMap(){
          //        第一步获取SqlSession对象
          SqlSession sqlSession = MybatisUtils.getSqlSession();
          UserMapper mapper = sqlSession.getMapper(UserMapper.class);
     
          Map<String,Object> map = new HashMap<String,Object>();
          map.put("userid",4);
          map.put("userpwd","789798789798797");
          int user = mapper.updateUserByMap(map);
          if (user>0){
              System.out.println("insert success !");
          }
          //增删改都需要提交事务 !!!
          sqlSession.commit();
     
          //        最后一步关闭sqlSession
          sqlSession.close();
      }
   ```

## 7.模糊查询

1. 例子：使用List<User> 

2. 接口：

3. ```java
   //  模糊查询
       List<User> getUserListByLike(String like);
   ```

4. 接口实现.xml(UserMapper.xml)：

5. ````xml
   <!--    模糊查询-->
       <select id="getUserListByLike" resultType="com.it.pojo.User">
           select * from mybatis.user where name like #{like} ;
       </select>
   ````

6. 测试：

7. ```java
   //    模糊查询
       @Test
       public void getUserListByLike(){
           //        第一步获取SqlSession对象
           SqlSession sqlSession = MybatisUtils.getSqlSession();
           UserMapper mapper = sqlSession.getMapper(UserMapper.class);
           List<User> userListByLike = mapper.getUserListByLike("%w%");
           for (User user : userListByLike) {
               System.out.println(user);
           }
           //        最后一步关闭sqlSession
           sqlSession.close();
       }
   ```



![image-20200323144951186](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323144951186.png)



## 9.错误分析

1.resource绑定映射文件必须是/

![image-20200323135406027](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323135406027.png)

2.namespace是 . 点

![image-20200323135514342](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323135514342.png)

3.

![image-20200323135748689](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323135748689.png)

# 3.配置解析



## *<u>模块mybatis-02</u>*

## 1.核心配置文件

![image-20200323145110093](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323145110093.png)

- mybatis-config.xml
- MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：
- configuration（配置）
  - [properties（属性）](https://mybatis.org/mybatis-3/zh/configuration.html#properties)
  - [settings（设置）](https://mybatis.org/mybatis-3/zh/configuration.html#settings)
  - [typeAliases（类型别名）](https://mybatis.org/mybatis-3/zh/configuration.html#typeAliases)
  - [typeHandlers（类型处理器）](https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers)
  - [objectFactory（对象工厂）](https://mybatis.org/mybatis-3/zh/configuration.html#objectFactory)
  - [plugins（插件）](https://mybatis.org/mybatis-3/zh/configuration.html#plugins)
  - [environments](https://mybatis.org/mybatis-3/zh/configuration.html#environments )（环境配置）
    - environment（环境变量）
      - transactionManager（事务管理器）
      - dataSource（数据源）
  - [databaseIdProvider（数据库厂商标识）](https://mybatis.org/mybatis-3/zh/configuration.html#databaseIdProvider)
  - [mappers（映射器）](https://mybatis.org/mybatis-3/zh/configuration.html#mappers)

## 2.environments-环境配置

- MyBatis 可以配置成适应多种环境，**不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。**
- 可以设置多套运行环境，但只能同时使用一套。Mybatis默认的事务管理是JDBC(当然不止一种事务管理)，连接池:POOLED。
- 切换环境只需要修改<environments default="">标签的值

在 MyBatis 中有两种类型的事务管理器（也就是 type="[JDBC|MANAGED]"）：

- JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。

- MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。例如:

  ```
  <transactionManager type="MANAGED">
    <property name="closeConnection" value="false"/>
  </transactionManager>
  ```

**提示** 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。

**数据源（dataSource）**

dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。

- 大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。

有三种内建的数据源类型（也就是 type="[UNPOOLED|POOLED|JNDI]"）：

**UNPOOLED**– 这个数据源的实现会每次请求时打开和关闭连接。虽然有点慢，但对那些数据库连接可用性要求不高的简单应用程序来说，是一个很好的选择。 性能表现则依赖于使用的数据库，对某些数据库来说，使用连接池并不重要，这个配置就很适合这种情形。UNPOOLED 类型的数据源仅仅需要配置以下 5 种属性：

- `driver` – 这是 JDBC 驱动的 Java 类全限定名（并不是 JDBC 驱动中可能包含的数据源类）。
- `url` – 这是数据库的 JDBC URL 地址。
- `username` – 登录数据库的用户名。
- `password` – 登录数据库的密码。
- `defaultTransactionIsolationLevel` – 默认的连接事务隔离级别。
- `defaultNetworkTimeout` – 等待数据库操作完成的默认网络超时时间（单位：毫秒）。查看 `java.sql.Connection#setNetworkTimeout()` 的 API 文档以获取更多信息。

作为可选项，你也可以传递属性给数据库驱动。只需在属性名加上“driver.”前缀即可，例如：

- `driver.encoding=UTF8`

这将通过 DriverManager.getConnection(url, driverProperties) 方法传递值为 `UTF8` 的 `encoding` 属性给数据库驱动。

**POOLED**– 这种数据源的实现利用“池”的概念将 JDBC 连接对象组织起来，避免了创建新的连接实例时所必需的初始化和认证时间。 这种处理方式很流行，能使并发 Web 应用快速响应请求。

除了上述提到 UNPOOLED 下的属性外，还有更多属性用来配置 POOLED 的数据源：

- `poolMaximumActiveConnections` – 在任意时间可存在的活动（正在使用）连接数量，默认值：10
- `poolMaximumIdleConnections` – 任意时间可能存在的空闲连接数。
- `poolMaximumCheckoutTime` – 在被强制返回之前，池中连接被检出（checked out）时间，默认值：20000 毫秒（即 20 秒）
- `poolTimeToWait` – 这是一个底层设置，如果获取连接花费了相当长的时间，连接池会打印状态日志并重新尝试获取一个连接（避免在误配置的情况下一直失败且不打印日志），默认值：20000 毫秒（即 20 秒）。
- `poolMaximumLocalBadConnectionTolerance` – 这是一个关于坏连接容忍度的底层设置， 作用于每一个尝试从缓存池获取连接的线程。 如果这个线程获取到的是一个坏的连接，那么这个数据源允许这个线程尝试重新获取一个新的连接，但是这个重新尝试的次数不应该超过 `poolMaximumIdleConnections` 与 `poolMaximumLocalBadConnectionTolerance` 之和。 默认值：3（新增于 3.4.5）
- `poolPingQuery` – 发送到数据库的侦测查询，用来检验连接是否正常工作并准备接受请求。默认是“NO PING QUERY SET”，这会导致多数数据库驱动出错时返回恰当的错误消息。
- `poolPingEnabled` – 是否启用侦测查询。若开启，需要设置 `poolPingQuery` 属性为一个可执行的 SQL 语句（最好是一个速度非常快的 SQL 语句），默认值：false。
- `poolPingConnectionsNotUsedFor` – 配置 poolPingQuery 的频率。可以被设置为和数据库连接超时时间一样，来避免不必要的侦测，默认值：0（即所有连接每一时刻都被侦测 — 当然仅当 poolPingEnabled 为 true 时适用）。

**JNDI** – 这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。这种数据源配置只需要两个属性：

- `initial_context` – 这个属性用来在 InitialContext 中寻找上下文（即，initialContext.lookup(initial_context)）。这是个可选属性，如果忽略，那么将会直接从 InitialContext 中寻找 data_source 属性。
- `data_source` – 这是引用数据源实例位置的上下文路径。提供了 initial_context 配置时会在其返回的上下文中进行查找，没有提供时则直接在 InitialContext 中查找。

和其他数据源配置类似，可以通过添加前缀“env.”直接把属性传递给 InitialContext。比如：

- `env.encoding=UTF8`

这就会在 InitialContext 实例化时往它的构造方法传递值为 `UTF8` 的 `encoding` 属性。

你可以通过实现接口 `org.apache.ibatis.datasource.DataSourceFactory` 来使用第三方数据源实现：

## 3.属性

- 我们可以通过properties属性来实现引用配置文件【db.properties】

- 在加载配置文件的时候，必须按照顺序来写配置文件否则会报下面的

  ```
  Caused by: org.xml.sax.SAXParseException; lineNumber: 32; columnNumber: 17; 元素类型为 "configuration" 的内容必须匹配 "(properties?,settings?,typeAliases?,typeHandlers?,objectFactory?,objectWrapperFactory?,reflectorFactory?,plugins?,environments?,databaseIdProvider?,mappers?)"。
  	at com.sun.org.apache.xerces.internal.util.ErrorHandlerWrapper.createSAXParseException(ErrorHandlerWrapper.java:203)
  ```

  ![image-20200323151755172](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323151755172.png)





我们可以通过properties属性来实现引用配置文件

这些属性都是可外部配置且可动态替换的，既可以在典型的 Java 属性文件中配置，亦可通过 properties 元素的子元素来传递。【db.properties】

编写一个配置文件

db.properties

```properties
driver=com.mysql.jdbc.Driver
url=jdbc:mysql://localhost:3306/mybatis?
useSSL=true&useUnicode=true&characterEncoding=utf8
username=root
password=Cc105481
```



在核心配置文件中引入



```properties
 <!--引入外部配置文件-->
    <properties resource="db.properties">
        <property name="username" value="root"/>
        <property name="password" value="Cc105481"/>
    </properties>
   
```

- 可以直接引入外部文件
- 可以在其中增加一些属性配置
- 如果两个文件有同一字段，优先使用外部配置文件的！

## 4、类型别名（typeAliases）

- 类型别名是为 Java 类型设置一个短的名字。

- 存在的意义仅在于用来减少类完全限定名的冗余。

  ```xml
      <!--可以给实体类起别名-->
      <typeAliases>
          <typeAlias type="com.rui.pojo.User" alias="User"/>
      </typeAliases>
  ```

  也可以指定一个包名，MyBatis 会在包名下面搜索需要的 Java Bean,比如：

  扫描实体类的包，他的默认别名就为这个类的类名，首字母小写！

  ```xml
   <!--可以给实体类起别名-->
      <typeAliases>
          <package name="com.rui.pojo"/>
      </typeAliases>
  ```

  

在实体类比较少的时候，使用第一种方式。

如果实体类十分多，建议使用第二种方式。

第一种可以DIY别名，第二种则不行，如果非要改，需要在实体类（pojo）上增加@Alias注解

```java
@Alias("author")
public class Author {
    ...
}
```

下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。

| 别名       | 映射的类型 |
| :--------- | :--------- |
| _byte      | byte       |
| _long      | long       |
| _short     | short      |
| _int       | int        |
| _integer   | int        |
| _double    | double     |
| _float     | float      |
| _boolean   | boolean    |
| string     | String     |
| byte       | Byte       |
| long       | Long       |
| short      | Short      |
| int        | Integer    |
| integer    | Integer    |
| double     | Double     |
| float      | Float      |
| boolean    | Boolean    |
| date       | Date       |
| decimal    | BigDecimal |
| bigdecimal | BigDecimal |
| object     | Object     |
| map        | Map        |
| hashmap    | HashMap    |
| list       | List       |
| arraylist  | ArrayList  |
| collection | Collection |
| iterator   | Iterator   |



## 5、设置

这是 MyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。

![Settings](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/Settings.png)

驼峰命名

![image-20200323153936894](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323153936894.png)

日志打印

![image-20200323154108956](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323154108956.png)



开启缓存和懒加载

![image-20200323154127008](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323154127008.png)

## 6.其他配置

<img src="C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/%25E7%258B%2582%25E7%25A5%259Emybatis.assets/image-20200323154348618.png" alt="image-20200323154348618" style="zoom:80%;" />

## 7.映射器（mappers）

![image-20200323154504102](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323154504102.png)

<img src="C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/%25E7%258B%2582%25E7%25A5%259Emybatis.assets/image-20200323154830004.png" alt="image-20200323154830004" style="zoom:67%;" />

## 6、生命周期和作用域

生命周期，和作用域是至关重要的，因为错误的使用会导致非常严重的**并发问题**。

**SqlSessionFactoryBuilder**

这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。 因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。 你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但最好还是不要一直保留着它，以保证所有的 XML 解析资源可以被释放给更重要的事情。

- 一旦创建了SqlSessionFactory，就不再需要它了
- 局部变量

!![image-20200323155851451](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323155851451.png)**SqlSessionFactory：**

SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由丢弃它或重新创建另一个实例。 使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏习惯”。因此 SqlSessionFactory 的最佳作用域是应用作用域。 有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。

- 可以想象为：数据库连接池
- SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，**没有任何理由丢弃它或重新创建另一个实例**。
- 因此SqlSessionFactory的最佳作用域是应用作用域。
- 最简单的就是使用 **单例模式** 或者静态单例模式



**SqlSession**

每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。 绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。 也绝不能将 SqlSession 实例的引用放在任何类型的托管作用域中，比如 Servlet 框架中的 HttpSession。 如果你现在正在使用一种 Web 框架，考虑将 SqlSession 放在一个和 HTTP 请求相似的作用域中。 换句话说，每次收到 HTTP 请求，就可以打开一个 SqlSession，返回一个响应后，就关闭它。 这个关闭操作很重要，为了确保每次都能执行关闭操作，你应该把这个关闭操作放到 finally 块中。 下面的示例就是一个确保 SqlSession 关闭的标准模式：

- 连接到连接池的一个请求！

- SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。

- 用完之后需要赶紧关闭，否则会占用资源

  ![SqlSessionFactory](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/SqlSessionFactory.png)

这里的每一个Mapper，就代表一个具体的业务！

## 7.类型

# 5、解决属性名和字段名不一致的问题

## 1、问题

数据库中的字段



![数据库中的字段](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E7%9A%84%E5%AD%97%E6%AE%B5.png)

新建一个项目，拷贝之前的，测试实体类字段不一致的情况。

```java
public class User {
    private int id;
    private String name;
    private String pwd;
}
```

![测试错误](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/%E6%B5%8B%E8%AF%95%E9%94%99%E8%AF%AF.png)

```java
//select * from mybatis.user where id = #{id}
//类型处理器
//select id,name,pwd from mybatis.user where id = #{id}
```

解决方法：

- 起别名

```sql
select id,name,pwd as password from mybatis.user where id = #{id}
```

## 2、resultMap

结果集映射

```
id name pwd
id name password
```

```xml
<!--结果集映射-->
    <resultMap id="UserMap" type="User">
        <!--column数据库中的字段，property实体类中的属性-->
        <id column="id" property="id"/>
        <result column="name" property="name"/>
        <result column="pwd" property="password"/>
    </resultMap>
    <select id="getUserById" resultMap="UserMap" parameterType="int">
       /*定义sql*/
       select * from mybatis.user where id = #{id};
   </select>
```

type是对应的实体类的类型。下面有两个选项，id一般用于主键的映射，result一般用于其他属性的映射。column是数据库内的字段，property是实体类中的属性。



- `resultMap` 元素是 MyBatis 中最重要最强大的元素

- ResultMap 的设计思想是，对于简单的语句根本不需要配置显式的结果映射，而对于复杂一点的语句只需要描述它们的关系就行了。

- `ResultMap` 最优秀的地方在于，虽然你已经对它相当了解了，但是根本就不需要显式地用到他们。

- 如果世界总是这么简单就好了。

  





# 6、日志

## 6.1、日志工厂

如果一个数据库操作，出现了异常，我们需要排错。日志就是最好的助手！

曾经：sout、debug

现在：日志工厂

![image-20200323165825692](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323165825692.png)

- SLF4J 
- LOG4J【掌握】
- LOG4J2
- JDK_LOGGING
- COMMONS_LOGGING 
- STDOUT_LOGGING【掌握】 直接在setting中配置后就能使用
- NO_LOGGING

在Mybatis中具体使用那个日志实现，在设置中设定！

**STDOUT_LOGGING标准日志输出**

在mybatis核心配置文件中，配置我们的日志！

```xml
<settings>
        <setting name="logImpl" value="STDOUT_LOGGING"/>
</settings>
```

导入名字以后一定小小心里面的空格，还有大小写都比如准确

![image-20200323170217004](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323170217004.png)

## 6.2、Log4j

什么事log4j

- Log4j是[Apache](https://baike.baidu.com/item/Apache/8512995)的一个开源项目，通过使用Log4j，我们可以控制日志信息输送的目的地是[控制台](https://baike.baidu.com/item/控制台/2438626)、文件、[GUI](https://baike.baidu.com/item/GUI)组件
- 我们也可以控制每一条日志的输出格式
- 通过定义每一条日志信息的级别，我们能够更加细致地控制日志的生成过程。
- 通过一个[配置文件](https://baike.baidu.com/item/配置文件/286550)来灵活地进行配置，而不需要修改应用的代码。



1.先导入log4j的包

```xml
    <dependencies>
        <!-- https://mvnrepository.com/artifact/log4j/log4j -->
        <dependency>
            <groupId>log4j</groupId>
            <artifactId>log4j</artifactId>
            <version>1.2.17</version>
        </dependency>
    </dependencies>

```



2.log4j.properties

```properties
log4j.rootLogger=debug, stdout, R
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
# Pattern to output the caller's file name and line number.
log4j.appender.stdout.layout.ConversionPattern=%5p [%t] (%F:%L) - %m%n
log4j.appender.R=org.apache.log4j.RollingFileAppender
log4j.appender.R.File=example.log
log4j.appender.R.MaxFileSize=100KB
# Keep one backup file
log4j.appender.R.MaxBackupIndex=5
log4j.appender.R.layout=org.apache.log4j.PatternLayout
log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n




```

3.配置log4j为日志实现

```xml
    <settings>
        <setting name="logImpl" value="LOG4J"/>
    </settings>
```

4.log4j的使用！直接测试运行刚才的查询

```
DEBUG [main] (LogFactory.java:105) - Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter.
DEBUG [main] (LogFactory.java:105) - Logging initialized using 'class org.apache.ibatis.logging.log4j.Log4jImpl' adapter.
DEBUG [main] (PooledDataSource.java:353) - PooledDataSource forcefully closed/removed all connections.
DEBUG [main] (PooledDataSource.java:353) - PooledDataSource forcefully closed/removed all connections.
DEBUG [main] (PooledDataSource.java:353) - PooledDataSource forcefully closed/removed all connections.
DEBUG [main] (PooledDataSource.java:353) - PooledDataSource forcefully closed/removed all connections.
DEBUG [main] (JdbcTransaction.java:136) - Opening JDBC Connection
Loading class `com.mysql.jdbc.Driver'. This is deprecated. The new driver class is `com.mysql.cj.jdbc.Driver'. The driver is automatically registered via the SPI and manual loading of the driver class is generally unnecessary.
DEBUG [main] (PooledDataSource.java:424) - Created connection 2049051802.
DEBUG [main] (JdbcTransaction.java:100) - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@7a220c9a]
DEBUG [main] (BaseJdbcLogger.java:143) - ==>  Preparing: /*定义sql*/ select * from mybatis.user where id = ?; 
DEBUG [main] (BaseJdbcLogger.java:143) - ==> Parameters: 1(Integer)
DEBUG [main] (BaseJdbcLogger.java:143) - <==      Total: 1
User{id=1, name='狂神', password='123456'}
DEBUG [main] (JdbcTransaction.java:122) - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@7a220c9a]
DEBUG [main] (JdbcTransaction.java:90) - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@7a220c9a]
DEBUG [main] (PooledDataSource.java:381) - Returned connection 2049051802 to pool.


Disconnected from the target VM, address: '127.0.0.1:58296', transport: 'socket'

Process finished with exit code 0

```

**简单使用**

1. 在要使用Log4j 的类中，导入org.apache.log4j.Logger;

2. 日志对象，加载参数为当前类的class

   ```java
    static Logger logger = Logger.getLogger(UserDaoTest.class);
   ```

   

3. 日志级别

   ```java
   logger.info("info:进入了testLog4j方法");
   logger.debug("debug:进入了testLog4j");
   logger.error("error:进入了testLog4j");
   ```



# 7、分页

**思考：为什么要分页？**

- 减少数据的处理量

## 7.1、使用Limit分页

```sql
select * from user limit startIndex,pageSize
```



使用Mybatis实现分页，核心SQL

1. 接口

   ```java
   //分页
   List<User> getUserByLimit(Map<String,Integer> map);
   ```

2. Mapper.xml

   ```xml
   <!--分页-->
   <select id="getUserByLimit" parameterType="map" resultMap="UserMap">
       select * from mybatis.user limit #{startIndex},#{pageSize}
   </select>
   ```

3. 测试

   ```java
   @Test
       public void getUserByLimit(){
           SqlSession sqlSession = MyBatisUtils.getSqlSession();
           UserMapper mapper = sqlSession.getMapper(UserMapper.class);
           HashMap<String, Integer> map = new HashMap<>();
           map.put("startIndex",0);
           map.put("pageSize",2);
   
   
           List<User> userList = mapper.getUserByLimit(map);
           for (User user : userList) {
               System.out.println(user);
           }
           sqlSession.close();
       }
   ```

   ## 

## 7.2、RowBounds分页

不再使用SQL实现分页

1. 接口

   ```java
   List<User> getUserByRowBounds();
   ```

2. mapper.xml

   ```xml
   <!--分页2-->
   <select id="getUserByRowBounds" resultMap="UserMap">
       select * from mybatis.user
   </select>
   ```

3. 测试

   ```java
   @Test
   public void getUserByRowBounds(){
       SqlSession sqlSession = MyBatisUtils.getSqlSession();
       //RowBounds实现
       RowBounds rowBounds = new RowBounds(1, 2);
   
       //通过java代码层面实现分页
       List<User> userList = sqlSession.selectList("com.rui.dao.UserMapper.getUserByRowBounds",null,rowBounds);
   
       for (User user : userList) {
           System.out.println(user);
       }
       sqlSession.close();
   }
   ```

## 7.3、分页插件



![image-20200323181523641](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323181523641.png)



# 8、使用注解开发

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；**这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制**。

## 8.1、面向接口编程

**面向接口编程的根本原因：<u>解耦</u>，可拓展，提高复用，分层开发中、上层不用管具体的实现，大家都遵守共同的标准，使得开发变得容易，规范性好**

![image-20200323202210432](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323202210432.png)

![image-20200323202300759](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323202300759.png)



## 8.2、使用注解开发

![image-20200323202340537](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323202340537.png)

1. 注解在接口WareSkuDao上实现

   ```JAVA
   @Select(value = "select * from user")
   List<User> getUsers();
   ```

2. 需要在核心配置文件mybatis-config.xml中绑定接口！

   ```XML
   <!--绑定接口-->
   <mappers>
       <mapper class="rui.dao.UserMapper"/>
   </mappers>
   ```

3. 测试

```JAVA
public class UserMapperTest {
    @Test
    public void test(){
        SqlSession sqlSession = MyBatisUtils.getSqlSession();
        //底层主要应用反射
        UserMapper mapper = sqlSession.getMapper(UserMapper.class);
        List<User> users = mapper.getUsers();
        for (User user : users) {
            System.out.println(user);
        }
        sqlSession.close();
    }
}
```

本质：反射机制实现



底层：动态代理！

![image-20200323204416440](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323204416440.png)

配置的所有东西都会读取到到在sqlsession中，

![image-20200323205048524](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323205048524.png)

通过反射拿到这个类的所有的信息，包括返回值类型。注解。参数。

## 8.3、CRUD

我们可以在工具类创建的时候实现自动提交事务！

```java
 public static SqlSession getSqlSession(){
        return sqlSessionFactory.openSession(true);
    }
```

编写接口，增加注解

```JAVA
public interface UserMapper {
    @Select(value = "select * from user")
    List<User> getUsers();

    //方法存在多个参数，所有的参数前面必须加上@Param注解
    @Select("select * from user where id = #{id} or name = #{name}")
    User getUserByID(@Param("id")int id,@Param("name")String name);

    @Insert("insert into user(id,name,pwd) values (#{id},#{name},#{password})")
    int addUser(User user);

    @Update("update user set name = #{name},pwd = #{password} where id = #{id}")
    int updateUser(User user);

    @Delete("delete from user where id = #{uid}")
    int deleteUser(@Param("uid") int id);
}
```



![image-20200323222625620](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323222625620.png)

使用注解开发时，如果是多个简单类型，必须要用@param注解修饰参数，里面的值要和sql语句的#{}里面的值一致。

而只有一个参数或者是引用类型的参数，不需要添加注解直接使用



测试类

【注意：我们必须要将接口注册绑定到我们的核心配置文件中！】



关于@Param()注解**

- 基本类型的参数或者String类型，需要加上
- 引用类型不需要加
- 如果只有一个基本类型的话，可以忽略，但是建议大家都加上
- 我们在SQL中引用的就是我们这里的@Param()中设定的属性名

**#{}   ${}区别**

https://blog.csdn.net/qian_qian_123/article/details/92844194

使用#的sql语句是预编译的，不存在sql注入问题。而$则不是预编译的，存在sql注入问题

1. ```
   1. ${param}传递的参数会被当成sql语句中的一部分，比如传递表名，字段名
   2.  
   3. 例子：(传入值为id)
   4.  
   5. order by ${param} 
   6.  
   7. 则解析成的sql为：
   8.  
   9. order by id
   10.  
   11.  
   12.  
   13. \#{parm}传入的数据都当成一个字符串，会对自动传入的数据加一个双引号
   14.  
   15. 例子：(传入值为id)
   16.  
   17. select * from table where name = #{param}
   18.  
   19. 则解析成的sql为：
   20.  
   21. select * from table where name = "id"
   22.  
   23. 为了安全，能用#的地方就用#方式传参，这样可以有效的防止sql注入攻击
   24.  
   25.  
   26.  
   27. sql注入简介
   28. 直接上了百度的例子，感觉一看就清晰明了
   29.  
   30.  
   31.  
   32. 某个网站的登录验证的SQL查询代码为：
   33.  
   34. strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');"
   35.  
   36. 恶意填入
   37.  
   38. userName = "1' OR '1'='1";
   39.  
   40. 与passWord = "1' OR '1'='1";
   41.  
   42. 时，将导致原本的SQL字符串被填为
   43.  
   44. strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');"
   45.  
   46. 也就是实际上运行的SQL命令会变成下面这样的
   47.  
   48. strSQL = "SELECT * FROM users;"
   49.  
   50. 这样在后台帐号验证的时候巧妙地绕过了检验，达到无账号密码，亦可登录网站。所以SQL注入攻击被俗称为黑客的填空游戏。
   ```



## 8.4mybatis执行流程解析

![image-20201121132447199](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20201121132447199.png)



![image-20200323210252614](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323210252614.png)
![image-20200323210330264](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/%25E7%258B%2582%25E7%25A5%259Emybatis.assets/image-20200323210330264.png)![image-20201121132646981](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/%25E7%258B%2582%25E7%25A5%259Emybatis.assets/image-20201121132646981.png)

![image-20200323210856336](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323210856336.png)

sqlsession中的执行器会执行sql语句

![image-20200323210731359](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200323210731359.png)

# 9、Lombok

```java
Project Lombok is a java library that automatically plugs into your editor and build tools, spicing up your java.
Never write another getter or equals method again, with one annotation your class has a fully featured builder, Automate your logging variables, and much more.
```



使用步骤：

1. 在IDEA中安装Lombok插件

2. 在项目中导入lombok的jar包

   ```xml
    <!-- https://mvnrepository.com/artifact/org.projectlombok/lombok -->
           <dependency>
               <groupId>org.projectlombok</groupId>
               <artifactId>lombok</artifactId>
               <version>1.18.10</version>
           </dependency>
   ```

   

3. 在实体类上加注解即可


   ```java
   @Getter and @Setter
   @FieldNameConstants
   @ToString
   @EqualsAndHashCode
   @AllArgsConstructor, @RequiredArgsConstructor and @NoArgsConstructor
   @Log, @Log4j, @Log4j2, @Slf4j, @XSlf4j, @CommonsLog, @JBossLog, @Flogger, @CustomLog
   @Data
   @Builder
   @SuperBuilder
   @Singular
   @Delegate
   @Value
   @Accessors
   @Wither
   @With
   @SneakyThrows
   @val
   @var
   experimental @var
   @UtilityClass
   Lombok config system
   ```

**说明：**

```java
@Data:无参构造，get、set、toSring、hashcode、equals
@AllArgsConstructor
@NoArgsConstructor
@ToString
@EqualsAndHashCode
 @Getter k可以放在方法上，也可以放在类上
```



# 10、多对一处理

多对一：

- 多个学生，对应一个老师
- 对于学生这边而言，**关联**...多个学生，关联一个老师【多对一】
- 对于老师而言，**集合**，一个老师又很多学生【一对多】



SQL:

```sql
CREATE TABLE `teacher`(
`id` int(10) Not null,
`name` VARCHAR(30) DEFAULT NULL,
PRIMARY KEY (`id`)
)ENGINE=INNODB DEFAULT CHARSET=utf8

INSERT INTO teacher(`id`,`name`) VALUES (1,'秦老师');

CREATE TABLE `student`(
`id` int(10) Not null,
`name` VARCHAR(30) DEFAULT NULL,
`tid` INT(10) DEFAULT NULL,
PRIMARY KEY (`id`),
KEY `fktid`(`tid`),
CONSTRAINT `fktid` FOREIGN KEY (`tid`) REFERENCES `teacher` (`id`)
)ENGINE=INNODB DEFAULT CHARSET=utf8

INSERT INTO student(`id`,`name`,`tid`) VALUES (1,'小明',1);
INSERT INTO student(`id`,`name`,`tid`) VALUES (2,'小红',1);
INSERT INTO student(`id`,`name`,`tid`) VALUES (3,'小张',1);
INSERT INTO student(`id`,`name`,`tid`) VALUES (4,'小李',1);
INSERT INTO student(`id`,`name`,`tid`) VALUES (5,'小王',1);
```



## 测试环境

1. 导入lombok
2. 新建实体类Teacher，Student
3. 新建Mapper接口
4. 建立Mapper.XML文件
5. 在核心配置文件中绑定注册我们的MApper接口或者文件！【方式很多，随意选】
6. 测试查询是否成功！



## 方法一：按照查询嵌套处理

```mysql
SELECT s.id sid,s.name sname ,t.id tid,t.name tname FROM student s,teacher t WHERE s.tid=t.id;
```

```XML
<!--
思路：
    1、查询所有的学生信息
    2、根据查询出来的学生的id的tid，寻找对应的老师！ -子查询

-->

<select id="getStudent" resultMap="StudentTeacher">
select * from student
</select>

<resultMap id="StudentTeacher" type="com.rui.pojo.Student">
    <!--复杂的属性，我们需要单独处理  对象：association  集合：collection-->
    <association property="teacher" column="tid" javaType="com.rui.pojo.Teacher" select="getTeacher"/>
</resultMap>

<select id="getTeacher" resultType="com.rui.pojo.Teacher">
    select * from teacher where id = #{id}
</select>
```

对象：association 

 集合：collection

select:表明当前属性是调用select指定的方法查出的结果             

column:指定将哪一列的值传给这个方法

## 方法二、按照结果嵌套处理

![image-20200324091210033](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324091210033.png)



```XML
<!--按照结果嵌套处理-->
<select id="getStudent2" resultMap="StudentTeacher2">
    select s.id sid,s.name sname,t.name tname,t.id tid
    from student s,teacher t
    where s.tid=t.id;
</select>

<resultMap id="StudentTeacher2" type="com.rui.pojo.Student">
    <result property="id" column="sid"/>
    <result property="name" column="sname"/>
    <association property="teacher" javaType="com.rui.pojo.Teacher">
        <result property="id" column="tid"></result>
        <result property="name" column="tname"></result>
    </association>

</resultMap>
```

```xml
<select id="getAllStudent2" resultMap="studentTeacher2">
    SELECT s.id sid,s.name sname ,t.id tid,t.name tname FROM student s,teacher t WHERE s.tid=t.id;
</select>
<resultMap id="studentTeacher2" type="Student">
    <id column="sid" property="id"/>
    <result column="sname" property="name"/>
    <association property="teacher" javaType="Teacher"> propetry是student中的teacher的属性 javatype对应的是java的类型
        <result column="tname" property="name"/> 对应teacher中的属性
        <result column="tid" property="id"/>
    </association>
</resultMap>
```



回顾Mysql多对一查询方式：

- 子查询
- 联表查询

# 11、一对多处理

比如：一个老师拥有多个学生！

对于老师而言，就是一对多的关系！





## 环境搭建

1. 环境搭建，和刚才一样

实体类

```JAVA
@Data
public class Teacher {
    private int id;
    private String name;

    //一个老师拥有多个学生
    private List<Student> students;
}
```

```JAVA
@Data
public class Student {
    private int id;
    private String name;
    private int tid;

}
```



## 按照结果嵌套处理

```mysql
SELECT s.id sid,s.name sname ,t.id tid,t.name tname FROM student s,teacher t WHERE s.tid=t.id;
```

![image-20200324092838139](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324092838139.png)

```XML
<!--按结果嵌套查询-->
<select id="getTeacher" resultMap="TeacherStudent">
    select s.id sid,s.name sname,t.name tname,t.id tid
    from student s,teacher t
    where s.tid=t.id and t.id = #{tid}
</select>
<resultMap id="TeacherStudent" type="com.rui.pojo.Teacher">
    <result property="id" column="tid"/>
    <result property="name" column="tname"/>
    <!--复杂的属性，我们需要单独处理  对象：association  集合：collection
        javaType="" 指定属性的类型 在这个方法里面可有可无
        集合中的泛型信息，我们使用ofType获取
    -->
    <collection property="students" ofType="com.rui.pojo.Student">
        <result property="id" column="sid"/>
        <result property="name" column="sname"/>
        <result property="tid" column="tid"/>
    </collection>
</resultMap>
```

![image-20200324094658284](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324094658284.png)

## 按照查询嵌套处理



```XMl
<select id="getTeacher2" resultMap="TeacherStudent2">
    select * from mybatis.teacher where id = #{tid}
</select>
<resultMap id="TeacherStudent2" type="com.rui.pojo.Teacher">
    <collection property="students" javaType="ArrayList" ofType="com.rui.pojo.Student" select="getStudentByTeacherId" column="id"/>//这里的column对应的是teacher中的id。而不是student中的tid，这里是将teacher的id值传给 select的方法getStudentByTeacherId 进行嵌套的查询
</resultMap>

<select id="getStudentByTeacherId" resultType="com.rui.pojo.Student">
    select * from mybatis.student where tid = #{tid}
</select>
```



## 小节

1. 关联-association【多对一】
2. 集合-collection   【一对多】
3. javaType & ofType
   1. JavaType用来指定实体类中属性的类型
   2. ofType用来指定映射到List或者集合中的pojo类型，泛型中的约束类型！

注意点：

- 保证SQL的可读性，尽量保证通俗易懂
- 注意一对多和多对一中，属性名和字段的问题！
- 如果问题不好排查错误，可以使用日志，建议使用Log4j

![image-20200324103850926](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324103850926.png)

**慢SQL		1S		1000S**

面试高频

- Mysql引擎
- InnoDB底层原理
- 索引
- 索引优化！

# 12、动态SQL

![image-20200324104124036](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324104124036.png)

**什么事动态SQL：动态SQL就是指根据不同的条件生成不同的SQL语句**

利用动态SQL这一特性可以彻底摆脱这种痛苦

动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。

- if
- choose (when, otherwise)
- trim (where, set)
- foreach

## 搭建环境

```sql
CREATE TABLE `bolg`(
	`id` VARCHAR(50) NOT NULL COMMENT '博客id',
	`title` VARCHAR(100) not null comment '博客标题',
	`author` VARCHAR(30) not null comment '博客作者',
	`creat_time` datetime not null comment '创建时间',
	`views` int(30) not null comment '浏览量'
)ENGINE=InnoDB DEFAULT CHARSET=utf8
```

创建一个基础工程

1. 导包

2. 编写配置文件

3. 编写实体类

   ```java
   @Data
   public class Blog {
       private int id;
       private String title;
       private String author;
       private Date creatTime;
       private int views;
   }
   ```

4. 编写实体类对应的Mapper接口和Mapper.xml



编写一个工具类。获取动态的id：

```java
package utils;
import java.util.UUID;
public class IdUtils {
    public static String getId() {
        return UUID.randomUUID().toString().replace("-", "");
    }
}
```

## IF

![image-20200324114048702](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324114048702.png)

```mysql
select * from mybatis.bolg where 1=1 and title = #{title} and author = #{author}
```



```XML
<select id="queryBlogIF" parameterType="map" resultType="com.rui.pojo.Blog">
    select * from mybatis.bolg where 1=1
    <if test="title != null">
        and title = #{title}
    </if>
    <if test="author != null">
        and author = #{author}
    </if>
</select>
```

```JAVA
@Test
public void queryBlogIF(){
    SqlSession sqlSession = MyBatisUtils.getSqlSession();
    BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);
    HashMap map = new HashMap();
    map.put("author","尹锐");
    List<Blog> blogs = mapper.queryBlogIF(map);
    for (Blog blog : blogs) {
        System.out.println(blog);
    }
    sqlSession.close();
}
```



## choose (when, otherwise)



```XML
<select id="queryBlogChoose" parameterType="map" resultType="com.rui.pojo.Blog">
    select * from mybatis.bolg
    <where>
        <choose>
            <when test="title != null">
                title=#{title}
            </when>
            <when test="author!=null">
                and author = #{author}
            </when>
            <otherwise>
                and views = #{views}
            </otherwise>
        </choose>
    </where>
</select>
```

当条件都满足的时候，只有第一个when标签起作用



## trim, (where, set)

```xml
select * from mybatis.bolg
<where>
<if test="title != null">
    title = #{title}
</if>
<if test="author != null">
    and author = #{author}
</if>
</where>
```

### set

```XML
<update id="updateBlog" parameterType="map">
    update mybatis.bolg
    <set>
        <if test="title != null">
            title = #{title},
        </if>
        <if test="author != null">
            author = #{author},
        </if>
    </set>
    where id = #{id}
</update>
```

![image-20200324121117022](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324121117022.png)

**所谓的动态SQL，本质还是SQL语句，只是我们可以在SQL层面，去执行一些逻辑代码**

if

Where,set,choose,when

## where标签

![image-20200324115217680](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324115217680.png)

![image-20200324115541973](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324115541973.png)

```xml
<select id="queryBlogIF" parameterType="map" resultType="com.yang.pojo.Blog">
    SELECT * FROM blog 
    <where>
    <if test="title != null">
        and title = #{title}
    </if>
    <if test="author != null">
    and author = #{author}
    </if>
    </where>
</select>
```

如果where中的标签没有一个符合条件的，则where默认会加上一个 where 1=1查询全部的语句。相当于下面的语句

![image-20200324133638838](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324133638838.png)

## SQL片段

有的时候，我们可能会将一些公共的部分抽取出来，方便复用！

1. 使用SQL标签抽取公共的部分

   ```XML
   <sql id="if-title-author">
       <if test="title != null">
           title = #{title}
       </if>
       <if test="author != null">
           and author = #{author}
       </if>
   </sql>
   ```

2. 在需要使用的地方使用Include标签引用即可

   ```XML
   <select id="queryBlogIF" parameterType="map" resultType="com.rui.pojo.Blog">
       select * from mybatis.bolg
       <where>
           <include refid="if-title-author"></include>
       </where>
   </select>
   ```

   注意事项：

   - 最好基于单表来定义SQL片段！
   - 不要存在where或者set**标签**，片段里尽量只有if就好了

   

   ## Foreach

   ![image-20200324132912426](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324132912426.png)

   ```sql
   select * from user where 1=1 and 
     <foreach item="id" index="index" collection="ids"
         open="(" separator="or" close=")">
           #{id}
     </foreach>
   
   ```

(id=1 or id=2 or id=3)

   ```
   ![image-20191205141204114](%E7%8B%82%E7%A5%9Emybatis.assets/image-20191205141204114.png)

   
   
   
   
   
   
   ```xml
   <!--
   select * from mybatis.bolg where 1=1 and (id=1 or id=2 or id=3)
   
   我们现在传递一个万能的map，这个map中可以存在一个map
   -->
   <select id="queryBlogForeach" parameterType="map" resultType="com.yang.pojo.Blog">
            SELECT * FROM blog
            <where>
                <foreach collection="ids" item="id" open="and (" separator="or" close=")">
                 id=#{id}
                </foreach>

            </where>

       </select>
   ```

   ```java
    @Test
     public void queryBlogForeach(){
       SqlSession sqlSession = MybaticUtils.getSqlSession();
       BlogMapper mapper = sqlSession.getMapper(BlogMapper.class);
       HashMap map = new HashMap();
   //    map.put("author","yang");
       ArrayList<Integer> ids= new ArrayList<>();
     ids.add(1);
       ids.add(2);
       map.put("ids" ,ids);
       List<Blog> blogs = mapper.queryBlogForeach(map);
       for (Blog blog : blogs) {
         System.out.println(blog);
       }
       sqlSession.close();
     }
   ```

   

   

   ## 

   **动态SQL就是在拼接SQL语句，我们只要保证SQL的正确性，按照SQL的格式，去排列组合就可以了**

   建议：

   - ​	先在Mysql中写出完整的SQL，在对应的去修改称为我们的动态SQL

# 13、缓存（了解）

## 13.1、简介

```mysql
查询	：		连接数据库，耗资源！
		一次查询的结果，给他暂存在一个可以直接取到的地方！--->内存	：	缓存
		
我们再次查询相同数据的时候，直接走缓存，就不用走数据库了
```

1. 什么事缓存[Cache]?

   - 存在内存中的临时数据。

   - 将用户经常查询的数据放在缓存（内存）中，用户去查询数据就不用从磁盘上（关系型数据库数据文件）查询，

     从缓存中查询，从而提高查询效率，解决了高并发系统的性能问题。

2. 为什么使用缓存？

   - 减少和数据库的交互次数，减少系统开销，提高系统效率。

3. 什么样的数据能使用缓存？

   - 经常查询并且不经常改变的数据。

## 13.2、Mybatis缓存

- MyBatis包含一个非常强大的查询缓存特性，它可以非常方便地定制和配置缓存。缓存可以极大的提升查询效率。
- MyBatis系统中默认定义了两级缓存：**一级缓存**和**二级缓存**
  - 默认情况下，只有一级缓存开启。（SqlSession级别的缓存，也称为本地缓存）
  - 二级缓存需要手动开启和配置，他是基于namespace级别的缓存。
  - 为了提扩展性，MyBatis定义了缓存接口Cache。我们可以通过实现Cache接口来自定义二级缓存



## 13.3、一级缓存

- 一级缓存也叫本地缓存：SqlSession
  - 与数据库同义词会话期间查询到的数据会放在本地缓存中。
  - 以后如果需要获取相同的数据，直接从缓存中拿，没有必要再去查询数据；

![image-20200324142618607](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324142618607.png)

**测试步骤：**

1. 开启日志!
2. 测试在一个Session中查询两次相同的记录
3. 查看日志输出

**缓存失效的情况：**

1. 查询不同的东西

2. 增删改操作，可能会改变原来的数据，所以必定会刷新缓存！

   就算是修改的数据和查询的数据不是同一个，只要有增删改的操作，都会刷新以及缓存

   ![image-20200324142250286](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324142250286.png)

3. 查询不同的Mapper.xml

4. 手动清理缓存！

   ```java
   sqlsession.clearCache(); //手动清理缓存
   ```

![image-20200324142727121](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324142727121.png)

小节：一级缓存默认是开启的，只在一次SqlSession中有效，也就是拿到连接到关闭连接这个区间段！

一级缓存就是一个Map。

![image-20200324142849396](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324142849396.png)

## 13.4、二级缓存

![image-20200324142913927](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324142913927.png)

![image-20200324143007442](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324143007442.png)

- 二级缓存也叫全局缓存，一级缓存作用域太低了，所以诞生了二级缓存
- 基于namespace级别的缓存，一个名称空间，对应一个二级缓存；
- 工作机制
  - 一个会话查询一条数据，这个数据就会被放在当前会话的一级缓存中；
  - 如果当前会话关闭了，这个会话对应的一级缓存就没了；但是我们想要的是，会话关闭了，一级缓存中的数据会被保存到二级缓存中；
  - 新的会话查询信息，就可以从二级缓存中获取内容；
  - 不同的mapper查出的数据会放在自己对应的缓存（map）中；



步骤：

1. 开启全局缓存

   ![image-20200324143058774](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324143058774.png)

   ```xml
   <!--显式的开启全局缓存-->
   <setting name="cacheEnabled" value="true"/>
   ```

2. 在要使用二级缓存的Mapper中开启

   ![image-20200324143350724](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324143350724.png)

   ```xml
   <!--在当前Mapper.xml中使用二级缓存-->
   <cache/>
   也可以自定义参数
   <cache eviction="FIFO"
          flushInterval="60000"
          size="512"
          readOnly="true"/>
   ```

3. 测试

   1. 问题：我们需要将实体类序列化！否则就会报错

      ```java
       java.io.NotSerializableException: com.rui.pojo.User
      ```

      ```
      public class Teacher implements Serializable
      ```

小结：

- 只要开启了二级缓存，在同一个Mapper下就有效
- 所有的数据都会先放在一级缓存中；
- **只有当会话提交，或者关闭的时候，才会提交到二级缓存中！**
- 

## 13.5、缓存原理

![image-20191205170549715](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20191205170549715.png)



## 13.6、自定义缓存-encache

```xml
EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认的CacheProvider。
```

要在程序中使用ehcache，先要导包！

```xml
<!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-ehcache -->
<dependency>
    <groupId>org.mybatis.caches</groupId>
    <artifactId>mybatis-ehcache</artifactId>
    <version>1.1.0</version>
</dependency>

```

然后在mapper中指定使用ehcache缓存实现

```xml
<!--在当前Mapper.xml中使用二级缓存-->
<cache type="org.mybatis.caches.ehcache.EhcacheCache"/>
```



导入配置文件 ehcache.xml

```xml
<?xml version="1.0" encoding="UTF-8"?>
<ehcache xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:noNamespaceSchemaLocation="http://ehcache.org/ehcache.xsd"
         updateCheck="false">
    <!--
       diskStore：为缓存路径，ehcache分为内存和磁盘两级，此属性定义磁盘的缓存位置。参数解释如下：
       user.home – 用户主目录
       user.dir  – 用户当前工作目录
       java.io.tmpdir – 默认临时文件路径
     -->
    <diskStore path="java.io.tmpdir/Tmp_EhCache"/>
    <!--
       defaultCache：默认缓存策略，当ehcache找不到定义的缓存时，则使用这个缓存策略。只能定义一个。
     -->
    <!--
      name:缓存名称。
      maxElementsInMemory:缓存最大数目
      maxElementsOnDisk：硬盘最大缓存个数。
      eternal:对象是否永久有效，一但设置了，timeout将不起作用。
      overflowToDisk:是否保存到磁盘，当系统当机时
      timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。
      timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。
      diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false.
      diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。
      diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。
      memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。
      clearOnFlush：内存数量最大时是否清除。
      memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。
      FIFO，first in first out，这个是大家最熟的，先进先出。
      LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。
      LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。
   -->
    <defaultCache
            eternal="false"
            maxElementsInMemory="10000"
            overflowToDisk="false"
            diskPersistent="false"
            timeToIdleSeconds="1800"
            timeToLiveSeconds="259200"
            memoryStoreEvictionPolicy="LRU"/>
 
    <cache
            name="cloud_user"
            eternal="false"
            maxElementsInMemory="5000"
            overflowToDisk="false"
            diskPersistent="false"
            timeToIdleSeconds="1800"
            timeToLiveSeconds="1800"
            memoryStoreEvictionPolicy="LRU"/>
 
</ehcache>
```



可以自定义缓存

继承和实现了cache接口，实现里面的方法就可以。

![image-20200324154227546](31.mybatis%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86.assets/image-20200324154227546.png)

Redis做缓存比较好

# 14.Mybatis常见问题汇总

#### 1、#{}和${}的区别是什么？

答：

- `${}`是 Properties 文件中的变量占位符，它可以用于标签属性值和 sql 内部，属于静态文本替换，比如${driver}会被静态替换为`com.mysql.jdbc.Driver`。
- `#{}`是 sql 的参数占位符，MyBatis 会将 sql 中的`#{}`替换为?号，在 sql 执行前会使用 PreparedStatement 的参数设置方法，按序给 sql 的?号占位符设置参数值，比如 ps.setInt(0, parameterValue)，`#{item.name}` 的取值方式为使用反射从参数对象中获取 item 对象的 name 属性值，相当于 `param.getItem().getName()`。

#### 2、Xml 映射文件中，除了常见的 select|insert|updae|delete 标签之外，还有哪些标签？

注：这道题是京东面试官面试我时问的。

答：还有很多其他的标签，`<resultMap>`、`<parameterMap>`、`<sql>`、`<include>`、`<selectKey>`，加上动态 sql 的 9 个标签，`trim|where|set|foreach|if|choose|when|otherwise|bind`等，其中为 sql 片段标签，通过`<include>`标签引入 sql 片段，`<selectKey>`为不支持自增的主键生成策略标签。

#### 3、最佳实践中，通常一个 Xml 映射文件，都会写一个 Dao 接口与之对应，请问，这个 Dao 接口的工作原理是什么？Dao 接口里的方法，参数不同时，方法能重载吗？

注：这道题也是京东面试官面试我时问的。

答：Dao 接口，就是人们常说的 `Mapper`接口，接口的全限名，就是映射文件中的 namespace 的值，接口的方法名，就是映射文件中`MappedStatement`的 id 值，接口方法内的参数，就是传递给 sql 的参数。`Mapper`接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为 key 值，可唯一定位一个`MappedStatement`，举例：`com.mybatis3.mappers.StudentDao.findStudentById`，可以唯一找到 namespace 为`com.mybatis3.mappers.StudentDao`下面`id = findStudentById`的`MappedStatement`。在 MyBatis 中，每一个`<select>`、`<insert>`、`<update>`、`<delete>`标签，都会被解析为一个`MappedStatement`对象。

Dao 接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

Dao 接口的工作原理是 JDK 动态代理，MyBatis 运行时会使用 JDK 动态代理为 Dao 接口生成代理 proxy 对象，代理对象 proxy 会拦截接口方法，转而执行`MappedStatement`所代表的 sql，然后将 sql 执行结果返回。

#### 4、MyBatis 是如何进行分页的？分页插件的原理是什么？

答：MyBatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的**内存分页**，而非物理分页，可以在 sql 内直接书写带有物理分页的参数来完成物理分页功能，也可以使用分页插件来完成物理分页。

分页插件的基本原理是使用 MyBatis 提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的 sql，然后重写 sql，根据 dialect 方言，添加对应的物理分页语句和物理分页参数。

举例：`select _ from student`，拦截 sql 后重写为：`select t._ from （select \* from student）t limit 0，10`

```
最近在搭建springboot框架的时候,构建ORM的时候,选择mybatis的时候,我们一般时候用：

      1.mybatis自带的分页RowBounds;

       2.mybatis插件或者直接书写sql进行分页;

          (1).通过自己的封装SQL根据beginNum(开始条数)和endNum(需要的条数)来进行分页

           (2).PageHelper分页插件

     --> mybatis自带分页RowBounds:   //逻辑分页

      Java：   
        RowBounds rb=new RowBounds(offset, limit);  //offset(从多少条开始);limit(获取多少条)
       SqlSession sqlSession=sqlSessionFactory.openSession();//sqlSessionFactory通过读取mybatis配置文件的输入流然后通过new SqlSeesionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-config.xml"));最终得到SqlSessionFactory;
       
         List<Student> studentlist=sqlSession.selectList("xx.xx.Mapper.findStudent",null,rb);//第一个参数为具体Mapper文件的下的findStudent的ID,第二个参数为提供的条件参数,第三个参数为我们要进行对获取学生进行分页

         sqlSession.close();
         return studentlist;

      Mapper：   
        <select id="findStudent" resultType="Student">
            select * from Student
         </select>

      备注：通过以上例子,很明显的看出,在分页的时候,我们是把所有的数据都查询出来,然后通过RowBounds进行在内存分页.通过源码查看,也是通过ResuleSet结果集进行分页;





      --> mybatis自写sql或者通过分页插件PageHelper:   //物理分页

        (1).mybatis PageHelper分页插件 

        Mapper：

            <select id="findStudent" resultType="Student">

                select * from Student

           </select>

        Dao层-StudentDao：

            List<Student> findStudent();

        Service层：

             PageHelper.startPage(pageNum,pageSize);//pageNum 页数  pageSize 数量

           List<Student> stu=studentDao.findStudent();  //studentDao @Autowried注解获取; 在执行查询数据时,就会自动执行2个sql;执行上述Mapper下的ID为findStudent的sql 自动执行分页,通过PageHelper进行识别是何数据库拼接分页语句,若是mysql,自动通过limit分页,若是oracle自动通过rownum进行分页,另一个会自动拼接Mapper下不存在的ID为findStudent_COUNT,查询的总数;可以通过打印的日志进行跟踪;

           PageInfo<Student> page = new PageInfo<Student>(stu); //自动封装总数count以及分页,数据返回页面

           return page;//返回分页之后的数据



      (2).mybatis 自行使用SQL进行分页

            例：     

           SQL代码(mysql数据库)：

               A：select * from Student  LIMIT #{beginNum,jdbcType=INTEGER},#{endNum,jdbcType=INTEGER}    //beginNum开始条数;endNum需要的条数

            

                B：select count(0) from Student

           JAVA：

                Map<String,Object> map=new HashMap<String,Object>();

                 map.put("beginNum",beginNum); 

                map.put("endNum",endNum);  //从第beginNum条开始,读取后面endNum条

                List<Student> studentlist=studentDao.findStudent(Map<String,Object> map);  //studentDao学生dao层

                 Integer count=studentDao.count();//获取总数返回页面

                 //需要手动进行封装总数以及分页信息,数据返回页面;       

        备注：查看如上例子代码,我们就发现了是直接通过SQL进行在数据库中直接分页,得到的数据就是我们想要分页之后的数据,就是物理分页;

 

    总结：

    1：逻辑分页 内存开销比较大,在数据量比较小的情况下效率比物理分页高;在数据量很大的情况下,内存开销过大,容易内存溢出,不建议使用

    2：物理分页 内存开销比较小,在数据量比较小的情况下效率比逻辑分页还是低,在数据量很大的情况下,建议使用物理分页
```



#### 4.1mybatis逻辑分页与物理分页

1.物理分页

物理分页依赖的是某一物理实体，这个物理实体就是数据库，比如MySQL数据库提供了limit关键字，程序员只需要编写带有limit关键字的SQL语句，数据库返回的就是分页结果。

2.逻辑分页

逻辑分页依赖的是程序员编写的代码。**数据库返回的不是分页结果，而是全部数据**，然后再由程序员**通过代码获取分页数据**，常用的操作是一次性从数据库中查询出全部数据并存储到List集合中，因为List集合有序，再根据索引获取指定范围的数据。

#### 5、简述 MyBatis 的插件运行原理，以及如何编写一个插件。

答：MyBatis 仅可以编写针对 `ParameterHandler`、`ResultSetHandler`、`StatementHandler`、`Executor` 这 4 种接口的插件，MyBatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 `InvocationHandler` 的 `invoke()`方法，当然，只会拦截那些你指定需要拦截的方法。

实现 MyBatis 的 Interceptor 接口并复写` intercept()`方法，然后在给插件编写注解，指定要拦截哪一个接口的哪些方法即可，记住，别忘了在配置文件中配置你编写的插件。

#### 5.1 JAVA中 什么是方法签名？

what is method signature in java？
// 在 Java 中什么是方法签名？

> 书中是这么说的：
> Definition: Two of the components of a method declaration comprise the method signature—the method’s name and the parameter types.

方法声明的两个组件构成了方法签名 - **方法的名称**和**参数类型**。
**example:**
这里是一个典型的方法声明:

```java
public double calculateAnswer(double wingSpan, int numberOfEngines,
                              double length, double grossTons) {
    //do the calculation here
}
```

上面方法的签名是:
`calculateAnswer(double, int, double, double)`

参考了几篇博客，知道了方法签名具体是个什么东东，以前都是模模糊糊就过去了，下面放几个博客的链接

> https://blog.csdn.net/u010592926/article/details/76637936
> https://blog.csdn.net/qiuchengjia/article/details/52910884

#### 5.2 Mybatis之插件实现原理

https://www.jianshu.com/p/6d52713fb05e



#### 6、MyBatis 执行批量插入，能返回数据库主键列表吗？、

答：能，JDBC 都能，MyBatis 当然也能。

6.1

#### 7、MyBatis 动态 sql 是做什么的？都有哪些动态 sql？能简述一下动态 sql 的执行原理不？

答：MyBatis 动态 sql 可以让我们在 Xml 映射文件内，以标签的形式编写动态 sql，完成逻辑判断和动态拼接 sql 的功能，MyBatis 提供了 9 种动态 sql 标签 `trim|where|set|foreach|if|choose|when|otherwise|bind`。

其执行原理为，使用 OGNL 从 sql 参数对象中计算表达式的值，根据表达式的值动态拼接 sql，以此来完成动态 sql 的功能。

#### 8、MyBatis 是如何将 sql 执行结果封装为目标对象并返回的？都有哪些映射形式？

答：第一种是使用`<resultMap>`标签，**逐一定义列名和对象属性名之间的映射关系**。第二种是使用 **sql 列的别名功能**，将列别名书写为对象属性名，比如 T_NAME AS NAME，对象属性名一般是 name，小写，但是列名不区分大小写，MyBatis 会忽略列名大小写，智能找到与之对应对象属性名，你甚至可以写成 T_NAME AS NaMe，MyBatis 一样可以正常工作。

有了列名与属性名的映射关系后，**MyBatis 通过反射创建对象，同时使用反射给对象的属性逐一赋值并返回**，那些找不到映射关系的属性，是无法完成赋值的。

#### 9、MyBatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。

答：能，MyBatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询，多对一查询，其实就是一对一查询，只需要把 `selectOne()`修改为 `selectList()`即可；多对多查询，其实就是一对多查询，只需要把 `selectOne()`修改为 `selectList()`即可。

关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询，就可以把主对象和其关联对象查出来。

那么问题来了，join 查询出来 100 条记录，如何确定主对象是 5 个，而不是 100 个？其去重复的原理是`<resultMap>`标签内的`<id>`子标签，指定了唯一确定一条记录的 id 列，MyBatis 根据列值来完成 100 条记录的去重复功能，`<id>`可以有多个，代表了联合主键的语意。

同样主对象的关联对象，也是根据这个原理去重复的，尽管一般情况下，只有主对象会有重复记录，关联对象一般不会重复。

举例：下面 join 查询出来 6 条记录，一、二列是 Teacher 对象列，第三列为 Student 对象列，MyBatis 去重复处理后，结果为 1 个老师 6 个学生，而不是 6 个老师 6 个学生。

t_id t_name s_id

| 1 | teacher | 38 | | 1 | teacher | 39 | | 1 | teacher | 40 | | 1 | teacher | 41 | | 1 | teacher | 42 | | 1 | teacher | 43 |

#### 10、MyBatis 是否支持延迟加载？如果支持，它的实现原理是什么？

答：MyBatis 仅**支持 association 关联对象和 collection 关联集合对象的延迟加载**，association 指的就是一对一，collection 指的就是一对多查询。在 MyBatis 配置文件中，可以配置是否启用延迟加载 `lazyLoadingEnabled=true|false。`

它的原理是，使用` CGLIB` 创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用 `a.getB().getName()`，拦截器 `invoke()`方法发现 `a.getB()`是 null 值，那么就会单独发送事先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调用 a.setB(b)，于是 a 的对象 b 属性就有值了，接着完成 `a.getB().getName()`方法的调用。这就是延迟加载的基本原理。

当然了，不光是 MyBatis，几乎所有的包括 Hibernate，支持延迟加载的原理都是一样的。

#### 11、MyBatis 的 Xml 映射文件中，不同的 Xml 映射文件，id 是否可以重复？

注：我出的。

答：不同的 Xml 映射文件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践而已。

原因就是 namespace+id 是作为 `Map<String, MappedStatement>`的 key 使用的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，自然 id 就可以重复，namespace 不同，namespace+id 自然也就不同。

#### [12、MyBatis 中如何执行批处理？](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/mybatis/mybatis-interview?id=_12、mybatis-中如何执行批处理？)

注：我出的。

答：使用 BatchExecutor 完成批处理。

#### [13、MyBatis 都有哪些 Executor 执行器？它们之间的区别是什么？](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/mybatis/mybatis-interview?id=_13、mybatis-都有哪些-executor-执行器？它们之间的区别是什么？)

注：我出的

答：MyBatis 有三种基本的 Executor 执行器，**`SimpleExecutor`、`ReuseExecutor`、`BatchExecutor`。**

**`SimpleExecutor`：**每执行一次 update 或 select，就开启一个 Statement 对象，用完立刻关闭 Statement 对象。

**``ReuseExecutor`：**执行 update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使用，不存在就创建，用完后，不关闭 Statement 对象，而是放置于 Map<String, Statement>内，供下一次使用。简言之，就是重复使用 Statement 对象。

**`BatchExecutor`：**执行 update（没有 select，JDBC 批处理不支持 select），将所有 sql 都添加到批处理中（addBatch()），等待统一执行（executeBatch()），它缓存了多个 Statement 对象，每个 Statement 对象都是 addBatch()完毕后，等待逐一执行 executeBatch()批处理。与 JDBC 批处理相同。

作用范围：Executor 的这些特点，都严格限制在 SqlSession 生命周期范围内。

#### [14、MyBatis 中如何指定使用哪一种 Executor 执行器？](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/mybatis/mybatis-interview?id=_14、mybatis-中如何指定使用哪一种-executor-执行器？)

注：我出的

答：在 MyBatis 配置文件中，可以指定默认的 ExecutorType 执行器类型，也可以手动给 `DefaultSqlSessionFactory` 的创建 SqlSession 的方法传递 ExecutorType 类型参数。

#### [15、MyBatis 是否可以映射 Enum 枚举类？](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/mybatis/mybatis-interview?id=_15、mybatis-是否可以映射-enum-枚举类？)

注：我出的

答：MyBatis 可以映射枚举类，不单可以映射枚举类，MyBatis 可以映射任何对象到表的一列上。映射方式为自定义一个 `TypeHandler`，实现 `TypeHandler` 的 `setParameter()`和 `getResult()`接口方法。`TypeHandler` 有两个作用，一是完成从 javaType 至 jdbcType 的转换，二是完成 jdbcType 至 javaType 的转换，体现为 `setParameter()`和 `getResult()`两个方法，分别代表设置 sql 问号占位符参数和获取列查询结果。

#### [16、MyBatis 映射文件中，如果 A 标签通过 include 引用了 B 标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在 A 标签的前面？](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/mybatis/mybatis-interview?id=_16、mybatis-映射文件中，如果-a-标签通过-include-引用了-b-标签的内容，请问，b-标签能否定义在-a-标签的后面，还是说必须定义在-a-标签的前面？)

注：我出的

答：虽然 MyBatis 解析 Xml 映射文件是按照顺序解析的，但是，被引用的 B 标签依然可以定义在任何地方，MyBatis 都可以正确识别。

原理是，MyBatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，MyBatis 会将 A 标签标记为未解析状态，然后继续解析余下的标签，包含 B 标签，待所有标签解析完毕，MyBatis 会重新解析那些被标记为未解析的标签，此时再解析 A 标签时，B 标签已经存在，A 标签也就可以正常解析完成了。

#### [17、简述 MyBatis 的 Xml 映射文件和 MyBatis 内部数据结构之间的映射关系？](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/mybatis/mybatis-interview?id=_17、简述-mybatis-的-xml-映射文件和-mybatis-内部数据结构之间的映射关系？)

注：我出的

答：MyBatis 将所有 Xml 配置信息都封装到 All-In-One 重量级对象 Configuration 内部。在 Xml 映射文件中，`<parameterMap>`标签会被解析为 `ParameterMap` 对象，其每个子元素会被解析为 ParameterMapping 对象。`<resultMap>`标签会被解析为 `ResultMap` 对象，其每个子元素会被解析为 `ResultMapping` 对象。每一个`<select>、<insert>、<update>、<delete>`标签均会被解析为 `MappedStatement` 对象，标签内的 sql 会被解析为 BoundSql 对象。

#### [18、为什么说 MyBatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？](https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/mybatis/mybatis-interview?id=_18、为什么说-mybatis-是半自动-orm-映射工具？它与全自动的区别在哪里？)

注：我出的

答：Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象时，可以根据对象关系模型直接获取，所以它是全自动的。而 MyBatis 在查询关联对象或关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。

面试题看似都很简单，但是想要能正确回答上来，必定是研究过源码且深入的人，而不是仅会使用的人或者用的很熟的人，以上所有面试题及其答案所涉及的内容，在我的 MyBatis 系列博客中都有详细讲解和原理分析。