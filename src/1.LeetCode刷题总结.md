

### 1.Java中字符串定义，初始化，赋值为null的区别

String类是final修饰的，以字面量的形式创建String变量时，jvm会在编译期间就把该字面量（“abcd”）放到字符串常量池中，由Java程序启动的时候就已经加载到内存中了。这个字符串常量池的特点就是有且只有一份相同的字面量，如果有其它相同的字面量，jvm则返回这个字面量的引用，如果没有相同的字面量，则在字符串常量池创建这个字面量并返回它的引用。 堆内存:存储的是数组和对象（其实数组就是对象），**凡是new建立的都是在堆中**，堆中存放的都是实体（对象），实体用于封装数据，而且是封装多个（实体的多个属性），如果一个数据消失，这个实体也没有消失，还可以用，所以堆是不会随时释放的，但是栈不一样，栈里存放的都是单个变量，变量被释放了，那就没有了。堆里的实体虽然不会被释放，但是会被当成垃圾，Java有垃圾回收机制不定时的收取。 执行语句String str="abcd"时，首先查看字符串池中是否存在字符串"abcd"，如果存在则直接将"abcd"赋给str，如果不存在则先在字符串池中新建一个字符串"abcd"，然后再将其赋给str。 执行语句String str=new String("abcd")时，不管字符串池中是否存在字符串"abcd"，直接新建一个字符串"abcd"（注意：新建的字符串"abcd"不是在字符串池中），然后将其付给str。前一语句的效率高，后一语句的效率低，因为新建字符串占用内存空间。

1、概述：

字符串定义 只定义不分配内存空间，不做任何操作；

 

字符串初始化 两种方式直接等号赋值，用new初始化，直接等号赋值放入内存池，其它变量也可以引用；new初始化分配内存空间，不可引用；

 

字符串赋值为null 初始化了，并且有了引用，但是没有指向任何内存空间；
2、详解：

String s;和String s=null;和String s="a";有什么区别？


第一个只是定义了一个String类型变量s，并没有给它赋初值，在Java中，默认在使用一个变量的时候必须赋予它初值（降低风险）。 
第二个和第三个都定义了String类型变量s，并赋予它初值，只不过第二个赋予的值为null（空）罢了


主要要理解的是
String s; s为一个引用～～它不是对象   


第一个是没有初始化的引用；   
第二个为空引用；
第三个是在字符串池里写入一个字符'a',然后用s指向它。


String s;只是给s分配一个内存空间   
String s=null;是分配的空间中存储的值为空值   
String s="a";这句就不用我多说了分配的空间的值为字符a


特别关注：String s="a"和String s=new String("a");是有本质上的区别的 

前者是在字符串池里写入一个字符'a',然后用s指向它；
后者是在堆上创建一个内容为"a"的字符串对象。


1、双引号的方式
String x = abcd;
String y = abcd;
         
System.out.println(x==y);//true
System.out.println(x.equals(y));//true

上面的输出结果：
x==y 的结果为true 是因为通过双引号赋值的方式之后，x 和 y 都是指向同一个内存地址，他们的引用都是指向方法区中的同一个内容，引用地址是一样的， 当同一个String字面值无论被创建多少次，始终只有一个内存地址被分配，之后的都是这个String的拷贝，Java中称作“字符串驻留”，所有的字符串常量在编译之后都会自动的驻留。x = abcd这种方式创建的时候首先会查看字符串池中是否已经存在，存在就直接返回PermGen中的该String对象，否则就会创建一个新的String对象，之后再放进字符串池中。

JVM里，考虑到垃圾回收（Garbage Collection）的方便，将 heap 划分为三部分： young generation （新生代）、 tenured generation（old generation）（旧生代）和 permanent generation( permgen )（永久代）


字符串池是为了解决字符串重复的问题，生命周期长，它存在于 permgen 中。

编译 Java 源代码时，源文件中出现的双引号内的字符串都被收纳到常量池中，用 CONSTANT_utf8_info 项存储着。

JVM 中，相应的类被加载运行后，常量池对应的映射到 JVM 的运行时常量池中。其中每项 CONSTANT_utf8_info（也就试记录那些字符串的）都会在常量引用解析时，自动生成相应的 internal String，记录在字符串池中。

2、构造器的方式
String a = new String(abcd);
String b = new String(abcd);
         
System.out.println(a==b);//false
System.out.println(a.equals(b));//true

上面代码运行结果：

a==b 为false 是因为通过new 构造器的方法创建之后，在heap堆中分别分配了两个内存地址。a 和 b 分别指向了堆中的两个不同的对象，不同的对象就会有不同的地址分配。

下面这张图就很好的阐述了上面的两种情况：
![image-20200526103628644](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200526103628644.png)

### 2.java中当给一个对象赋值为null

https://my.oschina.net/zjllovecode/blog/845165

```java
String[]  arr  =  new String[10]; 
arr=null;
```

将arr这个引用置空，不指向任何对象。 上面new的那个数组对象，则没有任何引用指向它，垃圾回收器可以回收此对象。

**java中对象引用放在栈中，对象的实例放于堆中**，一个对象要是只声明不赋值，则只会在内存的栈区创建引用，堆中并无此引用的指向。 而null对象在堆中会被java的垃圾回收机制回收。



在Java中，null值表示引用不指向任何对象。运行过程中系统发现使用了这样一个引用时·可以立即停止进一步的访问，不会给系统带来任何危险。

1.如果是对象的field的话那么系统在初始化对象的时候会把那些对象的值赋值为null，基本数据类型也有它们的初始值 2.如果是在方法内，那么程序员需要自己给这些变量赋值。

```java
class T{
  Object obj = null;
  Object obj1;//系统在初始化的时候会自动的给他赋值为null
}
class T{
  public void x(){
    Object obj = null;//这个需要程序员自己来做了
  }
}
```

**类中的变量不用初始化 方法中的局部变量必须初始化**

一、null是代表不确定的对象

Java中，null是一个关键字，用来标识一个不确定的对象。因此可以将null赋给引用类型变量，但不可以将null赋给基本类型变量。

比如：int a = null;是错误的。Ojbect o = null是正确的。

Java中，变量的适用都遵循一个原则，先定义，并且初始化后，才可以使用。我们不能int a后，不给a指定值，就去打印a的值。这条对对于引用类型变量也是适用的。

有时候，我们定义一个引用类型变量，在刚开始的时候，无法给出一个确定的值，但是不指定值，程序可能会在try语句块中初始化值。这时候，我们下面使用变量的时候就会报错。这时候，可以先给变量指定一个null值，问题就解决了。例如：

```
   Connection conn = null;
        try {
            conn = DriverManager.getConnection("url", "user", "password");
        } catch (SQLException e) {
            e.printStackTrace();
        }
 
        String catalog = conn.getCatalog();
```

如果刚开始的时候不指定conn = null，则最后一句就会报错。

二、null本身不是对象，也不是Objcet的实例

null本身虽然能代表一个不确定的对象，但就null本身来说，它不是对象，也不知道什么类型，也不是java.lang.Object的实例。 可以做一个简单的例子：

```
 //null是对象吗? 属于Object类型吗?
        if (null instanceof java.lang.Object) {
            System.out.println("null属于java.lang.Object类型");
        } else {
            System.out.println("null不属于java.lang.Object类型");
        }
```

结果会输出：null不属于java.lang.Object类型

三、Java默认给变量赋值

在定义变量的时候，如果定义后没有给变量赋值，则Java在运行时会自动给变量赋值。赋值原则是整数类型int、byte、short、long的自动赋值为0，带小数点的float、double自动赋值为0.0，boolean的自动赋值为false，其他各供引用类型变量自动赋值为null。 这个具体可以通过调试来看。

四、容器类型与null

List：允许重复元素，可以加入任意多个null。 Set：不允许重复元素，最多可以加入一个null。 Map：Map的key最多可以加入一个null，value字段没有限制。 数组：基本类型数组，定义后，如果不给定初始值，则java运行时会自动给定值。引用类型数组，不给定初始值，则所有的元素值为null。

五、null的其他作用

1、判断一个引用类型数据是否null。 用==来判断。

 2、释放内存，让一个非null的引用类型变量指向null。这样这个对象就不再被任何对象应用了。等待JVM垃圾回收机制去回收。

### 3.数组常用操作

#### 创建一个新的数组：

```Java
Java中创建数组的几种方法

public static void main(String[] args) {
//创建数组的第一种方法
int[] arr=new int[6];
int intValue=arr[5];
//System.out.println(intValue);
//创建数组的第二种方法
int[] x={1,2,3,4};
//System.out.println(x[1]);

//创建数组的第三种方法。
int[] y= new int[]{1,2,3,4,5};
int m=0;
boolean length = isLength(m,y);
if(length){
System.out.println(y[m]);
}else{
System.err.println("数组标越界");
}

}
//判断数组下标是否越界
public static boolean isLength(int m,int arr[]){
boolean flag=false;
int length = arr.length;
if(m<length)
flag=true;
return flag;
}
```



#### 2.二维数组

```java
这里写四种创建数组的方式：

1，

float f[][] = new float[6][6];
2,

float []f[] = new float[6][6];
3,

float [][]f = new float[6][6];
4,

float [][]f = new float[6][];



//第一种方式：？？？？
        int a[][]={{1,2,3},{4,5,6}};
        //第二种方式；
        int[][] ints = new int[4][2];
        ints[i][j] =__; //分别赋值
        //第三种方式：第二维的长度可以动态申请
        int[][] arr3 = new int[5][];//五行的长度
        for(int i=0; i<arr3.length; ++i){
            arr3[i]=new int[i+1];   //列的长度每次都变化。每次都要重新申请空间(长度)
            for(int j=0; j<arr3[i].length; ++j)
                arr3[i][j]= i+j;
        }

```

https://blog.csdn.net/Code_lr/article/details/78538937

#### 3.常用的十二个方法

以下是12个关于Java数组最常用的方法，它们是stackoverflow得票最高的问题。

声明一个数组

```
String[] aArray = new String[5];
String[] bArray = {"a","b","c", "d", "e"};
String[] cArray = new String[]{"a","b","c","d","e"};
```

输出数组的长度：

arr3.length

打印一个数组



```
int[] intArray = { 1, 2, 3, 4, 5 };
String intArrayString = Arrays.toString(intArray);
// print directly will print reference value
System.out.println(intArray);
// [I@7150bd4d
System.out.println(intArrayString);
// [1, 2, 3, 4, 5]
```



根据数组创建ArrayList

```
String[] stringArray = { "a", "b", "c", "d", "e" };
ArrayList<String> arrayList = new ArrayList<String>(Arrays.asList(stringArray));
System.out.println(arrayList);
// [a, b, c, d, e]
```

判断数组内部是否包含某个值

```
String[] stringArray = { "a", "b", "c", "d", "e" };
boolean b = Arrays.asList(stringArray).contains("a");
System.out.println(b);
// true
```

连接两个数组

```
int[] intArray = { 1, 2, 3, 4, 5 };
int[] intArray2 = { 6, 7, 8, 9, 10 };
// Apache Commons Lang library
int[] combinedIntArray = ArrayUtils.addAll(intArray, intArray2);
```

声明一个内联数组（array inline）

```
method(new String[]{"a", "b", "c", "d", "e"});
```

根据分隔符拼接数组元素（去掉最后一个分隔符）

```
// containing the provided list of elements
// Apache common lang
String j = StringUtils.join(new String[] { "a", "b", "c" }, ", ");
System.out.println(j);
// a, b, c
```

ArrayList转数组

```
String[] stringArray = { "a", "b", "c", "d", "e" };
ArrayList<String> arrayList = new ArrayList<String>(Arrays.asList(stringArray));
String[] stringArr = new String[arrayList.size()];
arrayList.toArray(stringArr);
for (String s : stringArr)
    System.out.println(s);
```

Array转Set

```
Set<String> set = new HashSet<String>(Arrays.asList(stringArray));
System.out.println(set);
//[d, e, b, c, a]
```

反转数组

```
int[] intArray = { 1, 2, 3, 4, 5 };
ArrayUtils.reverse(intArray);
System.out.println(Arrays.toString(intArray));
//[5, 4, 3, 2, 1]
```

删除数组元素

```
int[] intArray = { 1, 2, 3, 4, 5 };
int[] removed = ArrayUtils.removeElement(intArray, 3);//create a new array
System.out.println(Arrays.toString(removed));
```

整形转字节数组

```
byte[] bytes = ByteBuffer.allocate(4).putInt(8).array();
for (byte t : bytes) {
    System.out.format("0x%x ", t);
}
```

#### System.arraycopy

```java
public static native void arraycopy(Object src,int srcPos,Object dest, int destPos,int length)；
```

> ```
> Copy* @param      src      the source array. 源数组
> * @param      srcPos   starting position in the source array. 源数组的起始位置
> * @param      dest     the destination array. 目标数组
> * @param      destPos  starting position in the destination data. 目标数组的起始位置
> * @param      length   the number of array elements to be copied. 复制的长度
> ```

举个栗子：

将array数组复制到新的数组中；

```java
Copyint[] array = {1, 2, 3, 4, 5};
int[] targetArr = new int[array.length];
System.arraycopy(array,0,targetArr,0,array.length);
```

### 4、栈和队列常用操作

#### 4.1.栈



```java
Stack:
1-->public Stack()创建一个空堆栈
2-->public boolean empty()测试堆栈是否为空;
3-->public E pop()移除堆栈顶部的对象，并作为此函数的值返回该对象。 
4-->public E push(E item)把项压入堆栈顶部 
5-->public E peek()查看堆栈顶部的对象，但不从堆栈中移除它。 
6-->public boolean isEmpty()测试堆栈是否为空
```

在stack中有自己添加元素的方法push();但是在操作过程中发现，add()同样可以添加元素至stack

那这两个方法有什么不同呢？

stack本身没有add()方法，但是继承的类vector有add方法同样vector的父类和实现接口List同样有add()方法。

add & push

共同点：

add，push都可以向stack中添加元素。

不同点：

add是继承自Vector的方法，且返回值类型是boolean。

push是Stack自身的方法，返回值类型是添加的该元素。

具体的看源码：



       public synchronized boolean add(E e) {
            modCount++;
            ensureCapacityHelper(elementCount + 1);
            elementData[elementCount++] = e;
            return true;
        }
    public E push(E item) {
            addElement(item); 
        return item;
    }
peek & pop

共同点：

peek，pop都是返回栈顶元素。

不同点：

peek()函数返回栈顶的元素，但不弹出该栈顶元素。
pop()函数返回栈顶的元素，并且将该栈顶元素出栈。



#### 4.2 队列：

　队列是一种特殊的[线性表](https://baike.baidu.com/item/线性表/3228081)，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，

队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。

队列是一种特殊的线性表，它只允许在表的前端进行删除操作，而在表的后端进行插入操作。

LinkedList类实现了Queue接口，因此我们可以把LinkedList当成Queue来用。

LinkedList可以当成一个队列使用，因为他有removefirst方法和addlast方法

以下实例演示了队列（Queue）的用法：

```java
boolean  add(E e) //将指定的元素插入此队列（如果立即可行且不会违反容量限制），在成功时返回 true，如果当前没有可用的空间，则抛出 IllegalStateException。
E        element() //获取，但是不移除此队列的头。
boolean  offer(E e) //将指定的元素插入此队列（如果立即可行且不会违反容量限制），当使用有容量限制的队列时，此方法通常要优于 add(E)，后者可能无法插入元素，而只是抛出一个异常。
E        peek() //获取但不移除此队列的头；如果此队列为空，则返回 null。
E        poll() //获取并移除此队列的头，如果此队列为空，则返回 null。
E        remove() //获取并移除此队列的头。
```

```
import java.util.LinkedList;
import java.util.Queue;
 
public class Main {
    public static void main(String[] args) {
        //add()和remove()方法在失败的时候会抛出异常(不推荐)
        Queue<String> queue = new LinkedList<String>();
        //添加元素
        queue.offer("a");
        queue.offer("b");
        queue.offer("c");
        queue.offer("d");
        queue.offer("e");
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("poll="+queue.poll()); //返回第一个元素，并在队列中删除
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("element="+queue.element()); //返回第一个元素 
        for(String q : queue){
            System.out.println(q);
        }
        System.out.println("===");
        System.out.println("peek="+queue.peek()); //返回第一个元素 
        for(String q : queue){
            System.out.println(q);
        }
    }
}
```

**offer，add 区别：**

一些队列有大小限制，因此如果想在一个满的队列中加入一个新项，多出的项就会被拒绝。

这时新的 offer 方法就可以起作用了。它不是对调用 add() 方法抛出一个 unchecked 异常，而只是得到由 offer() 返回的 false。

**poll，remove 区别：**

remove() 和 poll() 方法都是从队列中删除第一个元素。remove() 的行为与 Collection 接口的版本相似， 但是新的 poll() 方法在用空集合调用时不是抛出异常，只是返回 null。因此新的方法更适合容易出现异常条件的情况。

**peek，element区别：**

element() 和 peek() 用于在队列的头部查询元素。与 remove() 方法类似，在队列为空时， element() 抛出一个异常，而 peek() 返回 null。

#### 4.3 两种遍历方式

1.队列

```java
public static void main(String[] args) { 
                Queue<Integer> q = new LinkedBlockingQueue<Integer>(); 
               //初始化队列 
                for (int i = 0; i < 5; i++) { 
                        q.offer(i); 
                } 
                System.out.println("-------1-----"); 
                //集合方式遍历，元素不会被移除 
                for (Integer x : q) { 
                        System.out.println(x); 
                } 
                System.out.println("-------2-----"); 
                //队列方式遍历，元素逐个被移除 
                while (q.peek() != null) { 
                        System.out.println(q.poll()); 
                } 
        } 
```

2.栈的遍历方式

```java
            public class TestStack { 

        public static void main(String[] args) { 

                Stack<Integer> s = new Stack<Integer>(); 
                for (int i = 0; i < 10; i++) { 
                        s.push(i); 
                } 

                //集合遍历方式 
                for (Integer x : s) { 
                        System.out.println(x); 
                } 
                System.out.println("------1-----"); 
                //栈弹出遍历方式 
//                while (s.peek()!=null) {     //不健壮的判断方式，容易抛异常，正确写法是下面的 
                while (!s.empty()) { 
                        System.out.println(s.pop()); 
                } 
                System.out.println("------2-----"); 
                //错误的遍历方式 
//                for (Integer x : s) { 
//                        System.out.println(s.pop()); 
//                } 
        } 
}
```









### 6.list常用方法



5、ListIterator<E> **listIterator**()

返回此列表元素的列表迭代器（按适当顺序）。

listIterator和iterator的区别是什么呢？下面这篇博客比较详细的分析，可以参考。

https://blog.csdn.net/longshengguoji/article/details/41551491

这里大概讲一下他们的区别：

当只需要遍历集合时，两个迭代器的功能都是一样。

但是listIterator迭代器只能用于List和他的实现子类，iterator迭代器可以用于所有的集合使用。

所不同的就是listIterator迭代器的功能会比iterator迭代器的功能要多。

listIterator迭代器可以在遍历集合时添加、修改和删除，而iterator迭代器在遍历集合时只有删除。

#### E **set**(int index, E element)

在索引为index位置的元素更改为element元素

####  E **remove**(int index)

删除指定索引的对象

#### List<E> **subList**(int fromIndex, int toIndex)

返回从索引fromIndex到toIndex的元素集合，包左不包右

![image-20200705174857928](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200705174857928.png)

#### int **indexOf**(Object o)

返回list集合中第一次出现o对象的索引位置，如果list集合中没有o对象，那么就返回-1

#### E **get**(int index)

返回list集合中指定索引位置的元素



list.addAll
list.subList()
list.indexOf()
list.clear()
list.equals(list2)
list.isEmpty
List定义时添加多条数据
list.remove(i)
list.contains()
list转数组
检验List是否存在重复的元素
Stream操作List
List取出对象中某一属性
List，将id属性逗号拼接
List，将id属性逗号拼接后转换为Strnig类型
List转换为另一个List
List过滤元素
List转换为Map
List与List差集
List与List交集
List与List去重并集
List求交集
list.addAll
 list.addAll(list);// 向集合追加一个collection，只可追加collection，由于java不提供collection的实现，由它的下级接口来实现
 list.addAll(4, list);// 与上述含义相同， “4”意为追加元素所放的位置
list.subList()

```
list.subList(1,3)//返回下标从1到3的数据 ，包括左不包括右 即返回下标为1,2的数据

List<Object> subList = list.subList(0, 5);

其中subList(0, 5)取得的是下标为0到4的元素,不包含下标为5的元素.
```



#### list.indexOf()

//在集合中查找元素 ，"a"如果有 ,返回所查找元素的下标,如果不存在则返回-1
  list.indexOf("a");
**list.clear()**
 list.clear();// 调用clear方法清空集合中的所有数据
**list.equals(list2)**
//该方法去比较两个对象时，首先先去判断两个对象是否具有相同的地址，如果是同一个对象的引用，则直接放回true；如果地址不一样，
//则证明不是引用同一个对象，接下来就是挨个去比较两个字符串对象的内容是否一致，完全相等返回true，否则false。
 list.equals(arr);//false
**list.isEmpty**
有没有瓶子 list != null
瓶子里有没有水 list.isEmpty()
判断的时候一定要注意先后顺序 如果没有瓶子都没有，直接判断有没有水，是会报nullException的
**list.add(null)会造成list.isEmpty() 为false,但是list.size()为1， 所以代码里要避免list.add(null)的陷阱 。**
**list==null,它其实是根本没有在堆内是不存在的，没有存储的地址。但是list.size()=0是已经存在地址，但是并没有存相应的元素，当元素的数量增加是，size随之变化。**
null说明了没有进行初始化，此时要是调用任何的方法的话都会抛出空指针异常，而list.size（）==0表示此list已经new过，但是其中没有存入任何值。
isEmpty先获取size的值在判断再返回，list.size则是直接返回属性size的值，相对isEmpty较快。看源码：
 public boolean isEmpty() {
     return size == 0;
 }
例子：我有一个空着的水杯（list），而你没有，那你是null，我的size为0。你想装水需要去买个水杯（new ArrayList();），我就可以直接装水（list.add(水)）。你要是没有杯子直接倒水，水就流出去啦（空指针异常）。所以用做判断的时候经常连用list!=null && list.size()!=0 。
区别： 是否存在，存在的话是否存放元素。因此最先判断是否存在实物，再判断实物中是否存放东西。

List定义时添加多条数据
 List<Integer> requiredCol = new ArrayList<Integer>() {{ add(1);add(2);add(3);add(4); }};
**list.remove(i)**
list.remove(i);//移除指定位置数据
list.contains()
contains方法的源码是用equals()比较的,也就是说比较的是地址,所以要在类中重写equals()方法.看代码如何实现的
 public boolean equals(Object obj) {
        if(this==obj)//地址相同
            return true;
        else if(obj!=null&&obj instanceof User) {
            User u=(User)obj;
            return this.name.equals(u.name)&&this.pswd.equals(u.pswd);
        }
        else
            return false;
    }

#### list转数组


​                

```java
             //为了将List转为数组，JDK提供了toArray
        //实现方式一：
        String [] array=(String[]) list.toArray(new String[list.size()]);
        for(String arrays: array) {
            System.out.println(arrays);
        }
        //方式二：
        String [] arr=new String [list.size()];
        list.toArray(arr);
        for(String arrs: arr) {
            System.out.println(arrs);
        }
检验List是否存在重复的元素
//校验list是否存在重复的编码且重复元素是哪个
                List<String> checkCode = new ArrayList<>();
                for (List<String> list : lists) {
                    String code = list.get(1);
                    checkCode.add(code);
                }
            
            
            HashSet<String> codeSet = new HashSet<>();
            for (String code : checkCode) {
                boolean b = codeSet.add(code);
                if (!b) {
                    throw new Exception("文件中存在重复的编码: " + code);
                }
            }
//只检验是否存在重复元素
	       HashSet<String> set = new HashSet<>(list);
	       Boolean result = set.size() == list.size() ? true : false;
```

#### Stream操作List

List取出对象中某一属性
  List<String> ids=list.stream().map(User::getId).collect(Collectors.toList());
List，将id属性逗号拼接
String str = List.stream().map(User::getId).collect(Collectors.joining(","));
List，将id属性逗号拼接后转换为Strnig类型
String str = List.stream().map(Restriction::getId).collect(Collectors.toList()).stream().map(w->w.toString()).collect(Collectors.joining(","));

List转换为另一个List
 List<Employee> employees = persons.stream()
                .filter(p -> p.getLastName().equals("l1"))
                .map(p -> new Employee(p.getName(), p.getLastName(), 1000))
                .collect(Collectors.toList());


List过滤元素
User match = users.stream().filter((user) -> user.getId() == 1).findAny().get();
List转换为Map
Map<Integer, String> result1 = list.stream().collect(
                Collectors.toMap(User::getId, Hosting::getName));

————————————————
版权声明：本文为CSDN博主「凉凉上神」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_37576193/article/details/106192968

#### add(int index, E element)

```java
// 1、将指定的元素,添加到该集合中的指定位置上。在列表的指定位置插入指定元素（可选操作）。将当前处于该位置的元素（如果有的话）和所有后续元素向右移动（在其索引中加 1）。
public void add(int index, E element)

// 2、返回集合中指定位置的元素。
public E get(int index)

// 3、移除列表中指定位置的元素,返回的是被移除的元素。
public E remove(int index)

// 4、用指定元素替换集合中指定位置的元素,返回值的更新前的元素。
public E set(int index, E element)
```

#### [Java中List转换为数组,数组转List](https://www.cnblogs.com/jingnumber/p/7814092.html)

List转换为Array可以这样处理：

ArrayList<String> list=new ArrayList<String>();

String[] strings = new String[list.size()];

list.toArray(strings);

反过来，如果要将数组转成List怎么办呢？如下：

String[] s = {"a","b","c"};
List list = java.util.Arrays.asList(s);

这个ArrayList不是java.util包下的，而是java.util.Arrays.ArrayList

它是Arrays类自己定义的一个静态内部类，这个内部类没有实现add()、remove()方法，而是直接使用它的父类AbstractList的相应方法。

而AbstractList中的add()和remove()是直接抛出java.lang.UnsupportedOperationException异常的！

```java
package cn.wyc;
 
import java.util.Arrays;
import java.util.List;
 
public class Test {
    public static void main(String[] args){
 
       //1、对象类型(String型)的数组数组使用asList()，正常
        String[] strings = {"aa", "bb", "cc"};
        List<String> stringList = Arrays.asList(strings);
        System.out.print("1、String类型数组使用asList()，正常：  ");
        for(String str : stringList){
            System.out.print(str + " ");
        }
        System.out.println();
 
 
        //2、对象类型(Integer)的数组使用asList()，正常
        Integer[] integers = new Integer[] {1, 2, 3};
        List<Integer> integerList = Arrays.asList(integers);
        System.out.print("2、对象类型的数组使用asList()，正常：  ");
        for(int i : integerList){
            System.out.print(i + " ");
        }
//        for(Object o : integerList){
//            System.out.print(o + " ");
//        }
        System.out.println();
 
 
        //3、基本数据类型的数组使用asList()，出错
        int[] ints = new int[]{1, 2, 3};
        List intList = Arrays.asList(ints);
        System.out.print("3、基本数据类型的数组使用asList()，出错(输出的是一个引用，把ints当成一个元素了)：");
        for(Object o : intList){
            System.out.print(o.toString());
        }
        System.out.println();
 
        System.out.print("   " + "这样遍历才能正确输出：");
        int[] ints1 = (int[]) intList.get(0);
        for(int i : ints1){
            System.out.print(i + " ");
        }
        System.out.println();
 
        //4、当更新数组或者List,另一个将自动获得更新
        System.out.print("4、当更新数组或者List,另一个将自动获得更新：  ");
        integerList.set(0, 5);
        for(Object o : integerList){
            System.out.print(o + " ");
        }
        for(Object o : integers){
            System.out.print (o + " ");
        }
        System.out.println();
 
        //5、add()   remove() 报错
        System.out.print("5、add()   remove() 报错：  ");
//        integerList.remove(0);
//        integerList.add(3, 4);
//        integerList.clear(); 
    }
 
}
输出：
1、String类型数组使用asList()，正常：  aa bb cc 
2、对象类型的数组使用asList()，正常：  1 2 3 
3、基本数据类型的数组使用asList()，出错(输出的是一个引用，把ints当成一个元素了)：[I@1540e19d
   这样遍历才能正确输出：1 2 3 
4、当更新数组或者List,另一个将自动获得更新：  5 2 3 5 2 3 
5、add()、remove()、clear() 报错： 
```



### 7.Java中集合及常用方法

![image-20200529151948927](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200529151948927.png)

https://www.cnblogs.com/xiaostudy/p/9502409.html

```java
1、boolean add(E e)
添加元素到Collection集合中。



 

2、boolean addAll(Collection<? extends E> c)
将指定c中的所有元素都添加到此Collection集合中。



 

3、void clear()
移除此collection集合中的所有元素



 

 

4、boolean contains(Object o)
检查Collection集合中是否包含o对象，如果包含则返回true，否则返回false。



 

 

5、boolean containsAll(Collection<?> c)
检查Collection集合中是否包含c的全部对象，全部包含则返回true，否则返回false。



 

6、boolean equals(Object o)
比较此collection集合与指定对象是否相等，是比较的是里面元素是否相等，而不是比较地址是否相等。

在Object类中，equals()方法底层就是“==”，也就是说就是比较地址是否相等，但是继承后，大多数的类都重写了该方法。

由于Collection是接口，不能直接new对象，所以只能new一个它的子类。


下面这个是Object类的equals()方法，底层就是用"=="。



下面我们来看Collection的一个实现类Vector。

Vector是继承了AbstractList


所以它的equals方法是调用了父类的方法


我们再跟进去看看。真的是重写的equals方

7、int hashCode()
返回此Collection集合的哈希码值。

8、boolean isEmpty()
检查Collection集合是否包含有元素，如果没有包含元素，则返回true，否则返回false。

此方法与contains方法的区别是，此方法是判断集合是否包含有元素，就是说，如果一个元素都没有的话就返回true，如果有一个或者以上就返回false。

contains的方法是判断集合中是否包含特定的元素，如果包含特定的元素就返回true，如果没有包含特定元素就返回false。

9、Iterator<E> iterator()
返回在此collection集合的元素上进行迭代的迭代器

注意：迭代过程中不能用集合里的添加、删除等方法修改集合，不然会报错。

如果想在迭代过程中还想操作集合，那么只能用迭代器类里面的方法。
10、boolean remove(Object o)
从collection集合中删除指定的元素，如果集合中有这个元素，并且删除成功，那么就返回true，否则返回false。

11、boolean removeAll(Collection<?> c)
从集合中删除c集合中所有的元素

12、boolean retainAll(Collection<?> c)
集合中仅保留c集合中的所有元素

13、int size()
返回集合中元素个数


14、Object[] toArray()
返回包含此collection集合中所有元素的数组


```

### 8.Collection 总接口 

--| List 特征 有序 可重复

----| ArrayList  底层维护的是一个Object类型的数组，如果使用无参构造方法创建ArrayList集合，默认的容量为10

​		用带有参数的构造方法，创建ArrayList集合，传入的initCapacity是多少，容量就是多少

​		特征: 增删慢 查找快

​		newCapacity = oldCapacity + (oldCapacity >> 1) 二进制位运算

----| LinkedList 底层维护的是一个双向链表 特征是增删快 查找慢

----| Vector 线程安全的ArrayList 和ArrayList基本相同，JDK1.0的古老产物。效率低于ArrayList

--| Set 特征 无序 不可重复

----| HashSet 底层维护是一个哈希表，存储效率极高

		一个自定义类对象放入到HashSet中，需要经历如下过程：
	
		通过当前类对象的HashCode，获取到当前类对象的哈希值，进行移位运算，计算出当前元素应该保存到哈希表中的位置。
	
		情况1: 当前位置没有元素，直接放入
	
		情况2: 当前位置已经存在其他元素。需要调用该元素的equals方法，进行比较，如果比较结果为两个元素不同，能够放入，两个元素相同，不能放入。

----| TreeSet	树形结构的Set集合

		能够放入TreeSet中的元素必须有自然顺序，或者提供【比较规则】
	
		一个自定义类对象，想要放入到TreeSet集合中，有两种方式
	
			1. 当前类【遵从】Comparable接口，实现compareTo(Object o)方法
	
			2. 实现一个自定义的比较器【遵从】Comparator接口，实现compare(Object o1, Object o2)方法

```java
Collection中的方法
//添加方法：
add(Object o) //添加指定元素
addAll(Collection c) //添加指定集合
//删除方法：
remove(Object o) //删除指定元素
removeAll(Collection c) //输出两个集合的交集
retainAll(Collection c) //保留两个集合的交集
clear() //清空集合
//查询方法：
size() //集合中的有效元素个数
toArray() //将集合中的元素转换成Object类型数组
//判断方法：
isEmpty() //判断是否为空
equals(Object o) //判断是否与指定元素相同
contains(Object o) //判断是否包含指定元素
containsAll(Collection c) //判断是否包含指定集合
    
List中的方法

//添加方法：
add(int index, Object o) //向指定位置添加元素
addAll(int index, Collection c) //向指定位置添加集合
//删除方法
remove(int index) //删除指定元素
//查询方法：
get(int index) //获取指定位置的元素
indexOf(Object o) //获取指定元素的位置
lastIndexOf(Object o) //获取指定元素最后一次出现的位置
//修改方法：
subList(int fromIndex, int toIndex) //截取子集合从fromIndex到toIndex，要头不要尾
set(int index, Object o) //修改指定位置的元素
ArrayList中特有的方法

ensureCapacity(int minCapactiy) //判断当前数组中的元素个数是否大于指定的minCapacity
trimToSize() //修改数组容量为当前数组有效元素个数
LinkedList中特有的方法

//查询方法：
getFirst() //获取集合中的第一个元素
getLast() //获取集合中的最后一个元素
//添加方法：
addFirst(Object o) //在集合的第一个位置添加指定元素
addLast(Object o) //在集合的最后一个位置添加指定元素
//删除方法：
removeFirst() //删除集合中的第一个元素
removeLast() //删除集合中的最后一个元素
Collection中的迭代器Iterator方法

Iterator iterator(); //迭代器构造方法
boolean hasNext() //判断是否有下一个元素
Object next() //获取当前元素
void remove() //删除通过next()获取的元素,在next()之后使用，不可以单独使用
List中的迭代器 ListIterator方法

ListIterator listIterator(); //迭代器构造函数
boolean hasNext() //判断是否有下一个元素
boolean hasPrevious() //判断是否有上一个元素 
Object next() //获取当前元素
Object previous() //获取上一个元素
void remove() //删除通过next()获取的元素,在next()之后使用，不可以单独使用
add(Object o) //添加指定元素
set(Object o) //修改指定元素
int nextIndex() //获取当前元素所在位置
Set中的方法
Set接口没有特有的方法，Collection中的方法在这里全部适用
```

### 9.[Java的深拷贝和浅拷贝](https://www.cnblogs.com/ysocean/p/8482979.html)

1、创建对象的5种方式

　　**①、通过 new 关键字**

　　这是最常用的一种方式，通过 new 关键字调用类的有参或无参构造方法来创建对象。比如 Object obj = new Object();

　　**②、通过 Class 类的 newInstance() 方法**

　　这种默认是调用类的无参构造方法创建对象。比如 Person p2 = (Person) Class.forName("com.ys.test.Person").newInstance();

　　**③、通过 Constructor 类的 newInstance 方法**

　　这和第二种方法类时，都是通过反射来实现。通过 java.lang.relect.Constructor 类的 newInstance() 方法指定某个构造器来创建对象。

　　Person p3 = (Person) Person.class.getConstructors()[0].newInstance();

　　实际上第二种方法利用 Class 的 newInstance() 方法创建对象，其内部调用还是 Constructor 的 newInstance() 方法。

　　**④、利用 Clone 方法**

　　Clone 是 Object 类中的一个方法，通过 对象A.clone() 方法会创建一个内容和对象 A 一模一样的对象 B，clone 克隆，顾名思义就是创建一个一模一样的对象出来。

　　Person p4 = (Person) p3.clone();

　　**⑤、反序列化**

　　序列化是把堆内存中的 Java 对象数据，通过某种方式把对象存储到磁盘文件中或者传递给其他网络节点（在网络上传输）。而反序列化则是把磁盘文件中的对象数据或者把网络节点上的对象数据，恢复成Java对象模型的过程。

　　具体如何实现可以参考我 [这篇博文](http://www.cnblogs.com/ysocean/p/6870069.html)。



3、Clone 方法



　　本篇博客我们讲解的是 Java 的深拷贝和浅拷贝，其实现方式正是通过调用 Object 类的 clone() 方法来完成。在 Object.class 类中，源码为：

```
protected native Object clone() throws CloneNotSupportedException;
```

　　这是一个用 native 关键字修饰的方法，关于native关键字有一篇[博客](https://www.cnblogs.com/ysocean/p/8476933.html)专门有介绍，不理解也没关系，只需要知道用 native 修饰的方法就是告诉操作系统，这个方法我不实现了，让操作系统去实现。具体怎么实现我们不需要了解，只需要知道 clone方法的作用就是复制对象，产生一个新的对象。那么这个新的对象和原对象是什么关系呢？

4、基本类型和引用类型

　　这里再给大家普及一个概念，在 Java 中基本类型和引用类型的区别。

　　在 Java 中数据类型可以分为两大类：基本类型和引用类型。

　　基本类型也称为值类型，分别是字符类型 char，布尔类型 boolean以及数值类型 byte、short、int、long、float、double。

　　引用类型则包括类、接口、数组、枚举等。

　　Java 将内存空间分为堆和栈。**基本类型直接在栈中存储数值**，**而引用类型是将引用放在栈中，实际存储的值是放在堆中，通过栈中的引用指向堆中存放的数据。**

![image-20200529165910169](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200529165910169.png)

上图定义的 a 和 b 都是基本类型，其值是直接存放在栈中的；而 c 和 d 是 String 声明的，这是一个引用类型，引用地址是存放在 栈中，然后指向堆的内存空间。

　　下面 d = c；这条语句表示将 c 的引用赋值给 d，那么 c 和 d 将指向同一块堆内存空间。

```java
package com.ys.test;

public class Person implements Cloneable{
    public String pname;
    public int page;
    public Address address;
    public Person() {}
    
    public Person(String pname,int page){
        this.pname = pname;
        this.page = page;
        this.address = new Address();
    }
    
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
    
    public void setAddress(String provices,String city ){
        address.setAddress(provices, city);
    }
    public void display(String name){
        System.out.println(name+":"+"pname=" + pname + ", page=" + page +","+ address);
    }

  
    
}
```

```java
package com.ys.test;

public class Address {
    private String provices;
    private String city;
    public void setAddress(String provices,String city){
        this.provices = provices;
        this.city = city;
    }
    @Override
    public String toString() {
        return "Address [provices=" + provices + ", city=" + city + "]";
    }
    
}
```



```java
@Test
public void testShallowClone() throws Exception{
    Person p1 = new Person("zhangsan",21);
    p1.setAddress("湖北省", "武汉市");
    Person p2 = (Person) p1.clone();
    System.out.println("p1:"+p1);
    System.out.println("p1.getPname:"+p1.getPname().hashCode());
    
    System.out.println("p2:"+p2);
    System.out.println("p2.getPname:"+p2.getPname().hashCode());
    
    p1.display("p1");
    p2.display("p2");
    p2.setAddress("湖北省", "荆州市");
    System.out.println("将复制之后的对象地址修改：");
    p1.display("p1");
    p2.display("p2");
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```java
@Test
public void testShallowClone() throws Exception{
    Person p1 = new Person("zhangsan",21);
    p1.setAddress("湖北省", "武汉市");
    Person p2 = (Person) p1.clone();
    System.out.println("p1:"+p1);
    System.out.println("p1.getPname:"+p1.getPname().hashCode());
    
    System.out.println("p2:"+p2);
    System.out.println("p2.getPname:"+p2.getPname().hashCode());
    
    p1.display("p1");
    p2.display("p2");
    p2.setAddress("湖北省", "荆州市");
    System.out.println("将复制之后的对象地址修改：");
    p1.display("p1");
    p2.display("p2");
}
```

![image-20200529170402839](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200529170402839.png)

　这是一个我们要进行赋值的原始类 Person。下面我们产生一个 Person 对象，并调用其 clone 方法复制一个新的对象。

　　**注意：调用对象的 clone 方法，必须要让类实现 Cloneable 接口，并且覆写 clone 方法。**

　　首先看原始类 Person 实现 Cloneable 接口，并且覆写 clone 方法,它还有三个属性，一个引用类型 String定义的 pname，一个基本类型 int定义的 page，还有一个引用类型 Address ，这是一个自定义类，这个类也包含两个属性 pprovices 和 city 。

　　接着看测试内容，首先我们创建一个Person 类的对象 p1，其pname 为zhangsan,page为21，地址类 Address 两个属性为 湖北省和武汉市。接着我们调用 clone() 方法复制另一个对象 p2，接着打印这两个对象的内容。

　　从第 1 行和第 3 行打印结果:

　　p1:com.ys.test.Person@349319f9

　　p2:com.ys.test.Person@258e4566

　　可以看出这是两个不同的对象。

　　从第 5 行和第 6 行打印的对象内容看，原对象 p1 和克隆出来的对象 p2 内容完全相同。

　　代码中我们只是更改了克隆对象 p2 的属性 Address 为湖北省荆州市（原对象 p1 是湖北省武汉市） ，但是从第 7 行和第 8 行打印结果来看，原对象 p1 和克隆对象 p2 的 Address 属性都被修改了。

　　也就是说对象 Person 的属性 Address，经过 clone 之后，其实只是复制了其引用，他们指向的还是同一块堆内存空间，当修改其中一个对象的属性 Address，另一个也会跟着变化。

![image-20200529171814243](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200529171814243.png)

　**浅拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，如果字段是值类型的，那么对该字段执行复制；如果该字段是引用类型的话，则复制引用但不复制引用的对象。因此，原始对象及其副本引用同一个对象。**

#### 6、深拷贝

　　弄清楚了浅拷贝，那么深拷贝就很容易理解了。

　　**深拷贝：创建一个新对象，然后将当前对象的非静态字段复制到该新对象，无论该字段是值类型的还是引用类型，都复制独立的一份。当你修改其中一个对象的任何内容时，都不会影响另一个对象的内容。**

![image-20200529180936109](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200529180936109.png)

　那么该如何实现深拷贝呢？**Object 类提供的 clone 是只能实现 浅拷贝的。**

　深拷贝的原理我们知道了，就是要让原始对象和克隆之后的对象所具有的引用类型属性不是指向同一块堆内存，这里有三种实现思路。



#### 　　①、让每个引用类型属性内部都重写clone() 方法

　　既然引用类型不能实现深拷贝，那么我们将每个引用类型都拆分为基本类型，分别进行浅拷贝。比如上面的例子，Person 类有一个引用类型 Address(其实String 也是引用类型，但是String类型有点特殊，后面会详细讲解)，我们在 Address 类内部也重写 clone 方法。如下：

　　Address.class:

```
package com.ys.test;

public class Address implements Cloneable{
    private String provices;
    private String city;
    public void setAddress(String provices,String city){
        this.provices = provices;
        this.city = city;
    }
    @Override
    public String toString() {
        return "Address [provices=" + provices + ", city=" + city + "]";
    }
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

}
```

@Override
    protected Object clone() throws CloneNotSupportedException {
        Person p = (Person) super.clone();
        p.address = (Address) address.clone();
        return p;
    }

　测试还是和上面一样，我们会发现更改了p2对象的Address属性，p1 对象的 Address 属性并没有变化。

　　但是这种做法有个弊端，这里我们Person 类只有一个 Address 引用类型，而 Address 类没有，所以我们只用重写 Address 类的clone 方法，但是如果 Address 类也存在一个引用类型，那么我们也要重写其clone 方法，这样下去，有多少个引用类型，我们就要重写多少次，如果存在很多引用类型，那么代码量显然会很大，所以这种方法不太合适。

#### 　②、利用序列化

　　序列化是将对象写到流中便于传输，而反序列化则是把对象从流中读取出来。这里写到流中的对象则是原始对象的一个拷贝，因为原始对象还存在 JVM 中，所以我们可以利用对象的序列化产生克隆对象，然后通过反序列化获取这个对象。

　　注意每个需要序列化的类都要实现 Serializable 接口，如果有某个属性不需要序列化，可以将其声明为 transient，即将其排除在克隆属性之外。

这里把 `Student studentB = (Student) studentA.clone()` 换成了 `Student studentB = studentA`。
 输出的结果：



```css
studentA:[Student: 460141958,subject:[Subject: 1163157884,name:lishi],name:Lily,age:18]
studentB:[Student: 460141958,subject:[Subject: 1163157884,name:lishi],name:Lily,age:18]
```

可见，对象拷贝后没有生成新的对象，二者的对象地址是一样的；而浅拷贝的对象地址是不一样的。

深拷贝，在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。

#### 2. 深拷贝特点

(1) 对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。
 (2) 对于引用类型，比如数组或者类对象，深拷贝会新建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。
 (3) 对于有多层对象的，每个对象都需要实现 `Cloneable` 并重写 `clone()` 方法，进而实现了对象的串行层层拷贝。
 (4) 深拷贝相比于浅拷贝速度较慢并且花销较大。



#### 3. 深拷贝的实现

对于 `Student` 的引用类型的成员变量 `Subject` ，需要实现 `Cloneable` 并重写 `clone()` 方法。



```java
public class Subject implements Cloneable {

    private String name;

    public Subject(String name) {
        this.name = name;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        //Subject 如果也有引用类型的成员属性，也应该和 Student 类一样实现
        return super.clone();
    }

    @Override
    public String toString() {
        return "[Subject: " + this.hashCode() + ",name:" + name + "]";
    }
}
```

在 `Student` 的 `clone()` 方法中，需要拿到拷贝自己后产生的新的对象，然后对新的对象的引用类型再调用拷贝操作，实现对引用类型成员变量的深拷贝。



```java
public class Student implements Cloneable {

    //引用类型
    private Subject subject;
    //基础数据类型
    private String name;
    private int age;

    public Subject getSubject() {
        return subject;
    }

    public void setSubject(Subject subject) {
        this.subject = subject;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    /**
     *  重写clone()方法
     * @return
     */
    @Override
    public Object clone() {
        //深拷贝
        try {
            // 直接调用父类的clone()方法
            Student student = (Student) super.clone();
            student.subject = (Subject) subject.clone();
            return student;
        } catch (CloneNotSupportedException e) {
            return null;
        }
    }

    @Override
    public String toString() {
        return "[Student: " + this.hashCode() + ",subject:" + subject + ",name:" + name + ",age:" + age + "]";
    }
}
```

一样的使用方式



```csharp
public class ShallowCopy {
    public static void main(String[] args) {
        Subject subject = new Subject("yuwen");
        Student studentA = new Student();
        studentA.setSubject(subject);
        studentA.setName("Lynn");
        studentA.setAge(20);
        Student studentB = (Student) studentA.clone();
        studentB.setName("Lily");
        studentB.setAge(18);
        Subject subjectB = studentB.getSubject();
        subjectB.setName("lishi");
        System.out.println("studentA:" + studentA.toString());
        System.out.println("studentB:" + studentB.toString());
    }
}
```

输出结果：



```css
studentA:[Student: 460141958,subject:[Subject: 1163157884,name:yuwen],name:Lynn,age:20]
studentB:[Student: 1956725890,subject:[Subject: 356573597,name:lishi],name:Lily,age:18]
```

由输出结果可见，深拷贝后，不管是基础数据类型还是引用类型的成员变量，修改其值都不会相互造成影响。





作者：安静的蓝孩子
链接：https://www.jianshu.com/p/94dbef2de298
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 10，map常用操作

1. Java Map 重要观点

- Java Map接口是Java Collections Framework的成员。但是它不是Collection
- 将键映射到值的对象。一个映射不能包含重复的键；每个键最多只能映射到一个值。（不同的键对应的值可以相等）
- `Map` 接口提供三种*collection 视图*，允许以键集、值集或键-值映射关系集的形式查看某个映射的内容。
- Map中某些映射实现可明确保证其自然顺序和定制顺序，如 `TreeMap` 类；另一些映射实现则不保证任何顺序，如 `HashMap` 类；还有些类保证添加顺序。
- 某些映射实现对可能包含的键和值有所限制。例如，某些实现禁止 null 键和值，另一些则对其键的类型有限制。

一些最常用的Map实现类是HashMap，LinkedHashMap，TreeMap，SortedMap，HashTable，WeakedHashMap。

Set的实现类都是基于Map来实现的(如，HashSet是通过HashMap实现的，TreeSet是通过TreeMap实现的，LinkedHashSet是通过LinkedHashMap来实现的)。

![image-20200531133434623](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200531133434623.png)

```java
a:添加功能
V put(K key,V value):添加元素。这个其实还有另一个功能?替换
如果键是第一次存储，就直接存储元素，返回null
如果键不是第一次存在，就用值把以前的值替换掉，返回以前的值
b:删除功能
void clear():移除所有的键值对元素
V remove(Object key)：根据键删除键值对元素，并把值返回
c:判断功能
boolean containsKey(Object key)：判断集合是否包含指定的键
boolean containsValue(Object value):判断集合是否包含指定的值
boolean isEmpty()：判断集合是否为空
d:获取功能
Set<Map.Entry<K,V>> entrySet(): 返回一个键值对的Set集合
V get(Object key):根据键获取值
Set keySet():获取集合中所有键的集合
Collection values():获取集合中所有值的集合
e:长度功能
int size()：返回集合中的键值对的对数
————————————————
版权声明：本文为CSDN博主「taraex」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/taraex/article/details/90243965


void                   clear() //从此映射中移除所有映射关系（可选操作）。
 boolean                containsKey(Object key) //如果此映射包含指定键的映射关系，则返回 true。
 boolean                containsValue(Object value) //如果此映射将一个或多个键映射到指定值，则返回 true。
 Set<Map.Entry<K,V>>    entrySet() //返回此映射中包含的映射关系的 Set 视图。
 boolean                equals(Object o) //比较指定的对象与此映射是否相等。
 V                      get(Object key) //返回指定键所映射的值；如果此映射不包含该键的映射关系，则返回 null。
 int                    hashCode() //返回此映射的哈希码值。
 boolean                isEmpty() //如果此映射未包含键-值映射关系，则返回 true。
 Set<K>                 keySet() //返回此映射中包含的键的 Set 视图。
 V                      put(K key, V value) //将指定的值与此映射中的指定键关联（可选操作）。
 void                   putAll(Map<? extends K,? extends V> m) //从指定映射中将所有映射关系复制到此映射中（可选操作）。
 V                      remove(Object key) //如果存在一个键的映射关系，则将其从此映射中移除（可选操作）。
 int                    size() //返回此映射中的键-值映射关系数。
 Collection<V>          values() //返回此映射中包含的值的 Collection 视图。
```

```

import java.util.HashMap;
import java.util.Map;

/**
 *Map常用操作方法
 */
public class MapDemo {

    public static void main(String[] args) {
        // Map实例化
        Map<String, Integer> maps = new HashMap<>();
        
        // 添加元素
        maps.put("A", 10);
        maps.put("B", 20);
        maps.put("C", 30);
        maps.put("D", 40);
        maps.put("E", 50);
        maps.put("F", 60);

        // 修改元素
        maps.replace("F", 65);
        
        // 删除元素
        maps.remove("E");
        
        // 遍历Map-原始方法
        for (Map.Entry<String, Integer> entry : maps.entrySet()) {
            System.out.println("key:" + entry.getKey() + ";value:" + entry.getValue());
        }
        
        // 遍历map-forEach方法（Java8新特性）
        maps.forEach((k,v)->
            System.out.println("key : " + k + "; value : " + v)
            );
        
        // 查询元素
        int f = maps.get("F");
        System.out.println("F的值为:" +  f);

    }
}
key:A;value:10
key:B;value:20
key:C;value:30
key:D;value:40
key:F;value:65
key : A; value : 10
key : B; value : 20
key : C; value : 30
key : D; value : 40
key : F; value : 65
F的值为:65
```



![image-20200531133713704](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200531133713704.png)

https://www.cnblogs.com/haimishasha/p/10790508.html

#### 2.map添加元素保持添加时顺序不变

要用LinkedHashMap

大多数情况下，只要不涉及线程安全问题，Map基本都可以使用HashMap，不过HashMap有一个问题，就是**迭代HashMap的顺序并不是HashMap放置的顺序**，也就是无序。HashMap的这一缺点往往会带来困扰，因为有些场景，我们期待一个有序的Map。这个时候，LinkedHashMap就闪亮登场了，它虽然增加了时间和空间上的开销，但是**通过维护一个运行于所有条目的双向链表，LinkedHashMap保证了元素迭代的顺序**。**该迭代顺序可以是插入顺序或者是访问顺序。**https://www.cnblogs.com/xiaoxi/p/6170590.html

```java

LinkedHashMap<String, Integer> map = new LinkedHashMap<>();
map.put("星期一", 40);
map.put("星期二", 43);
map.put("星期三", 35);
map.put("星期四", 55);
map.put("星期五", 45);
map.put("星期六", 35);
map.put("星期日", 30);
for (Map.Entry<String, Integer> entry : map.entrySet()){
    System.out.println("key: " + entry.getKey() + ", value: " + entry.getValue());
}
```

这个时候，结果正如我们所预期

```java
key: 星期一, value: 40
key: 星期二, value: 43
key: 星期三, value: 35
key: 星期四, value: 55
key: 星期五, value: 45
key: 星期六, value: 35
key: 星期日, value: 30
```





LinkedHashMap使用的也较为频繁，它基于HashMap，用于HashMap的特点，又增加了双链表的结构，从而保证了顺序性，本文主要从源码的角度分析其如何保证顺序性，accessOrder的解释，以及常用方法的阐释，若有不对之处，请批评指正，望共同进步，谢谢！https://blog.csdn.net/weixin_30315435/article/details/96749959?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase



   

这样line="1,2,3"
————————————————
版权声明：本文为CSDN博主「万里飞鹏」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zhangtongpeng/article/details/80750689

#### 3.HashMap存入和取出数据顺序不一致

Hashmap 是一个最常用的Map,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的，这样会导致按照顺序读取的时候和存入的顺序是不一样的   。 HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。

   LinkedHashMap 是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比 LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。




取出来的顺序不是上面的先后放入顺序，如果需要按照顺序取数据，有三种方法。

第一：

        通过有序的  Key  获取相应的数据。

第二：

        用HashMap的子类 LinkedHashMap 

可以按照我们put的顺序进行存储map数据

Map<String, String> map = new LinkedHashMap<>();

第三：

      用  TreeMap

#### 4.map.getOrDefault

Map.getOrDefault(Object key, V defaultValue)方法的作用是：
  当Map集合中有这个key时，就返回这个key值对应的value；
  如果没有就返回默认值defaultValue。

代码示例如下：

```java
	HashMap<String, String> map = new HashMap<>();
	map.put("name", "cookie");
	map.put("age", "18");
	map.put("sex", "女");
	String name = map.getOrDefault("name", "random");
	System.out.println(name);// cookie，map中存在name,获得name对应的value
	int score = map.getOrDefault("score", 80);
	System.out.println(score);// 80，map中不存在score,使用默认值80
```



#### 5.Dictionary

**Java.util.Dictionary**是一个抽象类，表示**键值**关系，并且与[map](https://www.breakyizhan.com/java/5326.html)类似。给定一个键，您可以存储值，并在需要时可以使用其键检索值。因此，它是键值对的列表。但是已经过时了

```
public abstract class Dictionary extends Object
```

**构造函数：**
**Dictionary（）**唯一的构造函数。
**util.Dictionary类的方法：**

1. put（K key，V value）：

   java.util.Dictionary.put（K key，V value）

   将键值对添加到字典

   语法：

   

   ```
   public abstract V put(K key, V value)
   Parameters : 
   -> key
   -> value
   Return : 
   key-value pair mapped in the dictionary
   ```

2. elements（）：

   java.util.Dictionary.elements（）

   返回字典

   语法中的

   值表示

   语法：

   

   ```
   public abstract Enumeration elements()
   Parameters : 
   --------
   Return : 
   value enumeration in dictionary
   ```

3. get（Object key）：

   java.util.Dictionary.get（Object key）

   返回与字典中的有争议键映射的值

   语法：

   

   ```
   public abstract V get(Object key)
   Parameters : 
   key - key whose mapped value we want
   Return : 
   value mapped with the argumented key
   ```

4. isEmpty（）：

   java.util.Dictionary.isEmpty（）

   检查字典是否为空。

   语法：

   

   ```
   public abstract boolean isEmpty()
   Parameters : 
   ------
   Return : 
   true, if there is no key-value relation in the dictionary; else false
   ```

5. keys（）：

   java.util.Dictionary.keys（）

   返回字典

   语法中的

   键表示

   语法：

   

   ```
   public abstract Enumeration keys()
   Parameters : 
   --------
   Return : 
   key enumeration in dictionary
   ```

6. remove（Object key）：

   java.util.Dictionary.remove（Object key）

   删除使用争论密钥映射的键值对。

   语法：

   

   ```
   public abstract V remove(Object key)
   Parameters : 
   key : key to be removed
   Return : 
   value mapped with the key
   ```

7. size（）：

   java.util.Dictionary.size（）

   返回no。字典

   语法

   中的键值对

   语法：

   

   ```
   public abstract int size()
   Parameters : 
   -------
   Return : 
   returns the no. of key-value pairs in the Dictionary
   ```

| **序号** | **方法描述**                                                 |
| -------- | ------------------------------------------------------------ |
| 1        | **Enumeration elements( )** 返回此 dictionary 中值的枚举。   |
| 2        | **Object get(Object key)** 返回此 dictionary 中该键所映射到的值。 |
| 3        | **boolean isEmpty( )** 测试此 dictionary 是否不存在从键到值的映射。 |
| 4        | **Enumeration keys( )** 返回此 dictionary 中的键的枚举。     |
| 5        | **Object put(Object key, Object value)** 将指定 key 映射到此 dictionary 中指定 value。 |
| 6        | **Object remove(Object key)** 从此 dictionary 中移除 key （及其相应的 value）。 |
| 7        | **int size( )** 返回此 dictionary 中条目（不同键）的数量。   |






### 11.[关于Java中for循环的i++和++i区别](https://www.cnblogs.com/zhanqing/p/9339723.html)

**在循环体中，i++和++i的作用是一样的**。

我们应该都知道i++和++i的区别是：

++i是先执行 i = i +1 再使用 i 的值，而 i++ 是先使用 i 的值再执行 i = i + 1；

for循环的执行顺序如下：

for（a;b;c）

{

　　d;

}

进入循环执行a；//只是进入的时候执行

执行b; //条件为真才执行d，不然跳出for了

执行d；

执行c；

再回到第2步开始执行

来看下面的实例：

for（int i = 0; i < 10;i++）{

　　System.out.println(i);

}

相当于：

for(int i = 0; i < 10;){

　　System.out.println(i);　

　　i++；　

}

2.for（int i = 0; i<10; ++i）{

　　System.out.println(i);

}

相当于：for（int i =0; i < 10;）

{

　　System.out.println(i);

　　++i;

}

**在循环体中，i++和++i的作用是一样的。**

打印出来的信息是：

0

1

2

3

4

5

6

7

8

9

打印信息证明了i++和++i的作用是一样的

但是肯定有一定区别的，所以把循环耗时也打印出来了。

循环次数 = 100的时候：

i++的时间是：5

++i的时间是：3

循环次数 = 1000的时候：

i++的时间是：25

++i的时间是：21

循环次数 = 10000的时候：

i++的时间是：179

++i的时间是：130

没错，就是运行时间的差别。在Java中i++语句是需要一个临时变量取存储返回自增前的值，而++i不需要。这样就导致使用i++时系统需要先申请一段内存空间，然后将值塞如进去，最后不用了才去释放。多了这么一系列操作时间。

大家可以仔细咀嚼一下我们开头的这句话：++i是先执行 i = i +1 再使用 i 的值，而 i++ 是先使用 i 的值再执行 i = i + 1；

一个是先执行然后在使用 i 的值，一个是先使用 i 的值再执行，运行时间的快慢可想而知。这是博主私人经验，有错的地方可留意探讨谢谢。

### 12.int 类型除法

1.保留两位小数

    public void txfloat() {
        // TODO 自动生成的方法存根
        int a=9;
        int b=7;
        DecimalFormat df=new DecimalFormat("0.00");
    
    System.out.println(df.format((float)a/b));
    System.out.println(df.format(a/(float)b));
    System.out.println(df.format((float)a/(float)b));
    System.out.println(df.format((float)(a/b)));
    }




![image-20200704225454374](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200704225454374.png)

方法比较简单粗暴，用 ‘DecimalFormat ’ 看看代码就懂了

DecimalFormat 是 NumberFormat 的一个具体子类，用于格式化十进制数字。
构造方法摘要
DecimalFormat() 
          使用默认模式和默认语言环境的符号创建一个 DecimalFormat。
DecimalFormat(String pattern) 
          使用给定的模式和默认语言环境的符号创建一个 DecimalFormat。
DecimalFormat(String pattern, DecimalFormatSymbols symbols) 
          使用给定的模式和符号创建一个 DecimalFormat。

https://blog.csdn.net/my13413527259/article/details/61204191



2.Java里对于两个整型数据直接做除法运算，最终只能得到一个整数结果，小数部分被舍弃。



3.int a = 5, b = 2;

//保留小数,结果为2.5
System.out.println((double) a / b);

//整除运算,结果为2
System.out.println(a / b);

//取余运算,结果为1
System.out.println(a % b);

#### 4.Java向上取整与向下取整

向上取整

Math.ceil()
向下取整

Math.floor()
这个记起来比较好记，ceil是天花板的意思，floor是地板的意思，通过这个我们就能很容易的区别哪个是向上取整，哪个是向下取整

示例如下：

```
public class Test {
    public static void main(String[] args) {
        double a = 3.6;
        double b = 3.4;
        System.out.println("a向上取整="+Math.ceil(a));
        System.out.println("a向下取整="+Math.floor(a));
        System.out.println("b向上取整="+Math.ceil(b));
        System.out.println("b向下取整="+Math.floor(b));
    }
}
```


结果如下：

![image-20200704225753564](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200704225753564.png)

### 13.[Java中String类的常用方法](https://www.cnblogs.com/libinhong/p/10989804.html)

#### String的最大长度

首先给出结论：
String在内存中的最大长度理论上是int型变量的最大值，Integer.MAX_VALUE,
String的字面常量的最大长度为CONSTANT_Utf8_info表决定，一般为65535.
1、String的内部实现
通过一个字符数组来维护字符序列，其声名如下：

private final char value[];
1
所以，String的最大长度取决于字符数组的最大长度，因为字符数组长度只能是byte,char,short,int而不能是long型，所以这也说明最大长度，另一方面，我们知道String类有一个方法，str.length() 它的返回值是int型变量，声明如下：

public int length()
1
所以这也说明了最大长度的理论值，但在实际中，要比理论值小，

public class mainClass {

    public static void main(String[] args) {
        // TODO Auto-generated method stub
        char[] value=new char[Integer.MAX_VALUE];   
        System.out.println("");
    }}



这个错误是内存溢出错误，所以系统无法分配这么大的内存空间。
现在的问题是，计算机系统可以分配多大的内存呢？
这其实和很多硬件相关的因素有关，下面通过程序来测试最大的内存空间。



#### Arrays.tostring方法

#### 1.构造方法

public String():空构造

public String(byte[] bytes):把字节数组转成字符串

public String(byte[] bytes,int index,int length):把字节数组的一部分转成字符串

public String(char[] value):把字符数组转成字符串

public String(char[] value,int index,int count):把字符数组的一部分转成字符串

public String(String original):把字符串常量值转成字符串



**构造方法：**

**1）无参构造方法**

String()

```
String s1 = new String();
System.out.println(s1);// 啥也不输出
```

 

**2）参数为字符串类型**

String(String original)

```
String s6 = new String("KobeBryant");
System.out.println(s6);
```

 

**3）参数为 byte 数组类型**

String(byte[] bytes)
String(byte[] bytes, Charset charset)        

byte 是网络传输或存储的序列化形式，所以在很多传输和存储的过程中需要将 byte[] 数组和 String 进行相互转化。

有关 IO 流的代码中会出现这个构造方法，字符编码导致的乱码问题也是比较多的，这里需要注意：一旦看到 byte 数组，一定要想到编码问题。

经常会用到 getBytes【字符串转字符数组】(Charset charset) 方法：

```
byte[] arr1 = { 97, 98, 99, 100 };
String s2 = new String(arr1);
System.out.println(s2);//abcd
```

 

**4）参数为 char 数组类型**

```
char[] arr3 = { 'a', 'b', 'c', 'd', 'e' }; // 将字符数组转换成字符串
String s4 = new String(arr3);
System.out.println(s4);//abcde
```

 

**5）参数为 StringBuilder 或者 StringBuffer 类型**

String(StringBuffer buffer)
            （Allocates a new string that contains the sequence of characters currently contained in the string buffer argument.）
String(StringBuilder builder)
            （Allocates a new string that contains the sequence of characters currently contained in the string builder argument.）

```
StringBuilder sbb = new StringBuilder();
sbb.append("hello ").append("world");
String str1 = sbb.toString(); //hello world  
```



**判断功能的方法**

#### equals 

**public boolean equals (Object anObject)** **：**将此字符串与指定对象进行比较。
**public boolean equalsIgnoreCase (String anotherString)** **：**将此字符串与指定对象进行比较，忽略大小写。



```
public class String_Demo01 {
  public static void main(String[] args) {
    // 创建字符串对象
    String s1 = "hello";
    String s2 = "hello";
    String s3 = "HELLO";

    // boolean equals(Object obj):比较字符串的内容是否相同
    System.out.println(s1.equals(s2)); // true
    System.out.println(s1.equals(s3)); // false
    System.out.println("-----------");

    //boolean equalsIgnoreCase(String str):比较字符串的内容是否相同,忽略大小写
    System.out.println(s1.equalsIgnoreCase(s2)); // true
    System.out.println(s1.equalsIgnoreCase(s3)); // true
    System.out.println("-----------");
  }
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

Object 是” 对象”的意思，也是一种引用类型。作为参数类型，表示任意对象都可以传递到方法中

**注意：**

**2****个字符串使用==比较运算符，比较的是地址值，如果使用的是equals方法，比较的是字符串内容是否相等**

 

**获取功能的方法**

####  length  concat  charAt indexOf 

**public int length ()** ：返回此字符串的长度。

```
 String s = "helloworld";
 //int length():获取字符串的长度，其实也就是字符个数
 System.out.println(s.length());//10
```

**public String concat (String str)** **：**将指定的字符串连接到该字符串的末尾。

```
String s = "helloworld";
//String concat:将指定的字符串连接到该字符串的末尾
String s2 = s.concat("**hello itheima");
System.out.println(s2);//helloworld**hello itheima
```

**public char charAt (int index) ：**返回指定索引处的 char值。

```
String s = "helloworld";
//char charAt：获取指定索引处的字符
System.out.println(s.charAt(0));//h
System.out.println(s.charAt(1));//e
```

**public int indexOf (String str) ：**返回指定子字符串第一次出现在该字符串内的索引。

```
String s = "helloworld";
// 获取子字符串第一次出现在该字符串内的索引，没有返回-1
System.out.println(s.indexOf("l"));//2
System.out.println(s.indexOf("wow"));//-1
System.out.println(s.indexOf("ak"));//-1
```

**public String substring (int beginIndex)** **：**返回一个子字符串，从**beginIndex**开始截取字符串到字符串结尾。

```
String s = "helloworld";
// 从beginIndex开始截取字符串到字符串结尾
System.out.println(s.substring(0));//helloworld
System.out.println(s.substring(5));//world
```

**public String substring (int beginIndex, int endIndex)** **：**返回一个子字符串，从**beginIndex**到**endIndex**截取字符串。含**beginIndex**，不含**endIndex**。

```
String s = "helloworld";
 // 从beginIndex到endIndex截取字符串。含beginIndex，不含endIndex。
System.out.println(s.substring(0, s.length()));//helloworld
System.out.println(s.substring(3,8));//lowor
```

 

 

**转换功能的方法**

 

**public char[] toCharArray ()** **：**将此字符串转换为新的字符数组。

```
String s = "HelloWorld!";
//char[] toCharArray:把字符串转换为字符数组
char[] chs = s.toCharArray();
```

**public byte[] getBytes () ：**使用平台的默认字符集将该 String编码转换为新的字节数组。

```
String s = "HelloWorld!";
byte[] bytes = s.getBytes();
```

**public String replace (CharSequence target, CharSequence replacement)** **：**将与target匹配的字符串使用replacement字符串替换。

```
String str = "itcast itheima";
String replace = str.replace("it","IT");
```

 

 

 

**分割功能的方法**

 

有些特殊符号需要用 反斜杠 \ 转义，在Java要用两个反斜杠 \\

**`public String[] split(String regex)`** **：**将此字符串按照给定的regex（规则）拆分为字符串数组。

```
//String分割
String s = "aa|bb|cc";
String[] strArray = s.split("\\|"); for(int i = 0; i < strArray.length; i++){
   System.out.print(strArray[i]);
}
```

 

 

**一些常用方法**

转自：

https://www.cnblogs.com/nanshouyong326/archive/2009/06/30/1513920.html

 

####  contains

**boolean contains(CharSequence s):** 判断字符串中是否包含指定字符。

```
String s = "djlfdjksdlka";
boolean str = s.contains("g");
System.out.println("str" + str);
```



Java中的字符串也是一连串的字符。但是与许多其他的计算机语言将字符串作为字符数组处理不同，Java将字符串作为String类型对象来处理。将字符串作为内置的对象处理允许Java提供十分丰富的功能特性以方便处理字符串。下面是一些使用频率比较高的函数及其相关说明。

substring()
它有两种形式，第一种是：String substring(int startIndex)
第二种是：String substring(int startIndex,int endIndex)

concat() 连接两个字符串

replace() 替换
它有两种形式，第一种形式用一个字符在调用字符串中所有出现某个字符的地方进行替换，形式如下：
String replace(char original,char replacement)
例如：String s=”Hello”.replace(’l',’w');
第二种形式是用一个字符序列替换另一个字符序列，形式如下：
String replace(CharSequence original,CharSequence replacement)

#### trim()

 去掉起始和结尾的空格

#### valueOf() 转换为字符串

**1. 由 基本数据型态转换成 String** 
String 类别中已经提供了将基本数据型态转换成 String 的 static 方法 
也就是 String.valueOf() 这个参数多载的方法 
有下列几种 
String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串 
String.valueOf(char c) : 将 char 变量 c 转换成字符串 
String.valueOf(char[] data) : 将 char 数组 data 转换成字符串 
String.valueOf(char[] data, int offset, int count) : 
将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串 
String.valueOf(double d) : 将 double 变量 d 转换成字符串 
String.valueOf(float f) : 将 float 变量 f 转换成字符串 
String.valueOf(int i) : 将 int 变量 i 转换成字符串 
String.valueOf(long l) : 将 long 变量 l 转换成字符串 
String.valueOf(Object obj) : 将 obj 对象转换成 字符串, 等于 obj.toString() 
用法如: 
int i = 10; 
String str = String.valueOf(i); 
这时候 str 就会是 "10" 
**2. 由 String 转换成 数字的基本数据型态** 
要将 String 转换成基本数据型态转 
大多需要使用基本数据型态的包装类别 
比如说 String 转换成 byte 
可以使用 Byte.parseByte(String s) 
这一类的方法如果无法将 s 分析 则会丢出 NumberFormatException 
byte : 
Byte.parseByte(String s) : 将 s 转换成 byte 
Byte.parseByte(String s, int radix) : 以 radix 为基底 将 s 转换为 byte 
比如说 Byte.parseByte("11", 16) 会得到 17 
double : 
Double.parseDouble(String s) : 将 s 转换成 double 
float : 
Double.parseFloat(String s) : 将 s 转换成 float 
int : 
Integer.parseInt(String s) : 将 s 转换成 int 
long : 
Long.parseLong(String



toLowerCase() 转换为小写

toUpperCase() 转换为大写

#### length()

 取得字符串的长度
例：
char chars[]={’a',’b’.’c'};
String s=new String(chars);
int len=s.length();

#### charAt() 

截取一个字符
例：
char ch;
ch=”abc”.charAt(1);
返回值为’b’

#### getChars() 截取多个字符

void getChars(int sourceStart,int sourceEnd,char target[],int targetStart)
sourceStart 指定了子串开始字符的下标
sourceEnd 指定了子串结束后的下一个字符的下标。因此，子串包含从sourceStart到sourceEnd-1的字符。
target 指定接收字符的数组
targetStart target中开始复制子串的下标值
例：
String s=”this is a demo of the getChars method.”;
char buf[]=new char[20];
s.getChars(10,14,buf,0);

getBytes()
替代getChars()的一种方法是将字符存储在字节数组中，该方法即getBytes()
例：
String s = “Hello!你好！”;
byte[] bytes = s.getBytes();

#### toCharArray()

例：
String s = “Hello!你好！”;
char[] ss = s.toCharArray();

equals()和equalsIgnoreCase() 比较两个字符串

regionMatches() 用于比较一个字符串中特定区域与另一特定区域，它有一个重载的形式允许在比较中忽略大小写。
boolean regionMatches(int startIndex,String str2,int
str2StartIndex,int numChars)
boolean regionMatches(boolean ignoreCase,int startIndex,String
str2,int str2StartIndex,int numChars)

#### startsWith()和endsWith()

startsWith()方法决定是否以特定字符串开始，endWith()方法决定是否以特定字符串结束

#### equals()和==

equals()方法比较字符串对象中的字符，==运算符比较两个对象是否引用同一实例。
例：String s1=”Hello”;
String s2=new String(s1);
s1.eauals(s2); //true
s1==s2;//false

compareTo()和compareToIgnoreCase() 比较字符串

#### indexOf()和lastIndexOf()

indexOf() 查找字符或者子串第一次出现的地方。
lastIndexOf() 查找字符或者子串是后一次出现的地方。

#### StringBuffer构造函数

StringBuffer定义了三个构造函数：
StringBuffer()
StringBuffer(int size)
StringBuffer(String str)
StringBuffer(CharSequence chars)

下面是StringBuffer相关的函数：
length()和capacity()
一个StringBuffer当前长度可通过length()方法得到,而整个可分配空间通过capacity()方法得到。

ensureCapacity() 设置缓冲区的大小
void ensureCapacity(int capacity)

setLength() 设置缓冲区的长度
void setLength(int len)

charAt()和setCharAt()
char charAt(int where)
void setCharAt(int where,char ch)

#### getChars() append()

void getChars(int sourceStart,int sourceEnd,char target[],int targetStart)

append() 可把任何类型数据的字符串表示连接到调用的StringBuffer对象的末尾。
例：int a=42;
StringBuffer sb=new StringBuffer(40);
String s=sb.append(”a=”).append(a).append(”!”).toString();

#### insert() 插入字符串

StringBuffer insert(int index,String str)
StringBuffer insert(int index,char ch)
StringBuffer insert(int index,Object obj)
index指定将字符串插入到StringBuffer对象中的位置的下标。

#### reverse() 颠倒StringBuffer对象中的字符

StringBuffer reverse()

delete()和deleteCharAt() 删除字符
StringBuffer delete(int startIndex,int endIndex)
StringBuffer deleteCharAt(int loc)

#### replace() 替换

StringBuffer replace(int startIndex,int endIndex,String str)

substring() 截取子串
String substring(int startIndex)
String substring(int startIndex,int endIndex)

####  str.charAt(7)

char ch = str.charAt(7);  //得到索引为7的字符

#### split 分割字符串

```
 String[] s = str.split(",");//将序列化之后的序列用，分隔符转化为数组
```

#### [java字符常量与字符串常量的区别](https://www.cnblogs.com/lupeirannb/p/4008760.html)

形式上：字符常量是单引号引起的一个字符例：‘a’
字符串常量是双引号引起的若干个字符"helloworld"
含义上：字符常量相当于一个整形值（ASC||值），可以参加表达式运算，直接拿变量使用
字符串常量代表一个地址值（该字符在内存中存放的位置）
占内存大小：
字符常量只占一个字节
字符串常量占若干个字节
字符型常量使用char型变量来存储
字符串用char型的数组来存储

类型字符类型为char，字符串类型为string
两者都是常量，区别于使用方法的不同

#### [String.valueOf() 方法的使用](https://www.cnblogs.com/zhangjs8385/archive/2011/11/04/2236527.html)

**1. 由 基本数据型态转换成 String** 
String 类别中已经提供了将基本数据型态转换成 String 的 static 方法 
也就是 String.valueOf() 这个参数多载的方法 
有下列几种 
String.valueOf(boolean b) : 将 boolean 变量 b 转换成字符串 
String.valueOf(char c) : 将 char 变量 c 转换成字符串 
String.valueOf(char[] data) : 将 char 数组 data 转换成字符串 
String.valueOf(char[] data, int offset, int count) : 
将 char 数组 data 中 由 data[offset] 开始取 count 个元素 转换成字符串 
String.valueOf(double d) : 将 double 变量 d 转换成字符串 
String.valueOf(float f) : 将 float 变量 f 转换成字符串 
String.valueOf(int i) : 将 int 变量 i 转换成字符串 
String.valueOf(long l) : 将 long 变量 l 转换成字符串 
String.valueOf(Object obj) : 将 obj 对象转换成 字符串, 等于 obj.toString() 
用法如: 
int i = 10; 
String str = String.valueOf(i); 
这时候 str 就会是 "10" 

#### 获取字符串长度、字符等

1、 获取字符串长度方法length()

　　　　格式：int length = str.length();

　　2、获取字符串中的第i个字符方法charAt(i)

　　　　格式：char ch = str.charAt(i); //i为字符串的索引号，可得到字符串任意位置处的字符，保存到字符变量中

　　3、获取指定位置的字符方法getChars(4个参数)

　　　　格式：char array[] = new char[80]; //先要创建以一个容量足够大的char型数组，数组名为array

　　　　str.getChars(indexBegin,indexEnd,array,arrayBegin);

　　解释一下括号中四个参数的指向意义：

　　　　　　1、indexBegin：需要复制的字符串的开始索引

　　　　　　2、 indexEnd:  需要复制的字符串的结束索引，indexEnd-1

　　　　　　3、array:       前面定义的char型数组的数组名

　　　　　　4、arrayBegin:数组array开始存储的位置索引号

　　这样我们就可以将字符串中想要的范围内的字符都复制到字符数组中，将字符数组打印输出即可。

　　与getChars()类似的方法有一个getBytes(),两者使用上基本相同，只是getBytes()方法创建的是byte类型的数组，而byte编码是默认字符集编码，它是用编码表示的字符。

下面就上代码简单演示一下三种方法的用法：

[![复制代码](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/copycode-1594738696720.gif)](javascript:void(0);)

```
 1 //String类基本操作方法
 2 public class StringBasicOpeMethod {
 3     public static void main(String args[]){
 4         String str = "如何才能变得像棋哥一样优秀？算了吧，憋吹牛逼！"; //定义一个字符串
 5         System.out.println(str);  //输出字符串
 6         /***1、length()方法***/
 7         int length = str.length();//得到字符串长度
 8         System.out.println("字符串的长度为："+length);
 9         /***2、charAt()方法***/
10         char ch = str.charAt(7);  //得到索引为7的字符
11         System.out.println("字符串中的第8个字符为："+ch);
12         /***3、getChars()方法***/
13         char chardst[] = new char[80]; //定义容量为80的字符数组，用于存储从字符串中提取出的一串字符
14         str.getChars(0,14,chardst,0);
15         //System.out.println("字符数组中存放的内容为："+chardst);//错误，输出的是编码
16         System.out.println(chardst); //**括号中不可带其他字符串
17     }
18 }
```

#### 字符串比较 

　　我们知道，明确的数值之间可以很方便地进行比较，那么字符串该如何进行比较呢？字符串的比较是将两个字符串从左到右逐个字符逐个字符进行比较，比较的依据是当前字符的Uncode编码值，直到比较出两个不同字符的大小。

　　字符串比较也分为两大类：一类是字符串大小的比较，这样的比较有三种结果，大于、等于以及小于；还有一类比较方法就是比较两个字符串是否相等，这样产生的比较结果无非就两种，ture和false。

  1、首先看一下第一种比较大小这类需求中的方法：

​     (1)不忽略字符串大小写情况下字符串的大小比较方法compareTo(another str)

​          格式：int result = str1.compareTo(str2);

​        输出三种比较结果：若该字符串的Unicode值<参数字符串的Unicode值，结果返回一负整数；若若该字符串的Unicode值=参数字符串的Unicode值，结果返回0；若该字符串的Unicode值>参数字符串的Unicode值，结果返回一正整数。

​     (2) 忽略字符串大小写情况下字符串的大小比较方法compareTOIgnoreCase(another str)

​          格式：int result = str1.compareToIgnoreCase(str2);

​        在忽略字符串大小写情况下，返回三种比较结果：输出三种比较结果：若该字符串的Unicode值<参数字符串的Unicode值，结果返回一负整数；若若该字符串的Unicode值=参数字符串的Unicode值，结果返回0；若该字符串的Unicode值>参数字符串的Unicode值，结果返回一正整数。

  2、然后看一下第二种判别两种字符串是否相等(相等情况下必须保证二者长度相等)需求中的方法：

​      (1)不忽略字符串大小写情况下判别字符串相等的方法eaquals(another str)

​          格式：boolean result = str1.equals(str2);

​          当且仅当str1和str2的长度相等，且对应位置字符的Unicode编码完全相等，返回true,否则返回false

​       (2)  忽略字符串大小写情况下判别字符串相等的方法equalsIgnoreCase(another str)

​          格式：boolean result = str1.equals(str2);

 demo如下：



```
public class StringCompareMethod {
    public static void main(String args[]){
        String str1 = "elapant";
        String str2 = "ELEPANT";  //定义两个字符串
        String str3 = "Apple";
        String str4 = "apple";
        /***1、compareTo方法***/
        //不忽略字符串字符大小写
        if(str1.compareTo(str2)>0){
            System.out.println(str1+">"+str2);
        }else if(str1.compareTo(str2) == 0){
            System.out.println(str1+"="+str2);
        }else{
            System.out.println(str1+"="+str2);
        }
        /***2、compareToIgnoreCase()方法***/
        //忽略字符串字符大小写
        if(str1.compareToIgnoreCase(str2)>0){
            System.out.println(str1+">"+str2);
        }else if(str1.compareToIgnoreCase(str2) == 0){
            System.out.println(str1+"="+str2);
        }else{
            System.out.println(str1+"<"+str2);
        }
        /***3、equals()方法***/
        //不忽略字符串字符大小写
        if(str3.equals(str4)){
            System.out.println(str3+"="+str4);
        }else{
            System.out.println(str3+"!="+str4);
        }
        /***4、equalsIgnoreCase()方法***/
        //忽略字符串字符大小写
        if(str3.equalsIgnoreCase(str4)){
            System.out.println(str3+"="+str4);
        }else{
            System.out.println(str3+"!="+str4);
        }
    }
}
```

![image-20200714225341569](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200714225341569.png)



####  三、字符串与其他数据类型的转换

 有时候我们需要在字符串与其他数据类型之间做一个转换，例如将字符串数据变为整形数据，或者反过来将整形数据变为字符串类型数据，"20"是字符串，20就是整形数。我们都知道整形和浮点型之间可以利用强制类型转换和自动类型转换两种机制实现两者之间的转换，那么"20"和20这两种属于不同类型的数据就需要用到String类提供的数据类型转换方法了。

  由于数据类型较多，因而转换使用的方法也比较多，在此我就用一个表格罗列一下：

| 数据类型 | 字符串转换为其他数据类型的方法 | 其它数据类型转换为字符串的方法1 | 其他数据类型转换为字符串的方法2 |
| -------- | ------------------------------ | ------------------------------- | ------------------------------- |
| byte     | Byte.parseByte(str)            | String.valueOf([byte] bt)       | Byte.toString([byte] bt)        |
| int      | Integer.parseInt(str)          | String.valueOf([int] i)         | Int.toString([int] i)           |
| long     | Long.parseLong(str)            | String.valueOf([long] l)        | Long.toString([long] l)         |
| float    | Float.parseFloat(str)          | String.valueOf([float] f)       | Float.toString([float] f)       |
| double   | double.parseDouble(str)        | String.valueOf([double] d)      | Double.toString([double] b)     |
| char     | str.charAt()                   | String.valueOf([char] c)        | Character.toString([char] c)    |
| boolean  | Boolean.getBoolean(str)        | String.valueOf([boolean] b)     | Boolean.toString([boolean] b)   |



```
public class StringConvert {
　　public static void main(String args[]){
　　　　/***将字符串类型转换为其他数据类型***/
　　　　boolean bool = Boolean.getBoolean("false"); //字符串类型转换为布尔类型
　　　　int integer = Integer.parseInt("20"); //字符串类型转换为整形
　　　　long LongInt = Long.parseLong("1024"); //字符串类型转换为长整形
　　　　float f = Float.parseFloat("1.521"); //字符串类型转换为单精度浮点型
　　　　double d = Double.parseDouble("1.52123");//字符串类型转换为双精度浮点型
　　　　byte bt = Byte.parseByte("200"); //字符串类型转换为byte型
　　　　char ch = "棋哥".charAt(0);
　　　　/***将其他数据类型转换为字符串类型方法1***/
　　　　String strb1 = String.valueOf(bool); //将布尔类型转换为字符串类型
　　　　String stri1 = String.valueOf(integer); //将整形转换为字符串类型
　　　　String strl1 = String.valueOf(LongInt); //将长整型转换为字符串类型
　　　　String strf1 = String.valueOf(f); //将单精度浮点型转换为字符串类型
　　　　String strd1 = String.valueOf(d); //将double类型转换为字符串类型
　　　　String strbt1 = String.valueOf(bt); //将byte转换为字符串类型
　　　　String strch1 = String.valueOf(ch); //将字符型转换为字符串类型
　　}
}
```

#### 四、字符串查找

 我们有时候需要在一段很长的字符串中查找我们需要的其中一部分字符串或者某个字符，String类恰恰提供了相应的查找方法，这些方法返回的都是目标查找对象在字符串中的索引值，所以都是整形值。具体分类情况如下：

 字符串查找无非分为两类：查找字符串和查找单个字符，而查找又可分为查找对象在字符串中第一次出现的位置和最后一次出现的位置，再扩展一步，我们可以缩小查找范围，在指定范围之内查找其第一次或最后一次出现的位置。

 （1）查找字符出现的位置

​      1、indexOf()方法

​        格式：1、str.indexOf(ch);

​             2、str.indexOf(ch,fromIndex); //包含fromIndex位置

​        格式1返回指定字符在字符串中第一次出现位置的索引 

​         格式2返回指定索引位置之后第一次出现该字符的索引号

​      2、lastIndexOf()方法

​        格式：1、str.lastIndexOf(ch);

​             2、str.lastIndexOf(ch,fromIndex);

​        格式1返回指定字符在字符串中最后一次出现位置的索引

​        格式2返回指定索引位置之前最后一次出现该字符的索引号

  (2)  查找字符串出现的位置

​     1、indexOf()方法 

​        格式：1、str.indexOf(str);

​             2、str.indexOf(str,fromIndex);

​        格式1返回指定子字符串在字符串中第一次出现位置的索引

​        格式2返回指定索引位置之前第一次出现该子字符串的索引号

​      2、lastIndexOf()方法

​        格式：1、str.lastIndexOf(str);

​             2、str.lastIndexOf(str,fromIndex); 

​        格式1返回指定子字符串在字符串中最后一次出现位置的索引

​        格式2返回指定索引位置之前最后一次出现该子字符串的索引号

看代码：

[![复制代码](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/copycode-1594738520026.gif)](javascript:void(0);)

```
//字符与字符串查找
public class StringSearchChar {
　　public static void main(String args[]){
　　　　String str = "How qi bocome handsome like qi ge"; //定义一个长字符串
　　　　System.out.println("该字符串为："+str);
　　　　/***1、indexOf()方法查找字符首个出现位置格式1,2***/
　　　　int index1 = str.indexOf(" "); //找到第一个空格所在的索引
　　　　int index2 = str.indexOf(" ",4); //找到索引4以后的第一个空格所在索引
　　　　System.out.println("第一个空格所在索引为："+index1);
　　　　System.out.println("索引4以后的第一个空格所在索引为："+index2);
　　　　System.out.println("*****************");
　　　　/***2、lastIndexOf()方法查找字符最后出现位置格式1,2***/
　　　　int index3 = str.lastIndexOf(" "); //找到最后一个空格所在的索引
　　　　int index4 = str.lastIndexOf(" ",10);//找到索引10以后的第一个空格所在索引
　　　　System.out.println("最后一个空格所在索引为："+index3);
　　　　System.out.println("索引10以前最后一个空格所在索引为："+index4);
　　　　System.out.println("*****************");
　　　　/***3、indexOf()方法查找子字符串第一次出现位置格式1,2***/
　　　　int index5 = str.indexOf("qi"); //找到"qi"子字符串第一次出现位置的索引
　　　　int index6 = str.indexOf("qi",5);//找到索引5以后子字符串"qi"第一个出现位置所在索引
　　　　System.out.println("子字符串qi第一次出现位置的索引号为："+index5);
　　　　System.out.println("索引5以后子字符串qi第一次出现位置的索引号为："+index6);
　　　　System.out.println("*****************");
　　　　/***4、lastIndexOf()方法查找子字符串最后一次出现位置格式1,2***/
　　　　int index7 = str.lastIndexOf("qi");
　　　　int index8 = str.lastIndexOf("qi",5);
　　　　System.out.println("子字符串qi最后一次出现位置的索引号为："+index7);
　　　　System.out.println("索引号5以后子字符串qi最后一次出现位置的索引号为："+index8);
　　}
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

结果截图如下：

 ![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1247549-20190118151924882-954603392.png)

 

####  五、截取与拆分

 这类方法是截取出一个长字符串中的一个子字符串或将字符串按照正则表达式的要求全部拆分保存到一个字符串数组中。具体方法如下所示：

 (1) 截取方法

   1、substring()方法  

​      格式1：String result = str.substring(index)；

​      格式2：String result = str.substring(beginIndex,EndIndex)；//实际索引号[beginIndex,EndIndex-1]

​       结果：截取出范围内的字符串

（2）拆分方法

​    1、split()方法

​      格式1 ：String strArray[] = str.split(正则表达式);// 拆分的结果保存到字符串数组中

​      格式2：String strArray[] = str.split(正则表达式，limit);

代码示例如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
//字符串截取与拆分
public class StringCutAndSplit {
　　public static void main(String args[]){
　　　　String str = "How to cut and split strings"; //定义字符串
　　　　System.out.println("字符串为："+str);
　　　　int length = str.length(); //获取字符串长度，保存到变量中
　　　　System.out.println("字符串长度为："+length);
　　　　/***1、substring()方法截取出第一个单词和最后一个单词***/
　　　　//首先配合indexOf()和lastIndexOf()方法找到第一个单词和最后一个单词前后空格的索引号
　　　　//第一个单词的左范围索引为0，最后一个单词的右范围索引为length-1
　　　　int firstIndex = str.indexOf(' '); //找到第一个空格所在位置
　　　　int lastIndex = str.lastIndexOf(' '); //找到最后一个空格所在位置
　　　　System.out.println("第一个空格的索引号为："+firstIndex);
　　　　System.out.println("最后一个空格的索引号为："+lastIndex);
　　　　//利用substring()方法根据第一个和最后一个单词的索引范围截取出第一个和最后一个单词
　　　　String firstWord = str.substring(0,firstIndex); //截取出第一个单词
　　　　String lastWord = str.substring(lastIndex+1,length);//截取出最后一个单词
　　　　System.out.println("第一个单词为："+firstWord);
　　　　System.out.println("最后一个单词为："+lastWord);
　　　　/***1、split()方法拆分出所有单词***/
　　　　String stringArray[] = str.split(" "); //根据空格要求拆分出所有单词保存到字符串数组中
　　　　System.out.println("拆分之后的各个词汇为："); //输出提示信息
　　　　for(int i = 0;i<stringArray.length;i++){
　　　　　　System.out.print(stringArray[i]+"\t");
　　　　}
　　}
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

代码执行结果如下：

 ![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1247549-20190118152053842-970998739.png)

 

#### 六、替换或修改

终于到最后一类方法了，开心！！有时候我们需要对原字符串中的某些子字符串进行替换或修改，此时也需要String类提供的一些简单快捷好用的方法啦

（1）concat()方法：合并字符串

​     格式：String result = str1.concat(str2);  //将str1和str2合并

 (2) toLowerCase()方法：将字符全部转化为小写

​     格式: String result = str.toLowerCase();

 (3) toUpperCase()方法： 将字符全部转化为大写

​     格式：String result = str.toUpperCase();     

 (4)replaceAll()、replaceFirst()方法：需要匹配正则表达式     

代码如下：

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

```
//字符串替换与修改
public class StringFindandReplace {
　　public static void main(String args[]){
　　　　String str1 = "vbasic";
　　　　String str2 = "Vbasic";
　　　　System.out.println("str1 = "+str1);
　　　　System.out.println("str2 = "+str2);
　　　　/***1、concat()方法将两字符串合并***/
　　　　String str3 = str1.concat(str2);
　　　　System.out.println("str1和str2合并后的字符串为："+str3);
　　　　/***2、toLowerCase()方法将str1字符全部转换为小写***/
　　　　String str4 = str1.toLowerCase();
　　　　System.out.println("str1的字符全部转换为小写："+str4);
　　　　/***3、toUpperCase()方法将str2字符全部转换为大写***/
　　　　String str5 = str2.toUpperCase();
　　　　System.out.println("str2的字符全部转换为大写："+str5);
　　　　/***4、实现字符串的替换，原字符串内容不变***/
　　　　String str6 = str1.replaceFirst("(?i)VBASIC","C++");
　　　　String str7 = str2.replaceFirst("(?-i)VBASIC","C++");
　　　　System.out.println("替换后的str1："+str6);
　　　　System.out.println("替换后的str2:"+str7);
　　}
}
```

[![复制代码](https://common.cnblogs.com/images/copycode.gif)](javascript:void(0);)

代码运行结果截图：

 ![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1247549-20190118152231099-1831673964.png)

#### String，StringBuilder和StringBuffer的区别

这三个类的主要区别在两个方面：运算速度（运算性能或执行效率）和线程安全性。

1、运算速度比较（通常情况下）：StringBuilder > StringBuffer > String

String是final类不能被继承且为字符串常量，而StringBuilder和StringBuffer均为字符串变量。String对象一旦创建便不可更改，而后两者是可更改的，它们只能通过构造函数来建立对象，且对象被建立以后将在内存中分配内存空间，并初始保存一个null，通过append方法向StringBuffer和StringBuilder中赋值。请看如下示例代码：

String str = "abc";
System.out.println(str);
str = str + "de";
System.out.println(str);
上述代码先创建一个String对象str，并赋值abc给str，然后运行到第三行，JVM会再创建一个新的str对象，并将原有str的值和de加起来再赋值给新的str。而第一个创建的str对象被JVM的垃圾回收机制（GC）回收掉。所以str实际上并没有被更改，即String对象一旦创建就不可更改。所以Java中对String对象进行的操作实际上是一个不断创建并回收对象的过程，因此在运行速度上很慢。

而StringBuilder和StringBuffer的对象是变量，对变量的操作是直接对该对象就行更改，因此不会进行反复的创建和回收。所以在运行速度上比较快。

String str = "abc" + "de";
StringBuilder stringBuilder = new StringBuilder().append("abc").append("de");
System.out.println(str);
System.out.println(stringBuilder.toString());
上述代码中String的操作速度反而要比StringBuilder快，这是因为在JVM眼里，第1行的代码操作和下列代码是完全一样的，所以很快。

String str = "abcde";
但如下的代码写法形式速度会很慢，JVM会不断地创建和回收对象来进行操作。

String str1 = "abc";
String str2 = "de";
String str = str1 + str2;
2. 线程安全性

StringBuilder（非线程安全）

而StringBuilder的方法没有该关键字修饰，所以不能保证线程安全性。是JDK1.5新增的，该类提供一个与StringBuffer兼容的 API，但不能保证同步，所以在性能上较高。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。

StringBuffer（线程安全的）

StringBuffer中大部分方法由synchronized关键字修饰，在必要时可对方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致，所以是线程安全的。类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。

3. 总结

String：适用于少量的字符串操作。

StringBuilder：适用于单线程下在字符串缓冲区进行大量操作。

StringBuffer：适用于多线程下在字符串缓冲区进行大量操作。**String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）**
 简要的说， String 类型和 StringBuffer 类型的主要性能区别其实在于 String 是不可变的对象, 因此在每次对 String 类型进行改变的时候其实都等同于生成了一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，那速度是一定会相当慢的。
 而如果是使用 StringBuffer 类则结果就不一样了，每次结果都会对 StringBuffer 对象本身进行操作，而不是生成新的对象，再改变对象引用。所以在一般情况下我们推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。而在某些特别情况下， String 对象的字符串拼接其实是被 JVM 解释成了 StringBuffer 对象的拼接，所以这些时候 String 对象的速度并不会比 StringBuffer 对象慢，而特别是以下的字符串对象生成中， String 效率是远要比 StringBuffer 快的：
 String S1 = “This is only a” + “ simple” + “ test”;
 StringBuffer Sb = new StringBuilder(“This is only a”).append(“ simple”).append(“ test”);
 你会很惊讶的发现，生成 String S1 对象的速度简直太快了，而这个时候 StringBuffer 居然速度上根本一点都不占优势。其实这是 JVM 的一个把戏，在 JVM 眼里，这个
 String S1 = “This is only a” + “ simple” + “test”; 其实就是：
 String S1 = “This is only a simple test”; 所以当然不需要太多的时间了。但大家这里要注意的是，如果你的字符串是来自另外的 String 对象的话，速度就没那么快了，譬如：
String S2 = “This is only a”;
String S3 = “ simple”;
String S4 = “ test”;
String S1 = S2 +S3 + S4;
这时候 JVM 会规规矩矩的按照原来的方式去做


在大部分情况下 StringBuffer > String
**StringBuffer**
Java.lang.StringBuffer线程安全的可变字符序列。一个类似于 String 的字符串缓冲区，但不能修改。虽然在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。
可将字符串缓冲区安全地用于多个线程。可以在必要时对这些方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致。
StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。
例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append("le") 会使字符串缓冲区包含“startle”，而 z.insert(4, "le") 将更改字符串缓冲区，使之包含“starlet”。
在大部分情况下 StringBuilder > StringBuffer

**java.lang.StringBuilde**
java.lang.StringBuilder一个可变的字符序列是5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快。两者的方法基本相同。

#### Java StringBuffer 和 StringBuilder 类



当对字符串进行修改的时候，需要使用 StringBuffer 和 StringBuilder 类。

和 String 类不同的是，StringBuffer 和 StringBuilder 类的对象能够被多次的修改，并且不产生新的未使用对象。

StringBuilder 类在 Java 5 中被提出，它和 StringBuffer 之间的最大不同在于 StringBuilder 的方法不是线程安全的（不能同步访问）。

由于 StringBuilder 相较于 StringBuffer 有速度优势，所以多数情况下建议使用 StringBuilder 类。然而在应用程序要求线程安全的情况下，则必须使用 StringBuffer 类。

#### Test.java 文件代码：

public class Test{  public static void main(String args[]){    StringBuffer sBuffer = new StringBuffer("菜鸟教程官网：");    sBuffer.append("www");    sBuffer.append(".runoob");    sBuffer.append(".com");    System.out.println(sBuffer);    } }

以上实例编译运行结果如下：

```
菜鸟教程官网：www.runoob.com
```

### StringBuffer 方法

以下是 StringBuffer 类支持的主要方法：

| 序号 | 方法描述                                                     |
| :--- | :----------------------------------------------------------- |
| 1    | public StringBuffer append(String s) 将指定的字符串追加到此字符序列。 |
| 2    | public StringBuffer reverse()  将此字符序列用其反转形式取代。 |
| 3    | public delete(int start, int end) 移除此序列的子字符串中的字符。 |
| 4    | public insert(int offset, int i) 将 `int` 参数的字符串表示形式插入此序列中。 |
| 5    | replace(int start, int end, String str) 使用给定 `String` 中的字符替换此序列的子字符串中的字符。 |

下面的列表里的方法和 String 类的方法类似：

| 序号 | 方法描述                                                     |
| :--- | :----------------------------------------------------------- |
| 1    | int capacity() 返回当前容量。                                |
| 2    | char charAt(int index) 返回此序列中指定索引处的 `char` 值。  |
| 3    | void ensureCapacity(int minimumCapacity) 确保容量至少等于指定的最小值。 |
| 4    | void getChars(int srcBegin, int srcEnd, char[] dst, int dstBegin) 将字符从此序列复制到目标字符数组 `dst`。 |
| 5    | int indexOf(String str) 返回第一次出现的指定子字符串在该字符串中的索引。 |
| 6    | int indexOf(String str, int fromIndex) 从指定的索引处开始，返回第一次出现的指定子字符串在该字符串中的索引。 |
| 7    | int lastIndexOf(String str) 返回最右边出现的指定子字符串在此字符串中的索引。 |
| 8    | int lastIndexOf(String str, int fromIndex) 返回 String 对象中子字符串最后出现的位置。 |
| 9    | int length()  返回长度（字符数）。                           |
| 10   | void setCharAt(int index, char ch) 将给定索引处的字符设置为 `ch`。 |
| 11   | void setLength(int newLength) 设置字符序列的长度。           |
| 12   | CharSequence subSequence(int start, int end) 返回一个新的字符序列，该字符序列是此序列的子序列。 |
| 13   | String substring(int start) 返回一个新的 `String`，它包含此字符序列当前所包含的字符子序列。 |
| 14   | String substring(int start, int end) 返回一个新的 `String`，它包含此序列当前所包含的字符子序列。 |
| 15   | String toString() 返回此序列中数据的字符串表示形式。         |

### Character类的常用方法

在对象中包装一个基本类型 char 的值。Character 类型的对象包含类型为 char 的单个字段。 以确定字符的类别（小写字母，数字，等等）

构造方法:
public Character(char value)

构造一个新分配的 Character 对象，用以表示指定的 char 值



Character类的判断功能:
public static boolean isDigit(char ch)
确定指定字符是否为数字。

public static boolean isLetter(char ch)
 确定指定字符是否为字母。

public static boolean isLowerCase(char ch)
确定是否是小写字母字符

public static boolean isUpperCase(char ch)
确定是否大写字母字符


两个转换功能:
public static int toLowerCase(char ch)
使用取自 UnicodeData 文件的大小写映射信息将字符参数转换为小写。

public static int toUpperCase(char ch)
使用取自 UnicodeData 文件的大小写映射信息将字符参数转换为大写。



### 14.Java中&&和&以及||和|的区别

在java的逻辑运算符中，有这么四类：&&（短路与），&（与），|（或），||（短路或）。

&&和&都是表示与，区别是&&只要第一个条件不满足，后面条件就不再判断。而&要对所有的条件都进行判断。

||（短路或）和|（或）都是表示“或”，区别是||只要满足第一个条件，后面的条件就不再判断，而|要对所有的条件进行判断。

看下面代码：



### 15.数列和数组的排序

Java排序方法sort的使用详解](https://www.cnblogs.com/minshia/p/6283858.html)



### 16.java.lang.Math.max

(参数1，参数2)是一个静态的工具方法

贴上jdk里面的源代码

    /**
    * Returns the greater of two {@code int} values. That is, the
    *返回两个{代码INT}值的较大值。也就是说，
    * result is the argument closer to the value of
    *结果是更接近价值的论点
    * {@link Integer#MAX_VALUE}. If the arguments have the same value,
    *{Link整数×Max值}。如果参数具有相同的值，
    * the result is that same value.		*结果是相同的值。
    *
    *
    * @param   a   an argument.
    *PARAM A的一个起点。
    * @param   b   another argument.
    *PARAM B的另一个起点。
    * @return  the larger of {@code a} and {@code b}.
    *@返回较大的{@代码A}和{@代码B}。
    */
    public static int max(int a, int b) {
        return (a >= b) ? a : b;
    }
与数值比较运算不同，该方法认为负 0 严格小于正 0。如果一个参数为正 0，另一个参数为负 0，那么结果为正 0。 

其实可以直接理解成 a >= b 就返回a，否则就返回b

下面是示例：

找出连续升序的最长的长度和降序的最长长度（也就是目前最长的长度）



	public class Demo {
		public static void main(String[] args) {
			int[] arr = { 11,12,13,14,15,16,17,18,31,2,13,313,123,3};
			int[] arra = { 10,9,8,7,6,5,4,3,2,1,3,4,6,7,8,2,6,2,6,2};
			int longest = getMaxLength(arr);
			int length = getMinLength(arra);
			System.out.println("升序最长的长度："+longest);
			System.out.println("降序最长的长度："+length);
	}
	
	/**
	 * 找出连续升序最长的长度
	 * @param arr 数组
	 * @return 长度
	 */
	public static int getMaxLength(int[] arr){
		int len = 1;	//长度初始化为1
		int longest = 0;	//连续最长的长度
		for (int i = 0; i < arr.length; i++) {
			//判断下一个数是否是本身加一
			if (i + 1 < arr.length && arr[i] + 1 == arr[i + 1]) {
				len++;	//有就自增
				longest = Math.max(longest, len);
			} else {
				len = 1;	//没有则初始化成1
			}
		}
		return longest;	//返回长度
	}
	
	/**
	 * 找出连续降序最长的长度
	 * @param arra 数组
	 * @return	长度
	 */
	public static int getMinLength(int[] arra){
		int len = 1;	//长度初始化为1
		int longest = 0;	//连续最长的长度
		for (int i = 0; i < arra.length; i++) {
			//判断下一个数是否是本身减一
			if (i + 1 < arra.length && arra[i] - 1 == arra[i + 1]) {
				len++;	//有就自增
				longest = Math.max(longest, len);
			} else {
				len = 1;	//没有则初始化成1
			}
		}
		return longest;	//返回长度
	}
}
控制台输出结果：

![image-20200705160714274](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200705160714274.png)

————————————————
版权声明：本文为CSDN博主「冷帝」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/weixin_42537350/article/details/84202630

### 17.java双端队列

　ArrayDeque是JDK容器中的一个双端队列实现，内部使用数组进行元素存储，不允许存储null值，可以高效的进行元素查找和尾部插入取出，是用作队列、双端队列、栈的绝佳选择，性能比LinkedList还要好。听到这里，不熟悉ArrayDeque的你是不是有点尴尬？JDK中竟然还有这么好的一个容器类？

```
public class DequeTest {
    public static void main(String[] args){
        // 初始化容量为4
        ArrayDeque<String> arrayDeque = new ArrayDeque<>(4);
        //添加元素
        arrayDeque.add("A");
        arrayDeque.add("B");
        arrayDeque.add("C");
        arrayDeque.add("D");
        arrayDeque.add("E");
        arrayDeque.add("F");
        arrayDeque.add("G");
        arrayDeque.add("H");
        arrayDeque.add("I");
        System.out.println(arrayDeque);

        // 获取元素
        String a = arrayDeque.getFirst();
        String a1 = arrayDeque.pop();
        String b = arrayDeque.element();
        String b1 = arrayDeque.removeFirst();
        String c = arrayDeque.peek();
        String c1 = arrayDeque.poll();
        String d = arrayDeque.pollFirst();
        String i = arrayDeque.pollLast();
        String e = arrayDeque.peekFirst();
        String h = arrayDeque.peekLast();
        String h1 = arrayDeque.removeLast();
        System.out.printf("a = %s, a1 = %s, b = %s, b1 = %s, c = %s, c1 = %s, d = %s, i = %s, e = %s, h = %s, h1 = %s", a,a1,b,b1,c,c1,d,i,e,h,h1);
        System.out.println();
        
        // 添加元素
        arrayDeque.push(e);
        arrayDeque.add(h);
        arrayDeque.offer(d);
        arrayDeque.offerFirst(i);
        arrayDeque.offerLast(c);
        arrayDeque.offerLast(h);
        arrayDeque.offerLast(c);
        arrayDeque.offerLast(h);
        arrayDeque.offerLast(i);
        arrayDeque.offerLast(c);
        System.out.println(arrayDeque);

        // 移除第一次出现的C
        arrayDeque.removeFirstOccurrence(c);
        System.out.println(arrayDeque);

        // 移除最后一次出现的C
        arrayDeque.removeLastOccurrence(c);
        System.out.println(arrayDeque);
        
    }
}

[A, B, C, D, E, F, G, H, I]
a = A, a1 = A, b = B, b1 = B, c = C, c1 = C, d = D, i = I, e = E, h = H, h1 = H
[I, E, E, F, G, H, D, C, H, C, H, I, C]
[I, E, E, F, G, H, D, H, C, H, I, C]
[I, E, E, F, G, H, D, H, C, H, I]
```

可以看到，从ArrayDeque中取出元素的姿势可谓是五花八门，不过别慌，稍后会对这些方法进行一一讲解，现在只需要知道，get、peek、element方法都是获取元素，但是不会将它移除，而pop、poll、remove都会将元素移除并返回，add和push、offer都是插入元素，它们的不同点在于插入元素的位置以及插入失败后的结果。

ArrayDeque是继承自Deque接口，Deque继承自Queue接口，Queue是队列，而Deque是双端队列，也就是可以从前或者从后插入或者取出元素，也就是比队列存取更加方便一点，单向队列只能从一头插入，从另一头取出。

|      | 从队列首部插入/取出 |                | 从队列尾部插入/取出 |                |
| :--- | :------------------ | :------------- | :------------------ | -------------- |
|      | 失败抛出异常        | 失败返回特殊值 | 失败抛出异常        | 失败返回特殊值 |
| 插入 | addFirst(e)  push() | offerFirst(e)  | addLast(e)          | offerLast(e)   |
| 移除 | removeFirst() pop() | pollFirst()    | removeLast()        | pollLast()     |
| 获取 | getFirst()          | peekFirst()    | getLast()           | peekLast()     |

```
isEmpty()
```





https://www.cnblogs.com/mfrank/p/9600137.html



### 18.小顶堆 [JAVA中PRIORITYQUEUE详解](https://www.cnblogs.com/Elliott-Su-Faith-change-our-life/p/7472265.html)

即优先队列。**优先队列的作用是能保证每次取出的元素都是队列中权值最小的**（Java的优先队列每次取最小元素，C++的优先队列每次取最大元素）。这里牵涉到了大小关系，**元素大小的评判可以通过元素本身的自然顺序（\*natural ordering\*），也可以通过构造时传入的比较器**（*Comparator*，类似于C++的仿函数）。

Java中*PriorityQueue*实现了*Queue*接口，不允许放入`null`元素；具体说是通过完全二叉树（*complete binary tree*）实现的**小顶堆**（任意一个非叶子节点的权值，都不大于其左右子节点的权值），也就意味着可以通过数组来作为*PriorityQueue*的底层实现。

![image-20200706101643349](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200706101643349.png)

```
leftNo = parentNo*2+1
rightNo = parentNo*2+2
parentNo = (nodeNo-1)/2
```

通过上述三个公式，可以轻易计算出某个节点的父节点以及子节点的下标。这也就是为什么可以直接用数组来存储堆的原因。

*PriorityQueue*的`peek()`和`element`操作是常数时间，`add()`, `offer()`, 无参数的`remove()`以及`poll()`方法的时间复杂度都是*log(N)*。

新加入的元素可能会破坏小顶堆的性质，因此需要进行必要的调整。

```
//offer(E e)
public boolean offer(E e) {
    if (e == null)//不允许放入null元素
        throw new NullPointerException();
    modCount++;
    int i = size;
    if (i >= queue.length)
        grow(i + 1);//自动扩容
    size = i + 1;
    if (i == 0)//队列原来为空，这是插入的第一个元素
        queue[0] = e;
    else
        siftUp(i, e);//调整
    return true;
}
```

上述代码中，扩容函数`grow()`类似于`ArrayList`里的`grow()`函数，就是再申请一个更大的数组，并将原数组的元素复制过去，这里不再赘述。需要注意的是`siftUp(int k, E x)`方法，该方法用于插入元素`x`并维持堆的特性。

```
//siftUp()
private void siftUp(int k, E x) {
    while (k > 0) {
        int parent = (k - 1) >>> 1;//parentNo = (nodeNo-1)/2
        Object e = queue[parent];
        if (comparator.compare(x, (E) e) >= 0)//调用比较器的比较方法
            break;
        queue[k] = e;
        k = parent;
    }
    queue[k] = x;
}
```

新加入的元素`x`可能会破坏小顶堆的性质，因此需要进行调整。调整的过程为：**从`k`指定的位置开始，将`x`逐层与当前点的`parent`进行比较并交换，直到满足`x >= queue[parent]`为止**。注意这里的比较可以是元素的自然顺序，也可以是依靠比较器的顺序。

#### element()和peek()

`element()`和`peek()`的语义完全相同，都是获取但不删除队首元素，也就是队列中权值最小的那个元素，二者唯一的区别是当方法失败时前者抛出异常，后者返回`null`。根据小顶堆的性质，堆顶那个元素就是全局最小的那个；由于堆用数组表示，根据下标关系，`0`下标处的那个元素既是堆顶元素。所以**直接返回数组`0`下标处的那个元素即可**。

![image-20200706101756957](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200706101756957.png)

代码也就非常简洁：

```
//peek()
public E peek() {
    if (size == 0)
        return null;
    return (E) queue[0];//0下标处的那个元素就是最小的那个
```

#### remove()和poll()

`remove()`和`poll()`方法的语义也完全相同，都是获取并删除队首元素，区别是当方法失败时前者抛出异常，后者返回`null`。由于删除操作会改变队列的结构，为维护小顶堆的性质，需要进行必要的调整。

![image-20200706101914819](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200706101914819.png)

代码如下：

```
public E poll() {
    if (size == 0)
        return null;
    int s = --size;
    modCount++;
    E result = (E) queue[0];//0下标处的那个元素就是最小的那个
    E x = (E) queue[s];
    queue[s] = null;
    if (s != 0)
        siftDown(0, x);//调整
    return result;
}
```

上述代码首先记录`0`下标处的元素，并用最后一个元素替换`0`下标位置的元素，之后调用`siftDown()`方法对堆进行调整，最后返回原来`0`下标处的那个元素（也就是最小的那个元素）。重点是`siftDown(int k, E x)`方法，该方法的作用是**从`k`指定的位置开始，将`x`逐层向下与当前点的左右孩子中较小的那个交换，直到`x`小于或等于左右孩子中的任何一个为止**。

```
//siftDown()
private void siftDown(int k, E x) {
    int half = size >>> 1;
    while (k < half) {
        //首先找到左右孩子中较小的那个，记录到c里，并用child记录其下标
        int child = (k << 1) + 1;//leftNo = parentNo*2+1
        Object c = queue[child];
        int right = child + 1;
        if (right < size &&
            comparator.compare((E) c, (E) queue[right]) > 0)
            c = queue[child = right];
        if (comparator.compare(x, (E) c) <= 0)
            break;
        queue[k] = c;//然后用c取代原来的值
        k = child;
    }
    queue[k] = x;
}
```

#### remove(Object o)

`remove(Object o)`方法用于删除队列中跟`o`相等的某一个元素（如果有多个相等，只删除一个），该方法不是*Queue*接口内的方法，而是*Collection*接口的方法。由于删除操作会改变队列结构，所以要进行调整；又由于删除元素的位置可能是任意的，所以调整过程比其它函数稍加繁琐。具体来说，`remove(Object o)`可以分为2种情况：1. 删除的是最后一个元素。直接删除即可，不需要调整。2. 删除的不是最后一个元素，从删除点开始以最后一个元素为参照调用一次`siftDown()`即可。此处不再赘述。

![image-20200706102140303](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200706102140303.png)

具体代码如下：

```
//remove(Object o)
public boolean remove(Object o) {
    //通过遍历数组的方式找到第一个满足o.equals(queue[i])元素的下标
    int i = indexOf(o);
    if (i == -1)
        return false;
    int s = --size;
    if (s == i) //情况1
        queue[i] = null;
    else {
        E moved = (E) queue[s];
        queue[s] = null;
        siftDown(i, moved);//情况2
        ......
    }
    return true;
}
```

#### 常用方法：

```
peek()//返回队首元素
poll()//返回队首元素，队首元素出队列
add()//添加元素
size()//返回队列元素个数
isEmpty()//判断队列是否为空，为空返回true,不空返回false
q.toArray()//变成数组
```

#### 三、优先队列的使用

1.队列保存的是基本数据类型的包装类

https://www.cnblogs.com/wei-jing/p/10806236.html

```
/自定义比较器，降序排列
static Comparator<Integer> cmp = new Comparator<Integer>() {
      public int compare(Integer e1, Integer e2) {
        return e2 - e1;
      }
    };
public static void main(String[] args) {
        //不用比较器，默认升序排列
        Queue<Integer> q = new PriorityQueue<>();
        q.add(3);
        q.add(2);
        q.add(4);
        while(!q.isEmpty())
        {
            System.out.print(q.poll()+" ");
        }
        /**
         * 输出结果
         * 2 3 4 
         */
        //使用自定义比较器，降序排列
        Queue<Integer> qq = new PriorityQueue<>(cmp);
        qq.add(3);
        qq.add(2);
        qq.add(4);
        while(!qq.isEmpty())
        {
            System.out.print(qq.poll()+" ");
        }
        /**
         * 输出结果
         * 4 3 2 
         */
}
```

 3.优先队列遍历

　　PriorityQueue的iterator（）不保证以任何特定顺序遍历队列元素。

　　若想按特定顺序遍历，先将队列转成数组，然后排序遍历

```
Queue<Integer> q = new PriorityQueue<>(cmp);
        int[] nums= {2,5,3,4,1,6};
        for(int i:nums)
        {
            q.add(i);
        }
        Object[] nn=q.toArray();
        Arrays.sort(nn);
        for(int i=nn.length-1;i>=0;i--)
            System.out.print((int)nn[i]+" ");
        /**
         * 输出结果
         * 6 5 4 3 2 1 
         */
```

4.比较器生降序说明

```
Comparator<Object> cmp = new Comparator<Object>() {
        public int compare(Object o1, Object o2) {
            //升序
            return o1-o2;
            //降序
            return o2-o1;
        }
    };
```

### 19.Integer常用方法

#### parseInt() 方法

parseInt() 方法用于将字符串参数作为有符号的十进制整数进行解析。

如果方法有两个参数， 使用第二个参数指定的基数，将字符串参数解析为有符号的整数。

所有 Number 派生类 parseInt 方法格式类似如下：

```
static int parseInt(String s)

static int parseInt(String s, int radix)
```

- **s** -- 十进制表示的字符串。

- **radix** -- 指定的基数。

  

```
public class Test{
    public static void main(String args[]){
        int x =Integer.parseInt("9");
        double c = Double.parseDouble("5");
        int b = Integer.parseInt("444",16);

        System.out.println(x);
        System.out.println(c);
        System.out.println(b);
    }
}

9
5.0
1092
```



#### 2.八进制数和十进制数

 如何表达一个八进制数呢？如果这个数是 876,我们可以断定它不是八进制数，因为八进制数中不可能出7以上的阿拉伯数字。但如果这个数是123、是567，或12345670，那么它是八进制数还是10进制数，都有可能。 
 所以规定，一个数如果要指明它采用八进制，必须在它前面加上一个0(零)，如：123是十进制，但0123则表示采用八进制。这就是八进制数的表达方法。 
 现在，对于同样一个数，比如是100，我们在代码中可以用平常的10进制表达，例如在变量初始化时： 
 int  a  =  100; 
 我们也可以这样写： 
 int  a  =  0144;  //0144是八进制的100；一个10进制数如何转成8进制，我们后面会学到。 
 千万记住，用八进制表达时，你不能少了最前的那个0。否则计算机会通通当成10进制。不过，有一个地方使用八进制数时，却不能使用加0，那就是我们前面学的用于表达字符的“转义符”表达法。 
**十六进制数的表达方法** 
 如果不使用特殊的书写形式，16进制数也会和10进制相混。随便一个数：9876，就看不出它是16进制或10进制。 
 16进制数必须以  0x开头。比如  0x1表示一个16进制数。而1则表示一个十进制。另外如：0xff,0xFF,0X102A,等等。其中的x也不区分大小写。(注意：0x中的0是数字0，而不是字母O) 
 以下是一些用法示例： 
 int  a  =  0x100F; 
 int  b  =  0x70  +  a; 



#### 3.十进制、二、八的转换

1. `二进制：Integer.toBinaryString(int i);`
2. `八进制：Integer.toOctalString(int i);`
3. `十六进制：Integer.toHexString(int i);`

以下字符作为十六进制数字：0123456789ABCDEF。

| 10进制转化其他进制 | 对应的方法,参数:n(原10进制数据),r(进制), | 返回值            |
| ------------------ | ---------------------------------------- | ----------------- |
| 10进制转2进制      | Integer.toBinaryString(n);               | 一个二进制字符串. |
| 10进制转8进制      | Integer.toOctalString(n);                | 一个八进制字符串  |
| 10进制转16进制     | Integer.toHexString(n);                  | 一个16进制字符串  |
| 10进制转 r 进制    | Integer.toString(100, 16);               | 一个r进制字符串   |

```
public static String toHexString(int i)
i -- 这是一个整数被转换为一个字符串.

返回值
此方法返回的字符串表示的无符号整数参数所表示的值以十六进制（基数为16）.
```

#### 4.Integer.bitCount

[[https://blog.csdn.net/haiyoushui123456/article/details/83997517?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight]]

统计计算二进制中1的数量,bitCount实现的功能是计算一个（byte,short,char,int统一按照int方法计算）int,long类型的数值在二进制下“1”的数量。



### 20.java中的>>和>>>

其中>>是有符号右移，>>>是无符号右移。

\>>表示：不管是正数还是负数，在移位时，所有移位的位置都置为0；例如：

int i = 2 >> 1;

int j = -2 >> 1;

![image-20200713102431446](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200713102431446.png)

先说>>： 2的二进制为0000~0010(32位)，>>1得到0000~0001，即为1； -2的二进制为1000~0010(32位，原码)=1111~1110(32位，补码)，>>1得到1111~1111(32位，补码)=1000~0001(32位，原码)，即为-1；

\>>>表示：正数时，在移位时，所有移位的位置都置为0;负数时所有当前位置前的原本为1的置为0，原本为0的置为1；

int i = 2 >>> 1;

int j = -2 >>>1;

![image-20200713102542587](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200713102542587.png)

正确的计算方式如下(移位计算是在补码上操作)：  再说>>>： 2的二进制为0000~0010(32位)，>>>1得到0000~0001，即为1； -2的二进制为1000~0010(32位，原码)=1111~1110(32位，补码)，>>>1得到0111~1111(32位，补码)=0111~1111(32位，原码)，即为int最大值；

### 21.set集合

在判断重复元素的时候，Set集合会调用hashCode()和equal()方法来实现。

HashSet是哈希表结构，主要利用HashMap的key来存储元素，计算插入元素的hashCode来获取元素在集合中的位置；

TreeSet是红黑树结构，每一个元素都是树中的一个节点，插入的元素都会进行排序；



![image-20200714104830931](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200714104830931.png)

#### 1.1 Set常用方法

#### 会自动拆箱装箱

如果set的泛型是java基本类型，在进行添加和删除或者contains的时候会自动拆箱装箱

与List接口一样，Set接口也提供了集合操作的基本方法。

但与List不同的是，Set还提供了equals(Object o)和hashCode()，供其子类重写，以实现对集合中插入重复元素的处理；



```java
public interface Set<E> extends Collection<E> {

    A:添加功能
    boolean add(E e);
    boolean addAll(Collection<? extends E> c);

    B:删除功能
    boolean remove(Object o);
    boolean removeAll(Collection<?> c);
    void clear();

    C:长度功能
    int size();

    D:判断功能
    boolean isEmpty();
    boolean contains(Object o);
    boolean containsAll(Collection<?> c);
    boolean retainAll(Collection<?> c); 

    E:获取Set集合的迭代器：
    Iterator<E> iterator();

    F:把集合转换成数组
    Object[] toArray();
    <T> T[] toArray(T[] a);

    //判断元素是否重复，为子类提高重写方法
    boolean equals(Object o);
    int hashCode();
}
```



#### 1.2 HashSet

HashSet实现Set接口，底层由HashMap(后面讲解)来实现，为哈希表结构，新增元素相当于HashMap的key，value默认为一个固定的Object。在我看来，HashSet相当于一个阉割版的HashMap;

当有元素插入的时候，会计算元素的hashCode值，将元素插入到哈希表对应的位置中来；

它继承于AbstractSet，实现了Set, Cloneable, Serializable接口。

(1)HashSet继承AbstractSet类，获得了Set接口大部分的实现，减少了实现此接口所需的工作，实际上是又继承了AbstractCollection类；

(2)HashSet实现了Set接口，获取Set接口的方法，可以自定义具体实现，也可以继承AbstractSet类中的实现；

(3)HashSet实现Cloneable，得到了clone()方法，可以实现克隆功能；

(4)HashSet实现Serializable，表示可以被序列化，通过序列化去传输，典型的应用就是hessian协议。

具有如下特点：

- 不允许出现重复因素；
- 允许插入Null值；
- 元素无序（添加顺序和遍历顺序不一致）；
- 线程不安全，若2个线程同时操作HashSet，必须通过代码实现同步；

#### 1.3 HashSet基本操作

HashSet底层由HashMap实现，插入的元素被当做是HashMap的key，根据hashCode值来确定集合中的位置，由于Set集合中并没有角标的概念，所以并没有像List一样提供get（）方法。当获取HashSet中某个元素时，只能通过遍历集合的方式进行equals()比较来实现；



```csharp
public class HashSetTest {
    public static void main(String[] agrs){
        //创建HashSet集合：
        Set<String> hashSet = new HashSet<String>();
        System.out.println("HashSet初始容量大小："+hashSet.size());

        //元素添加：
        hashSet.add("my");
        hashSet.add("name");
        hashSet.add("is");
        hashSet.add("jiaboyan");
        hashSet.add(",");
        hashSet.add("hello");
        hashSet.add("world");
        hashSet.add("!");
        System.out.println("HashSet容量大小："+hashSet.size());

        //迭代器遍历：
        Iterator<String> iterator = hashSet.iterator();
        while (iterator.hasNext()){
            String str = iterator.next();
            System.out.println(str);
        }
        //增强for循环
        for(String str:hashSet){
            if("jiaboyan".equals(str)){
                System.out.println("你就是我想要的元素:"+str);
            }
            System.out.println(str);
        }

        //元素删除：
        hashSet.remove("jiaboyan");
        System.out.println("HashSet元素大小：" + hashSet.size());
        hashSet.clear();
        System.out.println("HashSet元素大小：" + hashSet.size());

        //集合判断：
        boolean isEmpty = hashSet.isEmpty();
        System.out.println("HashSet是否为空：" + isEmpty);
        boolean isContains = hashSet.contains("hello");
        System.out.println("HashSet是否为空：" + isContains);
    }
}
```

#### 1.4 HashSet元素添加分析

Set集合不允许添加重复元素，那么到底是个怎么情况呢？

来看一个简单的例子：



```csharp
public class HashSetTest {

    public static void main(String[] agrs){
        //hashCode() 和 equals()测试：
        hashCodeAndEquals();
    }
    public static void hashCodeAndEquals(){
        //第一个 Set集合：
        Set<String> set1 = new HashSet<String>();
        String str1 = new String("jiaboyan");
        String str2 = new String("jiaboyan");
        set1.add(str1);
        set1.add(str2);
        System.out.println("长度："+set1.size()+",内容为："+set1);

        //第二个 Set集合：
        Set<App> set2 = new HashSet<App>();
        App app1 = new App();
        app1.setName("jiaboyan");

        App app2 = new App();
        app2.setName("jiaboyan");

        set2.add(app1);
        set2.add(app2);
        System.out.println("长度："+set2.size()+",内容为："+set2);

        //第三个 Set集合：
        Set<App> set3 = new HashSet<App>();
        App app3 = new App();
        app3.setName("jiaboyan");
        set3.add(app3);
        set3.add(app3);
        System.out.println("长度："+set3.size()+",内容为："+set3);
    }
}
```

测试结果：



```css
长度：1,内容为：[jiaboyan]
长度：2,内容为：[com.jiaboyan.collection.App@efb78af, com.jiaboyan.collection.App@5f3306ad]
长度：1,内容为：[com.jiaboyan.collection.App@1fb030d8]
```

可以看到，第一个Set集合中最终只有一个元素；第二个Set集合保留了2个元素；第三个集合也只有1个元素；

究竟是什么原因呢？

让我们来看看**HashSet**的add(E e)方法：



```java
public boolean add(E e) {
    return map.put(e, PRESENT)==null;
}
```

在底层HashSet调用了**HashMap**的put(K key, V value)方法:



```csharp
public V put(K key, V value) {
    if (table == EMPTY_TABLE) {
        inflateTable(threshold);
    }
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry<K,V> e = table[i]; e != null; e = e.next) {
        Object k;
        if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        }
    }
    modCount++;
    addEntry(hash, key, value, i);
    return null;
}
```

通过查看以上的源码，我们可以了解到：实际的逻辑都是在HashMap的put()方法中。



```bash
int hash = hash(key) 对传入的key计算hash值；

int i = indexFor(hash, table.length) 对hash值进行转换，转换成数组的index(HashMap中底层存储使用了Entry<K,V>[]数组)；

for (Entry<K,V> e = table[i]; e != null; e = e.next) 判断对应index下是否存在元素；

如果存在，则if(e.hash == hash && ((k = e.key) == key || key.equals(k)))判断；

如果不存在，则addEntry(hash, key, value, i)直接添加；
```

简单概括如下：

在向HashMap中添加元素时，先判断key的hashCode值是否相同，如果相同，则调用equals()、==进行判断，若相同则覆盖原有元素；如果不同，则直接向Map中添加元素；

反过来，我们在看下上面的例子：

在第一个Set集合中，我们new了两个String对象，赋了相同的值。当传入到HashMap中时，key均为“jiaboyan”，所以hash和i的值都相同。进行if (e.hash == hash && ((k = e.key) == key || key.equals(k)))判断，由于String对象重写了equals()方法，所以在((k = e.key) == key || key.equals(k))判断时，返回了true，所以第二次的插入并不会增加Set集合的长度；

第二个Set集合中，也是new了两个对象，但没有重写equals()方法（底层调用的Object的equals()，也就是==判断），所以会增加2个元素；

第三个Set集合中，只new了一个对象，调用的两次add方法都添加的这个新new的对象，所以也只是保留了1个元素；

#### 1.5 TreeSet

从名字上可以看出，此集合的实现和树结构有关。与HashSet集合类似，TreeSet也是基于Map来实现，具体实现**TreeMap**(后面讲解)，其底层结构为**红黑树**（特殊的二叉查找树）；

与HashSet不同的是，TreeSet具有排序功能，分为自然排序(123456)和自定义排序两类，默认是自然排序；在程序中，我们可以按照任意顺序将元素插入到集合中，等到遍历时TreeSet会按照一定顺序输出--倒序或者升序；

它继承AbstractSet，实现NavigableSet, Cloneable, Serializable接口。

（1）与HashSet同理，TreeSet继承AbstractSet类，获得了Set集合基础实现操作；

（2）TreeSet实现NavigableSet接口，而NavigableSet又扩展了SortedSet接口。这两个接口主要定义了搜索元素的能力，例如给定某个元素，查找该集合中比给定元素大于、小于、等于的元素集合，或者比给定元素大于、小于、等于的元素个数；简单地说，实现NavigableSet接口使得TreeSet具备了元素搜索功能；

（3）TreeSet实现Cloneable接口，意味着它也可以被克隆；

（4）TreeSet实现了Serializable接口，可以被序列化，可以使用hessian协议来传输；

具有如下特点：

- 对插入的元素进行排序，是一个有序的集合（主要与HashSet的区别）;
- 底层使用红黑树结构，而不是哈希表结构；
- 允许插入Null值；
- 不允许插入重复元素；
- 线程不安全；

#### 1.6 TreeSet基本操作



```csharp
public class TreeSetTest {
    public static void main(String[] agrs){
        TreeSet<String> treeSet = new TreeSet<String>();
        System.out.println("TreeSet初始化容量大小："+treeSet.size());

        //元素添加：
        treeSet.add("my");
        treeSet.add("name");
        treeSet.add("jiaboyan");
        treeSet.add("hello");
        treeSet.add("world");
        treeSet.add("1");
        treeSet.add("2");
        treeSet.add("3");
        System.out.println("TreeSet容量大小：" + treeSet.size());
        System.out.println("TreeSet元素顺序为：" + treeSet.toString());

        //增加for循环遍历：
        for(String str:treeSet){
            System.out.println("遍历元素："+str);
        }

        //迭代器遍历：升序
        Iterator<String> iteratorAesc = treeSet.iterator();
        while(iteratorAesc.hasNext()){
            String str = iteratorAesc.next();
            System.out.println("遍历元素升序："+str);
        }

        //迭代器遍历：降序
        Iterator<String> iteratorDesc = treeSet.descendingIterator();
        while(iteratorDesc.hasNext()){
            String str = iteratorDesc.next();
            System.out.println("遍历元素降序："+str);
        }

        //元素获取:实现NavigableSet接口
        String firstEle = treeSet.first();//获取TreeSet头节点：
        System.out.println("TreeSet头节点为：" + firstEle);

        // 获取指定元素之前的所有元素集合：(不包含指定元素)
        SortedSet<String> headSet = treeSet.headSet("jiaboyan");
        System.out.println("jiaboyan节点之前的元素为："+headSet.toString());

        //获取给定元素之间的集合：（包含头，不包含尾）
        SortedSet subSet = treeSet.subSet("1","world");
        System.out.println("1--jiaboan之间节点元素为："+subSet.toString());

        //集合判断：
        boolean isEmpty = treeSet.isEmpty();
        System.out.println("TreeSet是否为空："+isEmpty);
        boolean isContain = treeSet.contains("who");
        System.out.println("TreeSet是否包含who元素："+isContain);

        //元素删除：
        boolean jiaboyanRemove = treeSet.remove("jiaboyan");
        System.out.println("jiaboyan元素是否被删除"+jiaboyanRemove);

        //集合中不存在的元素，删除返回false
        boolean whoRemove = treeSet.remove("who");
        System.out.println("who元素是否被删除"+whoRemove);

       //删除并返回第一个元素：如果set集合不存在元素，则返回null
        String pollFirst = treeSet.pollFirst();
        System.out.println("删除的第一个元素："+pollFirst);

        //删除并返回最后一个元素：如果set集合不存在元素，则返回null
        String pollLast = treeSet.pollLast();
        System.out.println("删除的最后一个元素："+pollLast);

        treeSet.clear();//清空集合:
    }
}
```

#### 1.7 TreeSet元素排序

在前面的章节，我们讲到了TreeSet是一个有序集合，可以对集合元素排序，其中分为自然排序和自定义排序，那么这两种方式如何实现呢？

首先，我们通过JDK提供的对象来展示，我们使用String、Integer：



```csharp
public class TreeSetTest {
    public static void main(String[] agrs){
        naturalSort();
    }

    //自然排序顺序：升序
    public static void naturalSort(){
        TreeSet<String> treeSetString = new TreeSet<String>();
        treeSetString.add("a");
        treeSetString.add("z");
        treeSetString.add("d");
        treeSetString.add("b");
        System.out.println("字母顺序：" + treeSetString.toString());

        TreeSet<Integer> treeSetInteger = new TreeSet<Integer>();
        treeSetInteger.add(1);
        treeSetInteger.add(24);
        treeSetInteger.add(23);
        treeSetInteger.add(6);
        System.out.println(treeSetInteger.toString());
        System.out.println("数字顺序：" + treeSetString.toString());
    }
}
```

测试结果：



```css
字母顺序：[a, b, d, z]
数字顺序：[1, 6, 23, 24]
```

接下来，我们自定义对象，看能否实现：



```csharp
public class App{

    private String name;

    private Integer age;

    public App(){}

    public App(String name,Integer age){
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public static void main(String[] args ){
        System.out.println( "Hello World!" );
    }
}

public class TreeSetTest {
    public static void main(String[] agrs){
        customSort();
    }

     //自定义排序顺序：升序
    public static void customSort(){
        TreeSet<App> treeSet = new TreeSet<App>();

        //排序对象：
        App app1 = new App("hello",10);
        App app2 = new App("world",20);
        App app3 = new App("my",15);
        App app4 = new App("name",25);

        //添加到集合：
        treeSet.add(app1);
        treeSet.add(app2);
        treeSet.add(app3);
        treeSet.add(app4);
        System.out.println("TreeSet集合顺序为："+treeSet);
    }
}
```

测试结果：



```css
抛出异常：提示App不能转换为Comparable对象：
Exception in thread "main" java.lang.ClassCastException: com.jiaboyan.collection.App cannot be cast to java.lang.Comparable
```

为什么会报错呢？



```dart
compare(key, key); // type (and possibly null) check

final int compare(Object k1, Object k2) {
    return comparator==null ? ((Comparable<? super K>)k1).compareTo((K)k2)
        : comparator.compare((K)k1, (K)k2);
}
```

通过查看源码发现，在TreeSet调用add方法时，会调用到底层TreeMap的put方法，在put方法中会调用到compare(key, key)方法，进行key大小的比较；

在比较的时候，会将传入的key进行类型强转，所以当我们自定义的App类进行比较的时候，自然就会抛出异常，因为App类并没有实现Comparable接口；

将App实现Comparable接口，在做比较:



```java
public class App implements Comparable<App>{
    private String name;
    private Integer age;
    public App(){}
    public App(String name,Integer age){
        this.name = name;
        this.age = age;
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public Integer getAge() {
        return age;
    }
    public void setAge(Integer age) {
        this.age = age;
    }
    //自定义比较：先比较name的长度，在比较age的大小；
    public int compareTo(App app) {
        //比较name的长度：
        int num = this.name.length() - app.name.length();
        //如果name长度一样，则比较年龄的大小：
        return num == 0 ? this.age - app.age : num;
    }
    @Override
    public String toString() {
        return "App{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

测试结果如下：



```bash
TreeSet集合顺序为：[App{name='my', age=15}, App{name='name', age=25}, App{name='hello', age=10}, App{name='world', age=20}]
```

此外，还有另一种方式，那就是实现Comparetor<t>接口，并重写compare方法；



```dart
//自定义App类的比较器：
public class AppComparator implements Comparator<App> {

    //比较方法：先比较年龄，年龄若相同在比较名字长度；
    public int compare(App app1, App app2) {
        int num = app1.getAge() - app2.getAge();
        return num == 0 ? app1.getName().length() - app2.getName().length() : num;
    }
}
```

此时，App不用在实现Comparerable接口了，单纯的定义一个类即可；



```csharp
public class App{

    private String name;

    private Integer age;

    public App(){}

    public App(String name,Integer age){
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public static void main(String[] args ){
        System.out.println( "Hello World!" );
    }
}

public class TreeSetTest {
    public static void main(String[] agrs){
        customSort();
    }

    //自定义比较器：升序
    public static void customComparatorSort(){
        TreeSet<App> treeSet = new TreeSet<App>(new AppComparator());

        //排序对象：
        App app1 = new App("hello",10);
        App app2 = new App("world",20);
        App app3 = new App("my",15);
        App app4 = new App("name",25);

        //添加到集合：
        treeSet.add(app1);
        treeSet.add(app2);
        treeSet.add(app3);
        treeSet.add(app4);

        System.out.println("TreeSet集合顺序为："+treeSet);
    }
}
```

测试结果：



```bash
TreeSet集合顺序为：[App{name='hello', age=10}, App{name='my', age=15}, App{name='world', age=20}, App{name='name', age=25}]
```

最后，在说下关于compareTo()、compare()方法：



```undefined
结果返回大于0时，方法前面的值大于方法中的值；

结果返回等于0时，方法前面的值等于方法中的值；

结果返回小于0时，方法前面的值小于方法中的值；
```

集合排序方法



```dart
   @Test
    public void testFor() {
        String orderId1 = "2321837281372913";
        String userId1 = "20180701001";
        String orderId2 = "2321837281372914";
        String userId2 = "20180701002";
        String orderId3 = "2321837281372912";
        String userId3 = "20180701003";
        String orderId4 = "2321837281372918";
        String userId4 = "20180701005";
        String orderId5 = "2321837281372918";
        String userId5 = "20180701004";

        Order order = new Order();
        order.setUserId(userId1);
        order.setOrderId(orderId1);
        Order order1 = new Order();
        order1.setOrderId(orderId2);
        order1.setUserId(userId2);

        Order order2 = new Order();
        order2.setOrderId(orderId3);
        order2.setUserId(userId3);
        Order order3 = new Order();
        order3.setOrderId(orderId4);
        order3.setUserId(userId4);
        Order order4 = new Order();
        order4.setOrderId(orderId5);
        order4.setUserId(userId5);
        List<Order> orderList = new ArrayList<Order>();
        orderList.add(order);
        orderList.add(order1);
        orderList.add(order2);
        orderList.add(order3);
        orderList.add(order4);

//1.jdk8 lambda排序，带参数类型
//        orderList.sort(( Order ord1, Order ord2) -> ord2.getOrderId().compareTo(ord1.getOrderId()));

//2.jdk8 lambda排序，不带参数类型
//        orderList.sort(( ord1, ord2) -> ord2.getOrderId().compareTo(ord1.getOrderId()));

//3.jdk8 升序排序，Comparator提供的静态方法
        Collections.sort(orderList, Comparator.comparing(Order::getOrderId));

//4.jdk8 降序排序，Comparator提供的静态方法
//        Collections.sort(orderList, Comparator.comparing(Order::getOrderId).reversed());

//5.jdk8 组合排序，Comparator提供的静态方法，先按orderId排序，orderId相同的按userId排序
//        Collections.sort(orderList, Comparator.comparing(Order::getOrderId).reversed().thenComparing(Order::getUserId));

        orderList.stream().forEach(str -> System.out.println(str.getOrderId()+"/" + str.getUserId()));
    }
```



作者：Qihang
链接：https://www.jianshu.com/p/d6cff3517688
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



### 22.ASCII控制字符

| 二进制    | 十进制 | 十六进制 | 缩写 | 可以显示的表示法 | 名称/意义                           |
| --------- | ------ | -------- | ---- | ---------------- | ----------------------------------- |
| 0000 0000 | 0      | 00       | NUL  | ␀                | 空字符（Null）                      |
| 0000 0001 | 1      | 01       | SOH  | ␁                | 标题开始                            |
| 0000 0010 | 2      | 02       | STX  | ␂                | 本文开始                            |
| 0000 0011 | 3      | 03       | ETX  | ␃                | 本文结束                            |
| 0000 0100 | 4      | 04       | EOT  | ␄                | 传输结束                            |
| 0000 0101 | 5      | 05       | ENQ  | ␅                | 请求                                |
| 0000 0110 | 6      | 06       | ACK  | ␆                | 确认回应                            |
| 0000 0111 | 7      | 07       | BEL  | ␇                | 响铃                                |
| 0000 1000 | 8      | 08       | BS   | ␈                | 退格                                |
| 0000 1001 | 9      | 09       | HT   | ␉                | 水平定位符号                        |
| 0000 1010 | 10     | 0A       | LF   | ␊                | 换行键                              |
| 0000 1011 | 11     | 0B       | VT   | ␋                | 垂直定位符号                        |
| 0000 1100 | 12     | 0C       | FF   | ␌                | 换页键                              |
| 0000 1101 | 13     | 0D       | CR   | ␍                | 归位键                              |
| 0000 1110 | 14     | 0E       | SO   | ␎                | 取消变换（Shift out）               |
| 0000 1111 | 15     | 0F       | SI   | ␏                | 启用变换（Shift in）                |
| 0001 0000 | 16     | 10       | DLE  | ␐                | 跳出数据通讯                        |
| 0001 0001 | 17     | 11       | DC1  | ␑                | 设备控制一（XON 启用软件速度控制）  |
| 0001 0010 | 18     | 12       | DC2  | ␒                | 设备控制二                          |
| 0001 0011 | 19     | 13       | DC3  | ␓                | 设备控制三（XOFF 停用软件速度控制） |
| 0001 0100 | 20     | 14       | DC4  | ␔                | 设备控制四                          |
| 0001 0101 | 21     | 15       | NAK  | ␕                | 确认失败回应                        |
| 0001 0110 | 22     | 16       | SYN  | ␖                | 同步用暂停                          |
| 0001 0111 | 23     | 17       | ETB  | ␗                | 区块传输结束                        |
| 0001 1000 | 24     | 18       | CAN  | ␘                | 取消                                |
| 0001 1001 | 25     | 19       | EM   | ␙                | 连接介质中断                        |
| 0001 1010 | 26     | 1A       | SUB  | ␚                | 替换                                |
| 0001 1011 | 27     | 1B       | ESC  | ␛                | 跳出                                |
| 0001 1100 | 28     | 1C       | FS   | ␜                | 文件分割符                          |
| 0001 1101 | 29     | 1D       | GS   | ␝                | 组群分隔符                          |
| 0001 1110 | 30     | 1E       | RS   | ␞                | 记录分隔符                          |
| 0001 1111 | 31     | 1F       | US   | ␟                | 单元分隔符                          |
| 0111 1111 | 127    | 7F       | DEL  | ␡                | 删除                                |

#### ASCII可显示字符

![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/timg.jpg)

| 二进制    | 十进制 | 十六进制 | 图形        |
| --------- | ------ | -------- | ----------- |
| 0010 0000 | 32     | 20       | （空格）(␠) |
| 0010 0001 | 33     | 21       | !           |
| 0010 0010 | 34     | 22       | "           |
| 0010 0011 | 35     | 23       | #           |
| 0010 0100 | 36     | 24       | $           |
| 0010 0101 | 37     | 25       | %           |
| 0010 0110 | 38     | 26       | &           |
| 0010 0111 | 39     | 27       | '           |
| 0010 1000 | 40     | 28       | (           |
| 0010 1001 | 41     | 29       | )           |
| 0010 1010 | 42     | 2A       | *           |
| 0010 1011 | 43     | 2B       | +           |
| 0010 1100 | 44     | 2C       | ,           |
| 0010 1101 | 45     | 2D       | -           |
| 0010 1110 | 46     | 2E       | .           |
| 0010 1111 | 47     | 2F       | /           |
| 0011 0000 | 48     | 30       | 0           |
| 0011 0001 | 49     | 31       | 1           |
| 0011 0010 | 50     | 32       | 2           |
| 0011 0011 | 51     | 33       | 3           |
| 0011 0100 | 52     | 34       | 4           |
| 0011 0101 | 53     | 35       | 5           |
| 0011 0110 | 54     | 36       | 6           |
| 0011 0111 | 55     | 37       | 7           |
| 0011 1000 | 56     | 38       | 8           |
| 0011 1001 | 57     | 39       | 9           |
| 0011 1010 | 58     | 3A       | :           |
| 0011 1011 | 59     | 3B       | ;           |
| 0011 1100 | 60     | 3C       | <           |
| 0011 1101 | 61     | 3D       | =           |
| 0011 1110 | 62     | 3E       | >           |
| 0011 1111 | 63     | 3F       | ?           |

| 二进制    | 十进制 | 十六进制 | 图形 |
| --------- | ------ | -------- | ---- |
| 0100 0000 | 64     | 40       | @    |
| 0100 0001 | 65     | 41       | A    |
| 0100 0010 | 66     | 42       | B    |
| 0100 0011 | 67     | 43       | C    |
| 0100 0100 | 68     | 44       | D    |
| 0100 0101 | 69     | 45       | E    |
| 0100 0110 | 70     | 46       | F    |
| 0100 0111 | 71     | 47       | G    |
| 0100 1000 | 72     | 48       | H    |
| 0100 1001 | 73     | 49       | I    |
| 0100 1010 | 74     | 4A       | J    |
| 0100 1011 | 75     | 4B       | K    |
| 0100 1100 | 76     | 4C       | L    |
| 0100 1101 | 77     | 4D       | M    |
| 0100 1110 | 78     | 4E       | N    |
| 0100 1111 | 79     | 4F       | O    |
| 0101 0000 | 80     | 50       | P    |
| 0101 0001 | 81     | 51       | Q    |
| 0101 0010 | 82     | 52       | R    |
| 0101 0011 | 83     | 53       | S    |
| 0101 0100 | 84     | 54       | T    |
| 0101 0101 | 85     | 55       | U    |
| 0101 0110 | 86     | 56       | V    |
| 0101 0111 | 87     | 57       | W    |
| 0101 1000 | 88     | 58       | X    |
| 0101 1001 | 89     | 59       | Y    |
| 0101 1010 | 90     | 5A       | Z    |
| 0101 1011 | 91     | 5B       | [    |
| 0101 1100 | 92     | 5C       | \    |
| 0101 1101 | 93     | 5D       | ]    |
| 0101 1110 | 94     | 5E       | ^    |
| 0101 1111 | 95     | 5F       | _    |

| 二进制    | 十进制 | 十六进制 | 图形 |
| --------- | ------ | -------- | ---- |
| 0110 0000 | 96     | 60       | `    |
| 0110 0001 | 97     | 61       | a    |
| 0110 0010 | 98     | 62       | b    |
| 0110 0011 | 99     | 63       | c    |
| 0110 0100 | 100    | 64       | d    |
| 0110 0101 | 101    | 65       | e    |
| 0110 0110 | 102    | 66       | f    |
| 0110 0111 | 103    | 67       | g    |
| 0110 1000 | 104    | 68       | h    |
| 0110 1001 | 105    | 69       | i    |
| 0110 1010 | 106    | 6A       | j    |
| 0110 1011 | 107    | 6B       | k    |
| 0110 1100 | 108    | 6C       | l    |
| 0110 1101 | 109    | 6D       | m    |
| 0110 1110 | 110    | 6E       | n    |
| 0110 1111 | 111    | 6F       | o    |
| 0111 0000 | 112    | 70       | p    |
| 0111 0001 | 113    | 71       | q    |
| 0111 0010 | 114    | 72       | r    |
| 0111 0011 | 115    | 73       | s    |
| 0111 0100 | 116    | 74       | t    |
| 0111 0101 | 117    | 75       | u    |
| 0111 0110 | 118    | 76       | v    |
| 0111 0111 | 119    | 77       | w    |
| 0111 1000 | 120    | 78       | x    |
| 0111 1001 | 121    | 79       | y    |
| 0111 1010 | 122    | 7A       | z    |
| 0111 1011 | 123    | 7B       | {    |
| 0111 1100 | 124    | 7C       | \|   |
| 0111 1101 | 125    | 7D       | }    |
| 0111 1110 | 126    | 7E       | ~    |

### 23.自动装箱与拆箱(Autoboxing and unboxing)

一、什么是自动装箱拆箱 
很简单，下面两句代码就可以看到装箱和拆箱过程

```
1 //自动装箱
2 Integer total = 99;
3 
4 //自定拆箱
5 int totalprim = total;
```

 

简单一点说，装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。

下面我们来看看需要装箱拆箱的类型有哪些：

![image-20200714220914498](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200714220914498.png)

![image-20200714221015748](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200714221015748.png)

三、装箱与自动装箱的区别
装箱：利用Integer的构造方法Integer（int value），即Integer c=new Integer(1);

自动装箱：或者叫隐式装箱，直接给Integer赋值，即Integer d=1,在编译的时候，会调用Integer.valueOf（）方法完成装箱。

相比而言，自动装箱可能比装箱具有更高的效率，体现在自动装箱的缓存上，下面从几道题目来讲自动装箱的缓存。

四、相关面试题目
第一题：以下代码的输出结果为？（==号两边如果都是引用类型的话，则判断它们是否指向同一个对象。如果都是基本数据类型的话，则判断它们的数值是否相等）

package day1119;

public class TestBox2 {
    public static void main(String[] args) {
        Integer a = 100;
        Integer b = 100;
        Integer c = 200;
        Integer d = 200;
        System.out.println(a == b);
        System.out.println(c == d);
    }
}
也许有些人认为他们是四个各不相同的对象，两个式子都返回false。

实际运行后发现输出：
![image-20200714221150084](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200714221150084.png)

为什么一个是true，一个是false呢？

刚才我们知道，Integer a=100这条语句会触发自动装箱，而自动装箱的方法为Integer.valueOf（）方法，让我们去寻找这个方法，一探究竟。

观察Integer类的源码中的valueOf（）

```java
 public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }


```

可以看得出，当i的值位于[-128,127]的时候，会直接返回Integer缓存数组中相应对象的引用，如果i大于127或小于-128，会重新创建一个Integer实例，并返回。

那么第一条式子a和b的值都在缓存范围内，因此他们指向同一个对象，因此返回true。c和d的值不在范围内，都是通过new创建出来的，因此不是同一个对象，返回false。

注意：Byte、Short、Integer、Long、Character的valueOf（）实现机制类似。

其中相同值的Byte比较永远返回true，因为byte取值范围就是[-128,127]。

Short、Integer、Long的valueOf（）基本一样，i的范围都需要在[-128,127]。

Character中i的范围只要小于等于127即可，因为char最小值为0，本来就大于等于-128。

但是Float、Double中的valueOf（），永远返回新创建的对象，因为一个范围内的整数是有限的，但是小数却是无限的，无法保存在缓存中。

Boolean中只有两个对象，要么是true的Boolean，要么是false的Boolean，只要boolean的值相同，Boolean就相等。
第二题：以下代码的输出结果为？



```java
  package day1119;

public class TestBox3 {
    public static void main(String[] args) {
        Integer a = 1;
        Integer b = 2;
        Integer c = 3;
        Long d = 2L;
        Long e = 3L;
        int f = 2;
  //一旦有包装类型和数值类型判断==时，则触发包装类型的自动拆箱，转为数值类型的比较
    System.out.println(new Integer(300) == 300);//返回true
 
    //一旦有包装类型和数值类型发生运算时，则触发包装类型的自动拆箱，转为数值类型的运算
    System.out.println(c == (a + f));//返回true
 
    //一旦有包装类型和包装类型发生运算时，则触发包装类型的自动拆箱，转为数值类型的运算
    System.out.println(c == (a + b));//返回true
 
    //只有对象类型才有equals方法，因此首先a,b触发包装类型的自动拆箱，转为数值类型的运算。
    //运算完，再将结果3自动装箱，Integer重写了equals,因此可以转为包装类型与包装类型的比较。
    //当两边的包装类型不一致时，必定返回false。
    //当两边的包装类型一致时,再进行拆箱，判断两者代表的数值是否相等。
    System.out.println(c.equals(a + b));//返回true
 
    //不同数据类型的数值进行运算，首先会将低精度的数据类型转化为高精度的数据类型，即自动类型转换。
    //比如现在的int+long,会提升到long+long,再进行运算。
    System.out.println(e == (a + d));//返回true
 
    //==号两边类型不一致时，直接执行自动拆箱，比较之后的数值
    System.out.println(e == (a + b));//返回true
 
    //依次经历自动拆箱，自动类型转换、运算、自动装箱，类型比较，拆箱，数值比较
    System.out.println(e.equals(a + d));//返回true
 
    //依次经历自动拆箱，自动类型转换、运算、自动装箱，类型比较，两边类型不一致，直接返回false
    System.out.println(c.equals(a + d));//返回false
    }}
```


五、总结
如果想要深入了解自动装箱拆箱的过程，必须得反编译class文件，了解底层编译的细节，才可以解除自己此方面的疑问。
————————————————
版权声明：本文为CSDN博主「SunAlwaysOnline」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_33591903/article/details/84259105

### 24.char常用操作

#### 1.char转为int

```
char ch = '9'; 
if (Character.isDigit(ch)){  // 判断是否是数字 
int num = (int)ch - (int)('0'); System.out.println(num); }
```

Integer.parseInt(new String("1"))

char与int的相互转化，联想ASCII码，字符‘0’对应的值为48，所以不能直接加减‘ ’

char ch='9';
int ch_int=ch-'0';//此时ch_int=9
int转char

int i=9；
char i_ch=i+'0';//此时i_ch='9'

必须记住的几个ASCII值

字符值	ASCII值
‘0’	48
‘9’	57
‘A’	65
‘Z’	90
‘a’	97
‘z’	122Character.isDigit() 方法用于判断指定字符是否为数字。

#### 2.判断是不是数字Character.isDigit

语法

```
boolean isDigit(char ch)
```

参数

- ch -- 要测试的字符。

返回值

如果字符为数字，则返回 true；否则返回 false。

实例

```
public class Test {

	public static void main(String args[]) {
		System.out.println(Character.isDigit('c'));
		System.out.println(Character.isDigit('5'));
	}
}
```

以上程序执行结果为：

```
false true
```

### 25.int数值溢出问题

```
int x = Integer.MAX_VALUE ;  //  得到整型的最大值2147483647
System.out.println(x);

int y=Integer.MIN_VALUE ;//int类型的最小值 -2147483648
System.out.println(y);

System.out.println("x+1 = "+(x+1)); //x+1 = -2147483648
System.out.println("x+2 = "+(x+2)); //x+2 = -2147483647
```



int的范围为 ![图片说明](https://www.nowcoder.com/equation?tex=%5B2%5E%7B31%7D-1%2C%20-2%5E%7B31%7D%5D)

![image-20200714233652362](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200714233652362.png)

如果超过了这两个范围该怎么办？
其实也很简单，首先判断这个数的正负，如果正数，超过了INT_MAX，就设置为INT_MAX，如果是负数，首先我们不考虑负号，如果超过了INT_MAX+1, 则就置为INT_MAX+1, 最后再根据正负号，来加负号。



```
public class intTest {
    public static void main(String[] args) {
        int a = 1;
        System.out.println(a);
        for (int i =2;i<42;++i) {
            a = a*2;
        }
        System.out.println(a);

    }
}
输出：
1
0
https://www.jianshu.com/p/8f9e5223cc3a
```

### 26.int 和long的互相转换

Java中数据转换很常见，提供两种方法，不推荐强制转化类型，亲测无用！

第一种：int returnId=new Long(a).intValue();

第二种：int returnId=Integer.parseInt(String.valueOf(a));





1.将long型转化为int型，这里的long型是基础类型：

long a = 10; int b = (int)a;
2.将Long型转换为int 型的，这里的Long型是包装类型：

Long a = 10; int b=a.intValue();
3.将Long型转换为 Integer 型的，这里的Long型是包装类型：

Long a = 10;; Integer b=a.intValue();
4.将int型转化为long型，这里的int型是基础类型：

int a = 10;long b = (int)a;
5.将Integer型转化为long型，这里的Integer型是包装类型：

int a = 10;Long b = a.longValue();
6.将Integer型转化为Long型，这里的Integer型是包装类型：

Long a = 10; Integer b=a.longValue();
总结：这里的转化就是要注意Java的八种基础数据类型以及八种包装数据类型的区别

基本类型和封装类的转换

Int转Integer: Integer integer = new Integer(int);
Integer转int: int i = integer.intValue();
Double转double: double b = Double.doubleValue();
Float转float: float c = Float.floatValue();
Java语言是一种强类型的语言。强类型的语言有以下几个要求：

（1） 变量或常量必须有类型，而且只能在声明以后才能使用；
（2） 赋值时类型必须一致，值的类型必须和变量或常量的类型完全一致；
（3） 运算时类型必须一致，参与运算的数据类型必须一致才能运算。
但在实际应用中，经常需要在不同类型的值之间进行操作，这时就需要进行数据类型的转换。
数据类型转换有两种：

（1） 自动类型转换：编译器自动完成类型转换，不需要在程序中编写代码；
规则：从存储范围小的类型到存储范围大的类型。
具体规则：byte→short(char)→int→long→float→double.
（2） 强制类型转换：强制编译器进行类型转换，必须在程序中编写代码。该类型转换很可能存在精度的损失。
规则：从存储范围大的类型到存储范围小的类型。
具体规则：double→float→long→int→short(char)→byte.
1.整形与字符型之间的数据类型转换：

一.int转换成char有两种方法：

① 是利用char的unicode编码
例：int num1 = 8;
char ch1 = (char) (num1 + 48);
二. char转换成int型

① 使用int的parseint方法
例： Character ch2 = ‘8’; （char是基本数据类型，Character是其包装类型。）
int num2 = Integer.parseInt(ch2.toString());
②是利用char的unicode编码
例：char ch3 = ‘8’;
int num3 = ch3 - 48;
2.基本数据类型与字符串之间的转换：

一. int转换成String

①.整型转换成字符型
String num = Integer.toString(int n);
②.Long型转换成字符型
String num = Long.toString(long n);
③.Short型转换成字符型
String num = Short.toString(Short n);
④.Float型转换成字符型
String num = Float.toString(Float n);
⑤.Double型转换成字符型
String num = Double.toString(Double n);

二. String转换成int

①.转换成Int型
int/Integer num = Integer.parseInt(String str);
②.转换成long型
Long/long num = Long.parseLong(String str);
③.转换成short型
short/Short num = Short.parseShort(String str);
④.转换成float型
float/Float num = Float.parseFloat(String str);
⑤.转换成double型
double/Double num = Double.parseDouble(String str);



### 27.位运算

#### 1.异或

在java的位运算符中有一个异或的运算符，用符号(^)表示，其运算规则是:在两个二进制操作数的相同位中，相同则结果为0，不同则结果为1。

例如：0011^1010 = 1001         2^3 = 其所对应二进制的10^11=01 = 1

异或运算有三个特征，一个是0与一个数做异或操作还是本身，本身与本身做异或操作为0，异或操作还满足交换率。

性质：

1. 交换律 可以任意交换运算因子，结果不变。
2. 结合律 （a^b）^c=a^(a^c)
3. 对于任何数x，都有x^x=0,x^0=x,同自己求异或运算为0，同0求异或运算结果为自己
4. 自反性，A^B^B=A^0=A。这个性质可以用来求哪一个数为一个

用法实例：

**例一：在不引入第三个变量的情况下，两个变量的值（整数）**

```java
//交换a、b的值
a=a^b
b=a^b
a=a^b
```

**例二：判断奇数偶数更简单更高效的做法**

```text
//这个实际考的不多， 太简单
//思路：奇数的二进制最低为一定为1，偶数的二进制最低位一定为0，
a^1==1?偶数：奇数
```

**例三：找出唯一一个成对的数**

> **题干：**1-1000这1000个数放在含有1001个元素的数组中，只有唯一的一个元素值重复，其它均只出现 一次。每个数组元素只能访问一次，设计一个算法，将它找出来；不用辅助存储空 间，能否设计一个算法实现？

第一种解题思路：将所有的数加起来减去（1+2+……+1000）。但是这个有可能导致内存溢出



```text
//第二种思路：
将所有的值异或运算，结果再与（1^2^3……^1000）异或运算
结果相当于（1^1^2^2……1000^1000^k）最终的结果就是k
```

**例题五：找出唯一落单的那个数字（也就是仅仅出现一次的那个数）**

```text
结果=a[0]^a[1]^...^a[n-1]
```

例题六：（难度增加）找出数组中落单的那两个数

> 题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。

```text
package test.nowcoder;

import java.util.ArrayList;
import java.util.List;

/**
 * @Autre beyond
 * @Data 2019/10/19
 * 这个案例相比之前，难度有所跨越，它综合运用到了几个知识：
 *
 * 异或运算
 * 相同的数在某位上一定相同
 * 朴素的分治，将数分为两类，再分别求解
 * 移位运算
 * 与运算：判断某位是否为0这也可以出个题了
 * 
 */
public class TowNumOdd {
    public static void main(String[] args) {
        int [] arr={1,2,3,3,4,4,5,6,5,6};
        //先求总的
        int n=0;
        int temp=0;
        for (int i = 0; i <arr.length ; i++) {
            temp^=arr[i];
        }

       while (true){
           if ((temp&(1<<n++))==1){
            break;
           }
       }
       /*这个得出N位为整数的第一个非0（即1）位的方法很巧妙：和1做按位与运算，如果位上为1结果为1，N求出；

如果位上为0则结果为0，将1移动到下一位继续判断*/

       // 循环最后多加了1
       n--;

        List<Integer> num1=new ArrayList<>();
        List<Integer> num2=new ArrayList<>();

        for (int i = 0; i <arr.length ; i++) {
            if ((arr[i]&(1<<n))==0) {
                num1.add(arr[i]);
            }else {
                num2.add(arr[i]);
            }
        }
        int arr1=0,arr2=0;
        for (int i = 0; i <num1.size() ; i++) {
            arr1^=num1.get(i);

        }
        for (int i = 0; i <num2.size() ; i++) {
            arr2^=num2.get(i);

        }
        System.out.println(arr1+"+"+arr2);

    }
}
```

例题七：找连续自然数中跑丢的两个数

> 题目为：给你1-1000个连续自然数，然后从中随机去掉两个，再打乱顺序，要求只遍历一次，求出被去掉的两个数。

思路和例题6一样了，先用（1^2^3...^1000）与去掉的异或运算，之后就可以用例题6计算了。

**例题八：(再次升级)找到落单的三个数**

> 一个数组中有三个数字a、b、c只出现一次，其他数字都出现了两次。请找出三个只出现一次的数字。

https://link.zhihu.com/?target=https%3A//lanqiao.coding.me/ref/TheThreeSingleNum

例九： 思考题：不用判断语句，求整数的绝对值

> 一般思考：正数返回本身，负数取反+1，但这涉及到判定数是正的还是负的
> 提示：带符号右移31位，正数变为0，负数变为-1（1111 1111 … 1111 1111），任何数和-1做“异或”运算相当于取反……只能说这么多了

```text
   public static void main(String[] args) {
      int number;
Scanner in = new Scanner(System.in);
 number = in.nextInt();
 /*
     * >> 右移,高位补符号位
     * >>> 无符号右移,高位补0
     * ^ 异或,相同为0,不同为1
     */
System.out.println(number + "的绝对值是:" + ((number^(number>>31))+(number>>31)));

    }
```





#### 2.补码、原码、反码

机器数
一个数在计算机中的表现形式叫做机器数，这个数有正负之分，在计算机中用一个数的最高位（符号位）用来表示它的正负，其中0表示正数，1表示负数。

例如正数7，在计算机中用一个8位的二进制数来表示，是00000111，而负数-7，则用10000111表示，这里的00000111和10000111是机器数

真数
计算机中的机器数对应的真实的值就是真数，对最高位（符号位）后面的二进制数转换成10进制，并根据最高位来确定这个数的正负。对于上面的00000111和10000111来说，对最高位后面的二进制数转换成10进制是7，在结合最高位的值，得出对应的真数分别是7和-7

原码
用第一位表示符号，其余位表示值。因为第一位是符号位，所以8位二进制数的取值范围就是：[1111_1111 , 0111_1111]  即 [-127 , 127] ,原码是容易被人脑所理解的表达方式

反码
正数的补码反码是其本身，负数的反码是符号位保持不变，其余位取反。例如正数1的原码是[0000_0001]，它的反码是是其本身

[0000_0001],-1的原码是[1000_0001],其反码是[1111_1110]

补码
正数的补码是其本身，负数的补码是在其反码的基础上+1，例如正数1的原码是[0000_0001],他的补码是其本身[0000_0001],

-1的补码是[1111_1111]

有了原码为什么要使用反码和补码
因为人脑可以知道第一位是符号位，可以根据符号位对真值的绝对值进行加减乘除，但是对于计算机来说，加减乘除是最最最基本的运算，要设计的尽量简单，计算机辨别符号位会让计算机的设计电路变得很复杂，于是人们想出了让符号位也参与到运算上来。减去一个数，等于加上他的负数。

从上面的原码表中可以看见左边每增加一个二进制单位对应的真数是递减的，而右边每增加一个二进制单位对应的真数是递增的，所以对于原码来说，能满足正数的加法，但无法满足负数的加法

2+1 = [0000_0010]原+[0000_0001]原=[0000_0011]原 = 3

1+-1=[0000_00001]原+[1000_0001]原=[1000_0010]原=-2

为了满足负数对加法的需求，就必须让负数与他对应的二进制码是同步递增或者同步递减

于是就通过符号位不变，其余位取反来满足这个同步递增或者递减的要求，由于正数本来就满足它本身的加法，所以不需要做任何改变。这就是反码的定义由来。

![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/20180403095015188)

从上图的反码表中可以看到在运算不跨过0的时候，正负数的加法已经能满足要求

-2+1=[1111_1101]反+[0000_0001]反=[1111_1110]反=-1

127+1=[1000_0000]反=-127=128 加法算出来是128，由于128超过最大值，余1，所以取最小值开始的第一位，也就是最小值-127，但是这里有个不合理的地方，就是[1111_1111]和[0000_0000]都表示0，这导致在实际计算中每当跨过0一次，就有一个单位的误差

-1+2=[1111_1110]反+[0000_0010]反=[0000_0000]反=0

要解决这个问题就必须让反码中的[1111_1111]和[0000_0000]合并，

由于[1111_1111]+[0000_0001]=[0000_0000],所以在负数反码的基础上+1就可以解决反码中跨0的误差问题，同时不会对负数与它对应的二进制反码的同步递增产生影响，所以在反码的基础上+1就完美的解决了符号参与预算的问题，这就是补码为什么是在负数反码的基础上+1的由来。

![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/20180403101055691)

从上面的图中发现还有一个[1000_0000]的二进制没有对应任何真数，于是就规定了这个数的真数是-128

所以补码的表示范围是[-128~127] ，这样一来256个二进制正好表示256个整数，在实际二进制的运算中超过范围其实就是对256的取余预算（x+128）mod 256 - 128。

https://blog.csdn.net/zl10086111/article/details/80907428?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.compare&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.compare

#### 3.使用位运算来实现两数的加法。

与&，按位或|， 按位异或^

![图片说明](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/284295_1588686434571_209BD4459BD002D912E85E54433CA4C4.png)

#### 

计算机中存整数n是用补码存的。

- 如果n为正数，则原码=反码=补码
- 如果n为负数，则补码=反码+1

本题是考察对位运算的运用，使用位运算来实现两数的加法。
设两数字的二进制形式 a，b ，其求和 s = a + b ，a(i) 代表 a 的二进制第 i 位，则分为以下四种情况：
![图片说明](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/284295_1588687181635_F1F0A0DAE581028E686FC568F55694CE.png) 

观察发现，无进位和运算就是按位异或结果，进位就是与运算结果但是需要左移一位，因为进位影响下一位的运算。
所以s = a + b,其实就是无进位和+进位的结果。
算法步骤：

1. 计算a和b的无进位和，和进位 
2. 如果进位不为0，则说明a+b的结果等于无进位和+进位，此时，把无进位和作为a，进位作为b，继续计算 
3. 如果进位等于0， 说明此时a+b的结果就等于无进位和，返回无进位和即可。
   如图：

![image-20200715155447856](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200715155447856.png)

Q：你可能有疑问，如果是一个数为负数或者两个数都为负数怎么办？
A：上述补码的介绍，补码就是解决减法的问题，计算机把减法看做加法来运算。
所以代码如下：







1.解题思路

**使用位运算实现加法**

**1、一位加法**

| 普通加法  | 异或            |
| --------- | --------------- |
| 1 + 1 = 0 | 1 ^ 1 = 0(错误) |
| 1 + 0 = 1 | 1 ^ 0 = 1(正确) |
| 0 + 1 = 1 | 0 ^ 1 = 1(正确) |
| 0 + 0 = 0 | 0 ^ 0 = 0(正确) |

**问题**：没有采取进位操作导致**运算错误**

**难点：如何解决进位问题？**

|      与运算       |
| :---------------: |
|  1 & 1 = 1(进位)  |
| 1 & 0 = 0(不进位) |
| 0 & 1 = 0(不进位) |
| 0 & 0 = 0(不进位) |



#### 3、二位加法

例子：

- **正确的加法计算：11+01 = 100 **
- 使用位运算实现二位加法：
  1. 按位加法： res1 = 11 ^ 01 = 10
  2. 与运算进位： res2 = (11 & 01) << 1 = ( 01 ) << 1 = 010
  3. res1 ^ res2 = 10 ^ 010 = 00
  4. (10 & 10) << 1 = 100

```
  ``# write code here
    ``# 由于题目要求不能使用四则运算，那么就需要考虑使用位运算
    ``# 两个数相加可以看成两个数的每个位先相加，但不进位，然后在加上进位的数值
    ``# 如12+8可以看成1+0=1 2+8=0，由于2+8有进位，所以结果就是10+10=20
    ``# 二进制中可以表示为1000+1100 先每个位置相加不进位，
    ``# 则0+0=0 0+1=1 1+0=1 1+1=0这个就是按位异或运算
    ``# 对于1+1出现进位，我们可以使用按位与运算然后在将结果左移一位
    ``# 最后将上面两步的结果相加，相加的时候依然要考虑进位的情况，直到不产生进位
    ``# 注意python没有无符号右移操作，所以需要越界检查
    ``# 按位与运算：相同位的两个数字都为1，则为1；若有一个不为1，则为0。
    ``# 按位异或运算：相同位不同则为1，相同则为0。
```



  

 ![image-20200715163446231](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200715163446231.png)

#### 4、更高位的加法

继续推理可以得出三位数的加法只需重复的计算三次得到第一个表达式的值就是计算出来的结果

**三位加法：**

1. 101 ^ 111 = 0010 （没有处理进位的加法）
   (101 & 111) << 1 = 101 << 1 = 1010 （此处得到哪一位需要加上进位，为1的地方表示有进位需要加上）

2. 0010 ^ 1010 = 1000 （没有处理进位的加法 + 进位 = 没有处理进位的加法）

   (0010 & 1010) << 1 = 0010 << 1 = 00100 （查看是否有新的进位需要处理）

3. 1000 ^ 00100 （没有处理进位的加法 + 进位 = 没有处理进位的加法）

   (1000 & 00100) << 1 = 00000 << 1 = 000000 (进位为0，所以没有要处理的进位了)

**更高位加法：依上边类推**







#### 4.&和&&、|和||的异同

对于boolean类型的数据，&和&&，|和||的计算结果相同。但是这里有一处区别，按位与和按位或需要操作计算两个二进制的计算结果。但是如果是逻辑或，逻辑与，会有短路效应。可能只需要根据其中一个条件就可以判断了，例如true||false只需要判断前面一个就可以了，false&&false就只需要判断前面一个就知道为false。


#### 5.移位运算

（1）左 移 （<< ）

 右边空出的位用0填补高位左移溢出则舍弃该高位。计算机中常用补码表示数据，注，用补码计算

 ![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1112483-20190912170932750-948680241.png)   ![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1112483-20190912170944666-601313514.png)

（2）右 移 （>> ）

 左边空出的位用0或者1填补。正数用0填补，负数用1填补。注：不同的环境填补方式可能不同；低位右移溢出则舍弃该位。

 ![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1112483-20190912171001429-2521138.png)    ![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1112483-20190912171016064-1735059802.png)

（3）无 符 号 右 移 （>>> ）

 无符号右移：正数与右移规则一样，负数的无符号右移，就是相应的补码移位所得，在高位补0即可

 ![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1112483-20190912171040650-1120700197.png)    

![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1112483-20190912171053324-1758971811.png)

```
<<      :    左移运算符，num <<1,相当于num乘以2

>>      :    右移运算符，num >>1,相当于num除以2

>>>    :    无符号右移，忽略符号位，空位都以0补齐，（计算机中数字以补码存储，首位为符号位）。

如：a  =  00110111，则a>>2    = 00001101，b=11010011，则b>>2   =  11110100；  

如：a  =  00110111，则a>>>2  = 00001101，b=11010011，则b>>>2 =  00110100。



//Integer.toBinaryString()是将数字用二进制格式显示
	int i = -10;
	System.out.println(Integer.toBinaryString(i));
	//左移两位
	int j = -10<<2;
	System.out.println(Integer.toBinaryString(j));
	//右移两位
	int m = -10>>2;
	System.out.println(Integer.toBinaryString(m));
	//无符号右移
	int n = -10>>>2;
	System.out.println(Integer.toBinaryString(n));
	
11111111111111111111111111110110
11111111111111111111111111011000
11111111111111111111111111111101
111111111111111111111111111101（省略了首位两个0）
```

#### 6.Integer.bitCount()理解

bitCount实现的功能是计算一个（byte,short,char,int统一按照int方法计算）int,long类型的数值在二进制下“1”的数量。



#### 7.[byte为什么要&上0xff？](https://www.cnblogs.com/think-in-java/p/5527389.html)

**Integer.toHexString(b & 0xff)**（b是byte类型的）

这个方法是把字节（转换成了int）以16进制的方式显示。

（经过百度）int本身就是由4组byte组成，并且Java中本身就以byte读取。所以此处传参没有问题。

toHexString(b & 0xff)相当于做了一次位的与运算，将前24位字符省略，将后8位保留。即只转了后8位。即可得到两个十六进制的值。

记得在学计算机原理的时候，了解到计算机内的存储都是利用二进制的补码进行存储的。

复习一下，原码反码补码这三个概念

对于正数（00000001）原码来说，首位表示符号位，反码 补码都是本身

对于负数（100000001）原码来说，反码是对原码除了符号位之外作取反运算即（111111110），补码是对反码作+1运算即（111111111）

概念就这么简单。

 但是我做byte->int的转化 所有时候都只是为了保持 十进制的一致性吗？

不一定吧？好比我们拿到的文件流转成byte数组，难道我们关心的是byte数组的十进制的值是多少吗？我们关心的是其背后二进制存储的补码吧

所以大家应该能猜到为什么byte类型的数字要&0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。

当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性。

当然拉，保证了二进制数据性的同时，如果二进制被当作byte和int来解读，其10进制的值必然是不同的，因为符号位位置已经发生了变化。

 

象例2中，int c = a[0]&0xff;  a[0]&0xff=1111111111111111111111111 10000001&11111111=000000000000000000000000 10000001 ，这个值算一下就是129，

所以c的输出的值就是129。有人问为什么上面的式子中a[0]不是8位而是32位，因为当系统检测到byte可能会转化成int或者说byte与int类型进行运算的时候，就会将byte的内存空间高位补1（也就是按符号位补位）扩充到32位，再参与运算。上面的0xff其实是int类型的字面量值，所以可以说byte与int进行运算。

当将-127赋值给a[0]时候，a[0]作为一个byte类型，其计算机存储的补码是10000001（8位）。

将a[0] 作为int类型向控制台输出的时候，jvm作了一个补位的处理，因为int类型是32位所以补位后的补码就是1111111111111111111111111 10000001（32位），这个32位二进制补码表示的也是-127.

发现没有，虽然byte->int计算机背后存储的二进制补码由10000001（8位）转化成了1111111111111111111111111 10000001（32位）很显然这两个补码表示的十进制数字依然是相同的。

但是我做byte->int的转化 所有时候都只是为了保持 十进制的一致性吗？

不一定吧？好比我们拿到的文件流转成byte数组，难道我们关心的是byte数组的十进制的值是多少吗？我们关心的是其背后二进制存储的补码吧

所以大家应该能猜到为什么byte类型的数字要&0xff再赋值给int类型，其本质原因就是想保持二进制补码的一致性。

当byte要转化为int的时候，高的24位必然会补1，这样，其二进制补码其实已经不一致了，&0xff可以将高的24位置为0，低8位保持原样。这样做的目的就是为了保证二进制数据的一致性。

当然拉，保证了二进制数据性的同时，如果二进制被当作byte和int来解读，其10进制的值必然是不同的，因为符号位位置已经发生了变化。

 

象例2中，int c = a[0]&0xff;  a[0]&0xff=1111111111111111111111111 10000001&11111111=000000000000000000000000 10000001 ，这个值算一下就是129，

所以c的输出的值就是129。有人问为什么上面的式子中a[0]不是8位而是32位，因为当系统检测到byte可能会转化成int或者说byte与int类型进行运算的时候，就会将byte的内存空间高位补1（也就是按符号位补位）扩充到32位，再参与运算。上面的0xff其实是int类型的字面量值，所以可以说byte与int进行运算。

### 28.java的LinkList常用方法

https://www.cnblogs.com/LiaHon/p/11107245.html

https://blog.csdn.net/qedgbmwyz/article/details/80108618

**LinkedList类中定义了三个变量**

> size：集合的长度
>
> first：双向链表头部节点
>
> last：双向链表尾部节点

针对first变量和last变量，我们看到是Node类的实体，这是一个静态内部类，关于静态内部类的讲解，我们在[static五大应用场景](https://www.cnblogs.com/LiaHon/p/11075178.html)一章已经有说明

```java
private static class Node<E> {
    E item;
    Node<E> next;
    Node<E> prev;
    Node(Node<E> prev, E element, Node<E> next) {
        this.item = element;
        this.next = next;
        this.prev = prev;
    }
}
```

我们知道LinkedList是通过双向链表实现的，而双向链表就是通过Node类来体现的，类中通过item变量保存了当前节点的值，通过next变量指向下一个节点，通过prev变量指向上一个节点。

#### 二. LinkedList常用方法

#### 1. get(int index)

我们知道随机读取元素不是LinkedList所擅长的，读取效率比起ArrayList也低得多，那么我来看一下为什么

```java
public E get(int index) {
    checkElementIndex(index);
    return node(index).item;
}

/**
 * 返回一个指定索引的非空节点.
 */
Node<E> node(int index) {
    // assert isElementIndex(index);

    if (index < (size >> 1)) {
        Node<E> x = first;
        for (int i = 0; i < index; i++)
            x = x.next;
        return x;
    } else {
        Node<E> x = last;
        for (int i = size - 1; i > index; i--)
            x = x.prev;
        return x;
    }
}
```

从上述代码中我们可以看到get(int index)方法是通过node(int index)来实现的，它的实现机制是：

比较传入的索引参数index与集合长度size/2，如果是index小，那么从第一个顺序循环，直到找到为止；如果index大，那么从最后一个倒序循环，直到找到为止。也就是说越靠近中间的元素，调用get(int index方法遍历的次数越多，效率也就越低，而且随着集合的越来越大，get(int index)执行性能也会指数级降低。因此在使用LinkedList的时候，我们不建议使用这种方式读取数据，可以使用**getFirst()，getLast()**方法，将直接用到类中的first和last变量。

#### 2. add(E e) 和 add(int index, E element)

大家都在说LinkedList插入、删除操作效率比较高，以stringList.add(“猪八戒”)为例来看到底发生了什么？

在LinkedList中我们找到add(E e)方法的源码

```java
public boolean add(E e) {
    linkLast(e);
    return true;
}

/**
 * 设置元素e为最后一个元素
*/
void linkLast(E e) {
    final Node<E> l = last;
    final Node<E> newNode = new Node<>(l, e, null);
    last = newNode;
    if (l == null)
        first = newNode;
    else
        l.next = newNode;
    size++;
    modCount++;
}
```

很好理解：

情况1：假如stringList为空，那么添加进来的node就是first，也是last，这个node的prev和next都为null;

![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1677914-20190629172301085-1570355202.png)

情况2：假如stringList不为空，那么添加进来的node就是last，node的prev指向以前的最后一个元素，node的next为null；同时以前的最后一个元素的next.

![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1677914-20190629172320084-727843647.png)

而如果通过stringList.add(1, “猪八戒”)这种方式将元素添加到集合中呢？

```java
//在指定位置添加一个元素
public void add(int index, E element) {
    checkPositionIndex(index);
    if (index == size)
        linkLast(element);
    else
        linkBefore(element, node(index));
}

/**
 * 在一个非空节点前插入一个元素
 */
void linkBefore(E e, Node<E> succ) {
    // assert succ != null;
    final Node<E> pred = succ.prev;
    final Node<E> newNode = new Node<>(pred, e, succ);
    succ.prev = newNode;
    if (pred == null)
        first = newNode;
    else
        pred.next = newNode;
    size++;
    modCount++;
}
```

其实从代码中看到和add(E e)的代码实现没有本质区别，都是通过新建一个Node实体，同时指定其prev和next来实现，不同点在于需要调用node(int index)通过传入的index来定位到要插入的位置，这个也是比较耗时的，参考上面的get(int index)方法。

其实看到这里，大家也都明白了。

> LinkedList插入效率高是相对的，因为它省去了ArrayList插入数据可能的数组扩容和数据元素移动时所造成的开销，但数据扩容和数据元素移动却并不是时时刻刻都在发生的。

#### 3. remove(Object o) 和 remove(int index)

这里removeFirst()和removeLast()就不多说了，会用到类中定义的first和last变量，非常简单，我们看一下remove(Object o) 和 remove(int index)源码

```java
//删除某个对象
public boolean remove(Object o) {
    if (o == null) {
        for (Node<E> x = first; x != null; x = x.next) {
            if (x.item == null) {
                unlink(x);
                return true;
            }
        }
    } else {
        for (Node<E> x = first; x != null; x = x.next) {
            if (o.equals(x.item)) {
                unlink(x);
                return true;
            }
        }
    }
    return false;
}
//删除某个位置的元素
public E remove(int index) {
    checkElementIndex(index);
    return unlink(node(index));
}
//删除某节点，并将该节点的上一个节点（如果有）和下一个节点（如果有）关联起来
E unlink(Node<E> x) {
    final E element = x.item;
    final Node<E> next = x.next;
    final Node<E> prev = x.prev;

    if (prev == null) {
        first = next;
    } else {
        prev.next = next;
        x.prev = null;
    }

    if (next == null) {
        last = prev;
    } else {
        next.prev = prev;
        x.next = null;
    }

    x.item = null;
    size--;
    modCount++;
    return element;
}
```

其实实现都非常简单，先找到要删除的节点，remove(Object o)方法遍历整个集合，通过 == 或 equals方法进行判断；remove(int index)通过node(index)方法。

![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/1677914-20190629172337033-933154031.png)

#### 4. LinkedList遍历

我们主要列举一下三种常用的遍历方式，

普通for循环，增强for循环，Iterator迭代器

```java
public static void main(String[] args) {
    LinkedList<Integer> list = getLinkedList();
    //通过快速随机访问遍历LinkedList
    listByNormalFor(list);
    //通过增强for循环遍历LinkedList
    listByStrengThenFor(list);
    //通过快迭代器遍历LinkedList
    listByIterator(list);
}

/**
 * 构建一个LinkedList集合,包含元素50000个
 * @return
 */
private static LinkedList<Integer> getLinkedList() {
    LinkedList list = new LinkedList();
    for (int i = 0; i < 50000; i++){
        list.add(i);
    }
    return list;
}

/**
 * 通过快速随机访问遍历LinkedList
 */
private static void listByNormalFor(LinkedList<Integer> list) {
    // 记录开始时间
    long start = System.currentTimeMillis();
    int size = list.size();
    for (int i = 0; i < size; i++) {
        list.get(i);
    }
    // 记录用时
    long interval = System.currentTimeMillis() - start;
    System.out.println("listByNormalFor：" + interval + " ms");
}

/**
 * 通过增强for循环遍历LinkedList
 * @param list
 */
public static void listByStrengThenFor(LinkedList<Integer> list){
    // 记录开始时间
    long start = System.currentTimeMillis();
    for (Integer i : list) { }
    // 记录用时
    long interval = System.currentTimeMillis() - start;
    System.out.println("listByStrengThenFor：" + interval + " ms");
}

/**
 * 通过快迭代器遍历LinkedList
 */
private static void listByIterator(LinkedList<Integer> list) {
    // 记录开始时间
    long start = System.currentTimeMillis();
    for(Iterator iter = list.iterator(); iter.hasNext();) {
        iter.next();
    }
    // 记录用时
    long interval = System.currentTimeMillis() - start;
    System.out.println("listByIterator：" + interval + " ms");
}
```

执行结果如下：

```java
listByNormalFor：1067 ms
listByStrengThenFor：3 ms
listByIterator：2 ms
```

通过普通for循环随机访问的方式执行时间远远大于迭代器访问方式，这个我们可以理解，在前面的get(int index)方法中已经有过说明，那么为什么增强for循环能做到迭代器遍历差不多的效率？

通过反编译工具后得到如下代码

```java
public static void listByStrengThenFor(LinkedList<Integer> list)
  {
    long start = System.currentTimeMillis();
    Integer localInteger;
    for (Iterator localIterator = list.iterator(); localIterator.hasNext(); 
         localInteger = (Integer)localIterator.next()) {}
    long interval = System.currentTimeMillis() - start;
    System.out.println("listByStrengThenFor：" + interval + " ms");
}
```

很明显了，增强for循环遍历时也调用了迭代器Iterator，不过多了一个赋值的过程。

还有类似于pollFirst()，pollLast()取值后删除的方法也能达到部分的遍历效果。

#### 三. 总结

本文基于java8从定义一个LinkList入手，逐步展开，从源码角度分析LinkedList双向链表的结构是如何构建的，同时针对其常用方法进行分析，包括get，add，remove以及常用的遍历方法，并简单的说明了它的插入、删除操作为何相对高效，而取值操作性能相对较低，若有不对之处，请批评指正，望共同进步，谢谢！



### 29.平衡二叉树

**平衡二叉树**：是一种特殊的[二叉排序树](https://blog.csdn.net/lishanleilixin/article/details/88394031)，其中每一个节点的左子树和右子树的高度差至多等于1。从平衡二叉树的名字中可以看出来，它是一种高度平衡的二叉排序树。那么什么叫做高度平衡呢？意思就是要么它是一颗空树，要么它的左子树和右子树都是平衡二叉树，且左子树和右子树的深度只差的绝对值绝对不超过1。
**平衡因子**：将二叉树上节点的左子树深度减去右子树深度的值称为平衡因子BF。则平衡二叉树上所有节点的平衡因子只可能是**1，-1，0**。
只要二叉树上有一个节点的平衡因子的绝对值大于1，那么该二叉树就是不平衡的。
**最小不平衡子树**：距离插入节点最近的，且平衡因子的绝对值大于1的节点为根的子树，我们称之为最小不平衡子树。

#### AVL树的定义

平衡二叉树也叫AVL树。AVL树得名于它的发明者G.M.Adelson-Velsky和E.M.Landis，他们在1962年的论文"Analgorithm for the organization of information"中发表了它。

平衡二叉树是具有以下性质的二叉查找树：对于树中的任意一个结点，都有该结点的左子树的高度与右子树的高度之差的绝对值小于2。与普通的BST相比，AVL树只是多定义了旋转操作，使得当左右子树的高度差的绝对值大于或者等于2时，平衡树可以自动地进行树形调整，以重新满足上述性质。

#### 平衡二叉树的构建

节点定义
平衡二叉树节点数据结构和二叉排序树相差不大：

public class AVLNode {

	public AVLNode parent;
	public AVLNode leftChild, rightChild;
	public int data;
	
	public AVLNode(AVLNode parent, AVLNode leftChild, AVLNode rightChild, int data) {
		this.parent = parent;
		this.leftChild = leftChild;
		this.rightChild = rightChild;
		this.data = data;
	}
	
	public AVLNode(int data) {
		this(null, null, null, data);
	}
	
	public AVLNode(AVLNode parent, int data) {
		this.parent = parent;
		this.data = data;
	}

}
————————————————
版权声明：本文为CSDN博主「李闪磊」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/lishanleilixin/article/details/88538491



#### 插入数据

很多参考书上对AVL树的讲解过于复杂，这里，我们会充分简化这个过程，读者只要记住两副简单的图和一句口诀就可以完全理解平衡二叉树，切不可死记硬背。

先定义一个专用名称，平衡因子。每个结点的平衡因子就是该结点的左子树的高度减去右子树的高度，平衡二叉树的每个结点的平衡因子的绝对值不会超过2。接下来，看两个实际的例子，考虑顺序向二叉查找树中插入数据5,3,6,2,4,1，所得到的二叉查找树的形状如图 2.12(a) 所示。对于数据为 5 的这个结点，它的左子树高度与右子树高度之差为 2，我们可以通过改变5号结点和3号结点的相关指针将其变为如图 2.12(b) 所示的形状。由于3号结点的右孩子指针指向了5号结点，4号结点暂时脱离了二叉树，但注意到5号结点的左孩子指针变为空，我们可以将4号结点挂在5号结点的左孩子上，得到如图 2.12(c) 。这样，整棵树还继续满足平衡二叉树的性质。这个操作就像把树像旋纽一样向右旋转了下，我们把这个操作形象地称为右旋。右旋的口诀可以简单总结为“左子作父，父为右子，右孙变左孙”。由此可见，右旋操作的效果是原来的右孩子的深度(注意不是高度)加1，左孙的深度减1，而右孙的深度不变。而左旋的情况与右旋互为镜像，不再赘述。

![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/v2-d2ef851ea324d868d25edc2545274e2a_720w.png)

如果插入的顺序变成了5,2,6,1,3,4，所得到的二叉查找树的形状则如图 2.13(a) 所示。此时，5号结点的左子树与右子树的高度差仍然为2，这时再执行右旋行不行呢？我们可以尝试着做一下，右旋的结果如图 2.13(b) 所示，这时，新的树根2号结点的平衡因子为-2，显然直接右旋并没有使树重新平衡。这是因为右旋时右孙变左孙以后，深度没有变化，而显然造成树不平衡的主要原因在于右孙3号结点的深度过大。为了解决这个问题，尝试把它转化为第一个例子，就是对2号结点进行一次左旋，得到图 2.13(c) 。这样会使得右孙的深度转移到左孙。现在树的形状与上例相同了，再对这棵树进行右旋操作，会使得左孙深度减1，右孙不变。得到新的树是满足平衡二叉树的性质的，如图 2.13(d) 。

![img](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/v2-0708ce8200e5b9d8bf925abba8ddbe8b_720w.png)

通过上面的两个例子，我们可以找出规律了。当向一棵平衡二叉树中插入一个新的结点时，有可能会使得某个结点的子树高度发生变化，从而影响了这个结点的平衡因子。当该结点的平衡因子为2时，就应该考虑对该点执行右旋操作。在执行右旋之前，还要检查一下左子树上的左孙和右孙的高度，如果是左孙的高度比较大，那么直接右旋就可以重新平衡，如果是右孙的高度比较大，那么就要在左孩子结点上先执行一次左旋。(请读者想一下，如果某个结点的平衡因子为2，那么它的左孩子结点的平衡因子可能为0吗？为什么？)

#### 插入删除完整代码

```java
package 平衡二叉树;

import java.util.LinkedList;
import java.util.Queue;

public class MyAVLTree {

	private AVLNode root;
	private final int LEFT = 1;
	private final int RIGHT = -1;
	private final int MAX_LEFT = 2;
	private final int MAX_RIGHT = -2;
	
	/**
	 * 插入节点
	 * @param data
	 */
	public void put(int data) {
		putData(root, data);
	}
	
	private boolean putData(AVLNode node, int data) {
		if(node == null) {
			node  = new AVLNode(data);
			root = node;
			return true;
		}
		int t;
		AVLNode p;
		AVLNode temp = node;
		do {
			p = temp;
			t = temp.data - data;
			if(t < 0) {
				temp = temp.rightChild;
			}
			else if(t > 0) {
				temp = temp.leftChild;
			}
			else {
				return false;
			}
		} while(temp != null);
		
		if(t < 0) {
			p.rightChild = new AVLNode(p, data);
		}
		else if(t > 0) {
			p.leftChild = new AVLNode(p, data);
		}
		rebuild(p);
		return true;
		
	}
	
	/**
	 * 平衡二叉树的方法
	 * @param node
	 */
	public void rebuild(AVLNode node) {
		while(node != null) {
			if(calcNodeBalanceValue(node) == MAX_LEFT) {
				fixAfterInsertion(node, LEFT);
			}
			else if(calcNodeBalanceValue(node) == MAX_RIGHT) {
				fixAfterInsertion(node, RIGHT);
			}
			node = node.parent;
		}
	}
	
	
	/**
	 * 调整树的结构
	 * @param node
	 * @param type
	 */
	public void fixAfterInsertion(AVLNode node, int type) {
		if(type == LEFT) {
			AVLNode leftChild = node.leftChild;
			if(leftChild.leftChild != null) {  //右旋
				rightRotation(node);
			}
			else if(leftChild.rightChild != null) {   //左右旋
				leftRotation(leftChild);
				rightRotation(node);
			}
		}
		else if(type == RIGHT) {
			AVLNode rightChild = node.rightChild;
			if(rightChild.rightChild != null) {   //左旋
				leftRotation(node);
			}
			else if(rightChild.leftChild != null) {   //右左旋
				rightRotation(rightChild);
				leftRotation(node);
			}
		}
	}
	
	
	/**
	 * 右旋
	 * @param node
	 * @return
	 */
	public AVLNode rightRotation(AVLNode node) {
		if(node != null) {
			
			AVLNode leftChild = node.leftChild;
			node.leftChild = leftChild.rightChild;
			// 如果leftChild的右节点存在，则需将该右节点的父节点指给node节点
			if(leftChild.rightChild != null) {  
				leftChild.rightChild.parent = node;
			}
			leftChild.parent = node.parent;
			if(node.parent == null) {
				this.root = leftChild;
			}
			else if(node.parent.rightChild == node) {  // 即node节点在它原父节点的右子树中
				node.parent.rightChild = leftChild;
			}
			else if(node.parent.leftChild == node) {
				node.parent.leftChild = leftChild;
			}
			
			leftChild.rightChild = node;
			node.parent = leftChild;
			return leftChild;
		}
		
		return null;
	}
	
	/**
	 * 左旋
	 * @param node
	 * @return
	 */
	public AVLNode leftRotation(AVLNode node) {
		
		if(node != null) {
			AVLNode rightChild = node.rightChild;
			node.rightChild = rightChild.leftChild;
			if(rightChild.leftChild != null) {
				rightChild.leftChild.parent = node;
			}
			rightChild.parent = node.parent;
			if(node.parent == null) {
				this.root = rightChild;
			}
			else if(node.parent.rightChild == node) {
				node.parent.rightChild = rightChild;
			}
			else if(node.parent.leftChild == node) {
				node.parent.leftChild = rightChild;
			}
			rightChild.leftChild = node;
			node.parent = rightChild;
			return rightChild;
		}
		
		return null;
	}
	
	/**
	 * 计算node节点的BF值
	 * @param node
	 * @return
	 */
	public int calcNodeBalanceValue(AVLNode node) {
		if(node != null) {
			return getHeightByNode(node);
		}
		return 0;
	}
	
	private int getHeightByNode(AVLNode node) {
		if(node == null) {
			return 0;
		}
		return getChildDepth(node.leftChild) - getChildDepth(node.rightChild);
	}
	
	private int getChildDepth(AVLNode node) {
		if(node == null) {
			return 0;
		}
		return 1 + Math.max(getChildDepth(node.leftChild), getChildDepth(node.rightChild));
	}
	
	
	/**
	 * 中序遍历
	 */
	public void middOrderErgodic() {
		this.middOrderErgodic(this.root);
	}
	public void middOrderErgodic(AVLNode node) {
		if(node != null) {
			this.middOrderErgodic(node.leftChild);
			System.out.print(node.data + ", ");
			this.middOrderErgodic(node.rightChild);
		}
	}
	
	
	/**
	 * 删除指定val值的节点
	 * @param val
	 * @return
	 */
	public boolean delete(int val) {
		AVLNode node = getNode(val);
		if(node == null) {
			return false;
		}
		boolean flag = false;
		AVLNode p = null;
		AVLNode parent = node.parent;
		AVLNode leftChild = node.leftChild;
		AVLNode rightChild = node.rightChild;
		if(leftChild == null && rightChild == null) {
			if(parent != null) {
				if(parent.leftChild == node) {
					parent.leftChild = null;
				}
				else if(parent.rightChild == node) {
					parent.rightChild = null;
				}
			}
			else {
				this.root = null;
			}
			
			p = parent;
			node = null;
			flag = true;
		}
		else if(leftChild == null && rightChild != null) {
			if(parent != null && parent.data > val) {
				parent.leftChild = rightChild;
			}
			else if(parent != null && parent.data < val) {
				parent.rightChild = rightChild;
			}
			else {
				this.root = rightChild;
			}
			p = parent;
			node = null;
			flag = true;
		}
		else if(leftChild != null && rightChild == null) {
			if(parent != null &&  parent.data > val) {
				parent.leftChild = leftChild;
			}
			else if(parent != null && parent.data < val) {
				parent.rightChild = leftChild;
			}
			else {
				this.root = leftChild;
			}
			
			p = parent;
			node = null;
			flag = true;
		}
		else if(leftChild != null && rightChild != null) {
			AVLNode successor = getSuccessor(node);
			int tempData = successor.data;
			if(delete(tempData)) {
				node.data = tempData;
			}
			p = successor;
			successor = null;
			flag = true;
		}
		
		if(flag) {
			this.rebuild(p);
		}
		return flag;	
	}
	
	
	/**
	 * 获得指定节点
	 * @param key
	 * @return
	 */
	public AVLNode getNode(int key) {
	
		AVLNode node = root;
		int t;
		do {
			t = node.data - key;
			if(t > 0) {
				node = node.leftChild;
			}
			else if(t < 0) {
				node = node.rightChild;
			}
			else {
				return node;
			}
		} while(node != null);
		return null;
	}
	
	
	/***
	 * 获得指定节点的后继
	 * 找到node节点的后继节点
     * 1、先判断该节点有没有右子树，如果有，则从右节点的左子树中寻找后继节点，没有则进行下一步
     * 2、查找该节点的父节点，若该父节点的右节点等于该节点，则继续寻找父节点，
     *   直至父节点为Null或找到不等于该节点的右节点。
     * 理由，后继节点一定比该节点大，若存在右子树，则后继节点一定存在右子树中，这是第一步的理由
     *      若不存在右子树，则也可能存在该节点的某个祖父节点(即该节点的父节点，或更上层父节点)的右子树中，
     *      对其迭代查找，若有，则返回该节点，没有则返回null
	 * @param node
	 * @return
	 */
	public AVLNode getSuccessor(AVLNode node) {
		if(node.rightChild != null) {
			AVLNode rightChild=  node.rightChild;
			while(rightChild.leftChild != null) {
				rightChild = rightChild.leftChild;
			}
			return rightChild;
		}
		AVLNode parent = node.parent;
		while(parent != null && (node == parent.rightChild)) {
			node = parent;
			parent = parent.parent;
		}
		return parent;
	}
	
	
	/**
	 * 层序遍历
	 */
	public void sequenceErgodic() {
		if(this.root == null) {
			return;
		}
		Queue<AVLNode> queue = new LinkedList<>();
		AVLNode temp = null;
		queue.add(this.root);
		while(!queue.isEmpty()) {
			temp = queue.poll();
			System.out.println("当前节点值：" + temp.data + ", BF：" + calcNodeBalanceValue(temp));
			if(temp.leftChild != null) {
				queue.add(temp.leftChild);
			}
			if(temp.rightChild != null) {
				queue.add(temp.rightChild);
			}
		}
	}
	
	public static void main(String[] args) {
		MyAVLTree bbt = new MyAVLTree();
        bbt.put(3);
        bbt.put(2);
        bbt.put(1);
        bbt.put(4);
        bbt.put(5);
        bbt.put(6);
        bbt.put(7);
        bbt.put(10);
        bbt.put(9);
        bbt.middOrderErgodic();
        System.out.println();
        System.out.println("-----各节点平衡状况-----");
        bbt.sequenceErgodic();
        System.out.println();
        bbt.delete(5);
        bbt.delete(2);
        bbt.middOrderErgodic();
        System.out.println();
        System.out.println("-----各节点平衡状况-----");
        bbt.sequenceErgodic();
        System.out.println();
        
	}
}


```

#### 判断是不是平衡二叉树：

 **解法：** 
思路1：从根节点开始，求出根的左右子树的高度，如果根的左右子树的高度差大于1，返回FALSE，否则递归的判断根的左子树和右子树是否满足条件。



```java
   class TreeNode{
    int val;
    TreeNode left=null; 
    TreeNode right=null;
    public TreeNode(int val) {
        this.val = val;
    }
}

public boolean IsBalanced_Solution(TreeNode root) {         
         if(root==null)
             return true;
//如果树为 null 返回 TRUE。否则判断根的左右子树的高度差的绝对值是否大于1，若大于1 则返回false。
// 否则判断树的左右孩子是否是平衡二叉树，当两者都是平衡二叉树时返回TRUE，否则返回false.
         else if(Math.abs(TreeDepth(root.left)-TreeDepth(root.right))>1)
             return false;
         else return IsBalanced_Solution(root.left)&&IsBalanced_Solution(root.right);

}
    //求树的深度。
 public int TreeDepth(TreeNode root)
 {
     if(root==null)
         return 0;
         //如果树为 null 返回0 否则返回左右孩子的最大值+1。
     return Math.max(TreeDepth(root.left), TreeDepth(root.right))+1;
 
 }
```

### 30.collection以及Arrays工具类、比较器

#### String的compareTo() 方法

compareTo() 方法用于两种方式的比较：

- 字符串与对象进行比较。
- 按字典顺序比较两个字符串。

语法

int compareTo(Object o)  或  int compareTo(String anotherString)

参数

- **o** -- 要比较的对象。
- **anotherString** -- 要比较的字符串。

返回值

返回值是整型，它是先比较对应字符的大小(ASCII码顺序)，如果第一个字符和参数的第一个字符不等，结束比较，返回他们之间的**差值**，如果第一个字符和参数的第一个字符相等，则以第二个字符和参数的第二个字符做比较，以此类推,直至比较的字符或被比较的字符有一方结束。

- 如果参数字符串等于此字符串，则返回值 0；
- 如果此字符串小于字符串参数，则返回一个小于 0 的值；
- 如果此字符串大于字符串参数，则返回一个大于 0 的值。

实例

```
public class Test {
 
    public static void main(String args[]) {
        String str1 = "Strings";
        String str2 = "Strings";
        String str3 = "Strings123";
 
        int result = str1.compareTo( str2 );
        System.out.println(result);
      
        result = str2.compareTo( str3 );
        System.out.println(result);
     
        result = str3.compareTo( str1 );
        System.out.println(result);
    }
}
```

以上程序执行结果为：

```
0
-3
3
```

![image-20200717233735615](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200717233735615.png)

https://blog.csdn.net/qq_25827845/article/details/53870329?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.nonecase

#### 一、Comparable和Comparator的详解

Comparable & Comparator 都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序，所以，如想实现排序，就需要在集合外定义 Comparator 接口的方法或在集合内实现 Comparable 接口的方法。

##### （1）Comparable（内比较器）

Comparable可以认为是一个内比较器，实现了Comparable接口的类有一个特点，就是这些类是可以和自己比较的，至于具体和另一个实现了Comparable接口的类如何比较，则依赖compareTo方法的实现，compareTo方法也被称为自然比较方法。如果开发者add进入一个Collection的对象想要Collections的sort方法帮你自动进行排序的话，那么这个对象必须实现Comparable接口。compareTo方法的返回值是int，有三种情况：

1、比较者大于被比较者（也就是compareTo方法里面的对象），那么返回正整数

2、比较者等于被比较者，那么返回0

3、比较者小于被比较者，那么返回负整数

```
 public class Domain implements Comparable<Domain>
{
    private String str;
public Domain(String str)
{
    this.str = str;
}
public int compareTo(Domain domain)
{
    if (this.str.compareTo(domain.str) > 0)
        return 1;
    else if (this.str.compareTo(domain.str) == 0)
        return 0;
    else 
        return -1;
}
public String getStr()
{
    return str;
}
}

public static void main(String[] args)
{
    Domain d1 = new Domain("c");
    Domain d2 = new Domain("c");
    Domain d3 = new Domain("b");
    Domain d4 = new Domain("d");
    System.out.println(d1.compareTo(d2));
    System.out.println(d1.compareTo(d3));
    System.out.println(d1.compareTo(d4));
}
```

##### （2）Comparator（外比较器）

Comparator可以认为是是一个外比较器，个人认为有两种情况可以使用实现Comparator接口的方式：

1、一个对象不支持自己和自己比较（没有实现Comparable接口），但是又想对两个对象进行比较

2、一个对象实现了Comparable接口，但是开发者认为compareTo方法中的比较方式并不是自己想要的那种比较方式

Comparator接口里面有一个compare方法，方法有两个参数T o1和T o2，是泛型的表示方式，分别表示待比较的两个对象，方法返回值和Comparable接口一样是int，有三种情况：

1、o1大于o2，返回正整数

2、o1等于o2，返回0

3、o1小于o3，返回负整数

```
public class DomainComparator implements     Comparator<Domain>
{
public int compare(Domain domain1, Domain domain2)
{
    if (domain1.getStr().compareTo(domain2.getStr()) > 0)
        return 1;
    else if (domain1.getStr().compareTo(domain2.getStr()) == 0)
        return 0;
    else 
        return -1;
}
}

public static void main(String[] args)
    {
Domain d1 = new Domain("c");
Domain d2 = new Domain("c");
Domain d3 = new Domain("b");
Domain d4 = new Domain("d");
DomainComparator dc = new DomainComparator();
System.out.println(dc.compare(d1, d2));
System.out.println(dc.compare(d1, d3));
System.out.println(dc.compare(d1, d4));
}
```

##### （3）总结

总结一下，两种比较器Comparable和Comparator，后者相比前者有如下优点：

1、如果实现类没有实现Comparable接口，又想对两个类进行比较（或者实现类实现了Comparable接口，但是对compareTo方法内的比较算法不满意），那么可以实现Comparator接口，自定义一个比较器，写比较算法

2、实现Comparable接口的方式比实现Comparator接口的耦合性 要强一些，如果要修改比较算法，要修改Comparable接口的实现类，而实现Comparator的类是在外部进行比较的，不需要对实现类有任何修 改。从这个角度说，其实有些不太好，尤其在我们将实现类的.class文件打成一个.jar文件提供给开发者使用的时候。实际上实现Comparator 接口的方式后面会写到就是一种典型的策略模式。

[回到顶部](https://www.cnblogs.com/sxkgeek/p/9449984.html#_labelTop)

#### 二、Arrays类详解

java.util.Arrays类是JDK提供的一个工具类，用来处理数组的各种方法，而且每个方法基本上都是静态方法，能直接通过类名Arrays调用



#### 常用方法

#### asList

作用是返回由指定数组支持的固定大小列表

注意：这个方法返回的ArrayList 不是我们常用的集合类 java.util.ArrayList。这里的 ArrayList 是 Arrays 的一个内部类 java.util.Arrays.ArrayList。（返回的 ArrayList 数组是一个定长列表，我们只能对其进行查看或者修改，但是不能进行添加或者删除操作）

```
List<String> listStr = new ArrayList<>(Arrays.asList(str));
```

#### sort

该方法是用于数组排序，在Arrays类中有该方法的一系列重载方法，能对7种基本数据类型，包括 byte,char,double,float,int,long,short 等都能进行排序，还有 Object 类型（实现了Comparable接口），以及比较器 Comparator 。

#### binarySearch

用二分法查找数组中的某个元素，该方法和sort方法一样，适用于各种基本数据类型以及对象

注意：二分法是对以及有序的数组进行查找（比如先用Arrays.sort()进行排序，然后调用此方法进行查找）。找到元素返回下标，没有则返回 -1

#### copyOf

拷贝数组元素。底层采用 System.arraycopy() 实现，这是一个native方法。

#### equals和deepEquals

equals 用来比较两个数组中对应位置的每个元素是否相等。

deepEquals也是用来判断比较两个数组的元素是否相等，不过 deepEquals 能够进行比较多维数组，而且是任意层次的嵌套数组。

```
String[][] name1 = {{ "G","a","o" },{ "H","u","a","n"},{ "j","i","e"}};  
String[][] name2 = {{ "G","a","o" },{ "H","u","a","n"},{ "j","i","e"}};
System.out.println(Arrays.equals(name1,name2));// false  
System.out.println(Arrays.deepEquals(name1,name2));// true
```

#### Arrays.fill

## 

fill()方法使用参考

**声明举例：**

```
public static void fill(int[] a, form, to, int var) 
```

**参数：**

a--数组

form--替换开始位置（包括）

to--替换结束位置（不包括）

var--要替换的值

**使用参考实例：**

[![复制代码](1.LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
public class Test {
    
    public static void main(String[] args) {
        
        int[] a = new int[]{1,2,3,4,5,6};
        System.out.println(Arrays.toString(a));  //{1,2,3,4,5,6}
    
        Arrays.fill(a, 0);
        System.out.println(Arrays.toString(a));  //{0,0,0,0,0,0}    
        
        int[] b = new int[]{1,2,3,4,5,6};
        Arrays.fill(b, 2, 4, 0);
        System.out.println(Arrays.toString(b));  //{1,2,0,0,5,6}
        
        Boolean[] c = {true,false};
        System.out.println(Arrays.toString(c));  //{true,false}
        Arrays.fill(c, false);
        System.out.println(Arrays.toString(c));  //{false,false}
        Arrays.fill(c, 0, 1, true);
        System.out.println(Arrays.toString(c));  //{true,false}
        
        String[] d = {"a","b","c","d","e","f"};
        System.out.println(Arrays.toString(d));  //{a,b,c,d,e,f}
        Arrays.fill(d, 1, 2, "HelloWorld");
        System.out.println(Arrays.toString(d));  //{a,HelloWorld,c,d,e,f}
        
    }
}
```

#### toString和deepToString

toString 用来打印一维数组的元素，而 deepToString 用来打印多层次嵌套的数组元素。

[回到顶部](https://www.cnblogs.com/sxkgeek/p/9449984.html#_labelTop)

#### 三、Collections类详解

Collections是集合类的一个工具类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作



#### 排序方法

Collections提供了以下方法对List进行排序

void reverse(List list)：反转

void shuffle(List list),随机排序

void sort(List list),按自然排序的升序排序

void sort(List list, Comparator c);定制排序，由Comparator控制排序逻辑

void swap(List list, int i , int j),交换两个索引位置的元素

void rotate(List list, int distance),旋转。当distance为正数时，将list后distance个元素整体移到前面。当distance为负数时，将 list的前distance个元素整体移到后面。

#### sort

看一下sort(List list)源码

```
    public static <T extends Comparable<? super T>> void sort(List<T> list) {
    list.sort(null);
}
```

list接口里的sort方法

```
    default void sort(Comparator<? super E> c) {
    Object[] a = this.toArray();
    Arrays.sort(a, (Comparator) c);
    ListIterator<E> i = this.listIterator();
    for (Object e : a) {
        i.next();
        i.set((E) e);
    }
}
```



#### 查找，替换操作

int binarySearch(List list, Object key), 对List进行二分查找，返回索引，注意List必须是有序的

int max(Collection coll),根据元素的自然顺序，返回最大的元素。 类比int min(Collection coll)

int max(Collection coll, Comparator c)，根据定制排序，返回最大元素，排序规则由Comparatator类控制。类比int min(Collection coll, Comparator c)

void fill(List list, Object obj),用元素obj填充list中所有元素

int frequency(Collection c, Object o)，统计元素出现次数

int indexOfSubList(List list, List target), 统计targe在list中第一次出现的索引，找不到则返回-1，类比int lastIndexOfSubList(List source, list target).

boolean replaceAll(List list, Object oldVal, Object newVal), 用新元素替换旧元素。



#### 同步控制

Collections中几乎对每个集合都定义了同步控制方法，例如 SynchronizedList(), SynchronizedSet()，SynchronizedMap()等方法，来将集合包装成线程安全的集合。

### 31.16进制

![image-20200718141249623](%E7%AE%97%E6%B3%95-%E9%9F%A9%E9%A1%BA%E5%B9%B3-0514md.assets/image-20200718141249623.png)

### 32.Java单例模式——静态内部类实现



Singleton模式实现的重点在于将构造函数私有化(private)，并通过提供静态公有函数(public synchronized static xxx getInstance)来获取定义在类中的静态私有成员(private static xxx instance)，通过一个简单的判断静态实例是否为空来控制这个类只能够new一次，即控制了一个类只能有单个实例，一般的实现如下代码所示：


```java
package com.study.dp.singleton;
 
/**
 * 传统方式实现单例模式
 * @author CrazyPig
 *
 */
public class TraditionalSingletion {
	
	// 单实例
	private static TraditionalSingletion instance;
	
	// 不让new
	private TraditionalSingletion() {
		System.out.println("private TraditionalSingletion()");
	}
	
	public synchronized static TraditionalSingletion getInstance() {
		System.out.println("TraditionalSingletion getInstance()");
		if(instance == null) {
			System.out.println("instance = new TraditionalSingletion()");
			instance = new TraditionalSingletion();
		}
		return instance;
	}
	
	public static void main(String[] args) {
		TraditionalSingletion instance = TraditionalSingletion.getInstance();
		System.out.println("========================================");
		TraditionalSingletion instance01 = TraditionalSingletion.getInstance();
		System.out.println("========================================");
		TraditionalSingletion instance02 = TraditionalSingletion.getInstance();
	}
 
}
```

今天偶然在一篇文章中看到另外一种巧妙的做法，通过将这个单实例的引用变量定义在静态内部类中，来实现单例，这样可以做到不用if条件进行判断，并且是多线程安全的(由jvm保证)。这个特殊的做法如下所示：



```
package com.study.dp.singleton;
 
/**
 * 静态内部类实现单例模式
 * @author CrazyPig
 *
 */
public class SpecialSingleton {
	
	// 静态内部类
	private static class NestClass {
		private static SpecialSingleton instance;
		static {
			System.out.println("instance = new SingletonTest()");
			instance = new SpecialSingleton();
		}
	}
	
	// 不能直接new
	private SpecialSingleton() {
		System.out.println("private SingletonTest()");
	}
	
	public static SpecialSingleton getInstance() {
		System.out.println("SingletonTest getInstance()");
		return NestClass.instance;
	}
	
	public static void main(String[] args) {
		SpecialSingleton instance = SpecialSingleton.getInstance();
		System.out.println("========================================");
		SpecialSingleton instance01 = SpecialSingleton.getInstance();
		System.out.println("========================================");
		SpecialSingleton instance02 = SpecialSingleton.getInstance();
	}
 
}
```

#### java 双重检查单例和静态内部类单例

https://blog.csdn.net/android_freshman/article/details/51029031?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase

这种静态内部类的实现方式，它主要原理是：加载一个类时，其内部类不会同时被加载。一个类被加载，当且仅当其某个静态成员（静态域、构造器、静态方法等）被调用时发生，也就是说内部类：InnerClass只有我们调用getInstance()的时候才会被加载。
那么这个写法为什么线程安全呢？原因可以在《深入理解Java虚拟机》这本书的第七章7.3.5小节找到答案，这里摘要出主要原因，大家有兴趣可以自己去看看书：

虚拟机会保证一个类的< clinit>()方法在多线程环境中被正确的加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的< clinit>()方法，其他线程都需要阻塞等待，直到活动线程执行< clinit>()方法完毕。如果在一个类的< clinit>()方法中有耗时很长的操作，就有可能造成多个进程阻塞(需要注意的是，其他线程虽然会被阻塞，但如果执行< clinit>()方法的那条线程退出< clinit>()方法后，其他线程唤醒之后不会再次进入< clinit>()方法。同一个类加载器下，一个类型只会被初始化一次)，在实际应用中这种阻塞旺旺是很隐蔽的。
这就是他线程安全的原因，通俗的说就是这个静态内部类只能同时有一个线程去初始化它，其他的被阻塞，如果一个线程初始化了这个静态内部类，那么其他的就不会再去初始化了。

那么上面这个写法就真的能保证这个类的实例在任何情况下都只有一个吗？其实是不行的，通过反射的方式，就可以修改这个类的私有构造器权限，然后创建出一个这个类的实例，这个在下一篇博客里面写。
个人浅薄理解，欢迎补充

#### 内部类和静态内部类

https://www.cnblogs.com/eternityz/p/12577225.html

**静态内部类使用方法**

通过外部类访问静态内部类

```java
OuterClass.StaticNestedClass
```

创建静态内部类对象

```
OuterClass.StaticNestedClass nestedObject = new OuterClass.StaticNestedClass();
```

**内部类的使用方法**

必须先实例化外部类,才能实例化内部类

```
OuterClass outerClass = new OuterClass();
OuterClass.InnerClass innerClass = outerClass.new InnerClass();
```

**两者区别**

1. 内部类, 即便是私有的也能访问,无论静态还是非静态都能访问
   - 可以访问封闭类(外部类)中所有的成员变量和方法
   - 封闭类(外部类)中的私有private成员变量和方法也可以访问
   - 内部类中不可以有静态的变量和静态的方法
2. 静态内部类
   - 无权访问封闭类(外部类)的中的非静态变量或者非静态方法
   - 封闭类(外部类)中的私有private的静态static成员变量和方法也可以访问
   - 静态内部类中可以有静态的变量和静态的方法
3. 内部类可以被声明为private, public, protected, or package private. 但是封闭类(外部类)只能被声明为`public` or package private



#### 内部类

https://www.cnblogs.com/qiaoshouliang/p/4661699.html

的几种创建方法：

1、成员内部类

```
class   Outer{  private   int   i =   1  ;       class   Inner{         public   void   fun() {System.out.println(  "Outer I="   + i)}         }       } 
```



2、方法内部类

```
class Outer{ 
public void fun() { 
    final int i = 1; // 被方法内部类访问的局部变量必须被final修饰
    class Inner{ // 方法内部类 不能有访问修饰符，比如public
        public void print() {System.out.println("Method I=" + i)} 
            } 
        } 
    } 
```


3、匿名内部类

```
interface USB { 
    class Inner { // 默认是public static，即可以直接new USB.Inner();
    } 
} 
```


4、静态内部类

```
class Outer{ 
　　private int i = 1; 
　　static class Inner{ // 不能访问外部类的非静态成员
　　　　public void fun() { } 
      } 
}
```



5、接口内部类

```
interface USB { 
    class Inner { // 默认是public static，即可以直接new USB.Inner();
    } 
} 
```

 

[回到顶部](https://www.cnblogs.com/qiaoshouliang/p/4661699.html#_labelTop)

二、神马是内部类？

乍一看，好些创建方式，挺复杂的吧？首先内部类是个啥东西？
定义：创建在一个类内部的类型。根据创建位置的不同，分为成员的、方法的、匿名的。接口中的内部类叫做接口内部类。
理解：在类的内部创建，那就是类的一部分，跟属性、方法同级。这也就解释了为何能访问外部私有成员，我是你的一部分，我当然可以访问了。

问题的引出<理解内部类>：

那问题来了，我是你的一部分，别人继承了外部类，会不会也把内部类也继承过去呢？这得从内部类设计的初衷与面向对象来探讨了。
比如我们用Body类来描述人体。如果是描述人类的话，会去描述人类具有的属性跟功能。
那现在我们描述人体，人体内部有心肝脾胃肾，这些再用属性来描述就不合适了吧？那怎么办呢？我们可以用内部类去描述。
所以，无论内部类是公开的还是私有的，都不会被继承，因为他不是属性，也不是方法。而是一个内部事务的描述，我们称之为内部类。
内部类可以更好地对内部事务进行封装，看例子：

身体类中，有属于身体的各个器官，各个器官有自己的功能与属性，于是我们把它封装成一个内部类去单独描述。
用来描述器官的内部类是身体的一部分，所以可以去自由的访问身体的资源(属性与功能)，各个器官与身体相互协调完成运作。



```
public   class   Body {   　　  private   class   Heart {   // 心脏  　　　　  public   void   bloodSupply() {   　　　　  // 供血...       　　}        }   　　  private   class   Hepar {   // 肝脏  　　　　  public   void   Metabolism() {   　　　　  // 代谢...       　　}        }   　　  private   class   Spleen {   // 脾脏  　　　　  public   void   storageBlood() {   　　　　  // 储血...          }        }   　　  private   class   Stomach {   //胃部  　　　　  public   void   digest() {   　　　　  // 消化...          }        }   　　  private   class   Kidney {   // 肾脏  　　　　  public   void   dischargePoison() {   　　　　  // 排毒...          }        }   }
```

 

问题的引出<内部类访问外部类成员方式>：

因为可以访问外部私有成员，那问题也就诞生了，他是怎么访问的呢？

1：对于成员内部类来说，他会持有一份外部类当前对象的引用，Outer.this。
这样就可以调用外部类可见的方法跟成员变量，调用方法是通过持有的外部类引用去调用的。Outer.this.fun();
那对于private成员是如何去访问的呢？是通过编译器在外部类中生成的静态的access$0()方法来访问的。Outer.this.access$0(Outer);

![img](http://img.blog.csdn.net/20130510173741511)

![img](http://img.blog.csdn.net/20130511075639803)


2：对于方法内部类（匿名内部类）来说，因为内部类要访问所在方法中的局部变量，这时候用持有的外部类当前对象引用还能调用的到吗？
调不到了，那Java语言的设计者是这么来解决这个问题的：将局部变量复制一份给内部类使用，怎么复制的？在内部类初始化的时候通过构造方法传值的方式。
这样，内部类中会有一份复制的private修饰的成员变量。这样我就能访问了。但问题又来了，比如：

```
public   void   fun() {   　　  int   i =   1  ;   　　  class   Inner{   　　　　  // int i = 1; 由编译器生成  　　　　publicvoid print() { i++ }       　}       　 System.out.println(  "i="   + i);   　　  // 还是会输出i=1，我们明明在内部类方法中对此变量进行++了啊。抱歉，您++的是被复制的另一份。  } 
```

 

问题的引出<保持两个不同变量的一致性>：


好，问题就这么无情的出现了，怎么解决？Java又说了，要不然给局部变量加上final吧，这样就会保持值得一致性了。
ok，问题解决，这就是为什么方法内部类访问的局部变量必须被final修饰的终极原因（为了约束两个不同变量的一致性）。设计问题，挺无奈的解决方案。


来看看另一种说法：
在Java中，方法的局部变量位于栈上，对象位于堆上。
因为局部变量的范围被限制在该方法内，当一个方法结束时，栈结构被删除，该变量消失。
但是，定义在这个类中的内部类对象仍然存活在堆上，所以内部类对象不能使用局部变量。除非这些局部变量被标识为最终的。  

这种说法是片面的，因为根本原因是内部类对象无法访问局部变量，才会去复制一份。

为了保证两个变量的一致性，才去使用final关键字修饰局部变量。而不是因为栈生命周期与堆生命周期不一致的问题。

### 33.notify  vs notifyAll

对于wait()和notify()的理解，还是要从jdk官方文档中开始，在Object类方法中有：对于wait()和notify()的理解，还是要从jdk官方文档中开始，在Object类方法中有：

```java
void notify() 
Wakes up a single thread that is waiting on this object’s monitor. 
译：唤醒在此对象监视器上等待的单个线程
void notifyAll() 
Wakes up all threads that are waiting on this object’s monitor. 
译：唤醒在此对象监视器上等待的所有线程
void wait( ) 
Causes the current thread to wait until another thread invokes the notify() method or the notifyAll( ) method for this object. 
译：导致当前的线程等待，直到其他线程调用此对象的notify( ) 方法或 notifyAll( ) 方法
void wait(long timeout) 
Causes the current thread to wait until either another thread invokes the notify( ) method or the notifyAll( ) method for this object, or a specified amount of time has elapsed. 
译：导致当前的线程等待，直到其他线程调用此对象的notify() 方法或 notifyAll() 方法，或者指定的时间过完。
void wait(long timeout, int nanos) 
Causes the current thread to wait until another thread invokes the notify( ) method or the notifyAll( ) method for this object, or some other thread interrupts the current thread, or a certain amount of real time has elapsed. 
译：导致当前的线程等待，直到其他线程调用此对象的notify( ) 方法或 notifyAll( ) 方法，或者其他线程打断了当前线程，或者指定的时间过完。
    
    官方文档总结一下：
  wait( )，notify( )，notifyAll( )都不属于Thread类，而是属于Object基础类，也就是每个对象都有wait( )，notify( )，notifyAll( ) 的功能，因为每个对象都有锁，锁是每个对象的基础，当然操作锁的方法也是最基础了。
    
当需要调用以上的方法的时候，一定要对竞争资源进行加锁，如果不加锁的话，则会报 IllegalMonitorStateException 异常
    
当想要调用wait( )进行线程等待时，必须要取得这个锁对象的控制权（对象监视器），一般是放到synchronized(obj)代码中。
    
在while循环里而不是if语句下使用wait，这样，会在线程暂停恢复后都检查wait的条件，并在条件实际上并未改变的情况下处理唤醒通知
    
调用obj.wait( )释放了obj的锁，否则其他线程也无法获得obj的锁，也就无法在synchronized(obj){ obj.notify() } 代码段内唤醒A。
    
notify( )方法只会通知等待队列中的第一个相关线程（不会通知优先级比较高的线程）
    
notifyAll( )通知所有等待该竞争资源的线程（也不会按照线程的优先级来执行）
    
假设有三个线程执行了obj.wait( )，那么obj.notifyAll( )则能全部唤醒tread1，thread2，thread3，但是要继续执行obj.wait（）的下一条语句，必须获得obj锁，因此，tread1，thread2，thread3只有一个有机会获得锁继续执行，例如tread1，其余的需要等待thread1释放obj锁之后才能继续执行。
    
当调用obj.notify/notifyAll后，调用线程依旧持有obj锁，因此，thread1，thread2，thread3虽被唤醒，但是仍无法获得obj锁。直到调用线程退出synchronized块，释放obj锁后，thread1，thread2，thread3中的一个才有机会获得锁继续执行。

    
```

二、wait()和notify()的通常用法
Java多线程开发中，我们常用到wait()和notify()方法来实现线程间的协作，简单的说步骤如下： 
1. A线程取得锁，执行wait()，释放锁; 
2. B线程取得锁，完成业务后执行notify()，再释放锁; 
3. B线程释放锁之后，A线程取得锁，继续执行wait()之后的代码；

三、生产者与消费者模式
假设有一个公共的容量有限的池子，有两种人，一种是生产者，另一种是消费者。需要满足如下条件：

1、生产者产生资源往池子里添加，前提是池子没有满，如果池子满了，则生产者暂停生产，直到自己的生成能放下池子。

2、消费者消耗池子里的资源，前提是池子的资源不为空，否则消费者暂停消耗，进入等待直到池子里有资源数满足自己的需求。

运用wait()和notify()实现如下：

```


抽象仓库类
public interface AbstractStorage {
    void consume(int num);
    void produce(int num);
}
仓库类
/**
 *  生产者和消费者的问题
 *  wait、notify/notifyAll() 实现
 */
public class Storage1 implements AbstractStorage {
    //仓库最大容量
    private final int MAX_SIZE = 100;
    //仓库存储的载体
    private LinkedList list = new LinkedList();
 
    //生产产品
    public void produce(int num){
        //同步
        synchronized (list){
            //仓库剩余的容量不足以存放即将要生产的数量，暂停生产
            while(list.size()+num > MAX_SIZE){
                System.out.println("【要生产的产品数量】:" + num + "\t【库存量】:"
                        + list.size() + "\t暂时不能执行生产任务!");
                try {
                    //条件不满足，生产阻塞
                    list.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
 
            for(int i=0;i<num;i++){
                list.add(new Object());
            }
 
            System.out.println("【已经生产产品数】:" + num + "\t【现仓储量为】:" + list.size());
 
            list.notifyAll();
        }
    }
 
    //消费产品
    public void consume(int num){
        synchronized (list){
            //不满足消费条件
            while(num > list.size()){
                System.out.println("【要消费的产品数量】:" + num + "\t【库存量】:"
                       + list.size() + "\t暂时不能执行生产任务!");
                try {
                    list.wait();
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
            //消费条件满足，开始消费
            for(int i=0;i<num;i++){
                list.remove();
            }
 
            System.out.println("【已经消费产品数】:" + num + "\t【现仓储量为】:" + list.size());
 
            list.notifyAll();
        }
    }
}
生产者
public class Producer extends Thread{
    //每次生产的数量
    private int num ;
 
    //所属的仓库
    public AbstractStorage abstractStorage;
 
    public Producer(AbstractStorage abstractStorage){
        this.abstractStorage = abstractStorage;
    }
 
    public void setNum(int num){
        this.num = num;
    }
 
    // 线程run函数
    @Override
    public void run()
    {
        produce(num);
    }
 
    // 调用仓库Storage的生产函数
    public void produce(int num)
    {
        abstractStorage.produce(num);
    }
}
消费者
public class Consumer extends Thread{
    // 每次消费的产品数量
    private int num;
 
    // 所在放置的仓库
    private AbstractStorage abstractStorage1;
 
    // 构造函数，设置仓库
    public Consumer(AbstractStorage abstractStorage1)
    {
        this.abstractStorage1 = abstractStorage1;
    }
 
    // 线程run函数
    public void run()
    {
        consume(num);
    }
 
    // 调用仓库Storage的生产函数
    public void consume(int num)
    {
        abstractStorage1.consume(num);
    }
 
    public void setNum(int num){
        this.num = num;
    }
}
测试类
public class Test{
    public static void main(String[] args) {
        // 仓库对象
        AbstractStorage abstractStorage = new Storage1();
 
        // 生产者对象
        Producer p1 = new Producer(abstractStorage);
        Producer p2 = new Producer(abstractStorage);
        Producer p3 = new Producer(abstractStorage);
        Producer p4 = new Producer(abstractStorage);
        Producer p5 = new Producer(abstractStorage);
        Producer p6 = new Producer(abstractStorage);
        Producer p7 = new Producer(abstractStorage);
 
        // 消费者对象
        Consumer c1 = new Consumer(abstractStorage);
        Consumer c2 = new Consumer(abstractStorage);
        Consumer c3 = new Consumer(abstractStorage);
 
        // 设置生产者产品生产数量
        p1.setNum(10);
        p2.setNum(10);
        p3.setNum(10);
        p4.setNum(10);
        p5.setNum(10);
        p6.setNum(10);
        p7.setNum(80);
 
        // 设置消费者产品消费数量
        c1.setNum(50);
        c2.setNum(20);
        c3.setNum(30);
 
        // 线程开始执行
        c1.start();
        c2.start();
        c3.start();
 
        p1.start();
        p2.start();
        p3.start();
        p4.start();
        p5.start();
        p6.start();
        p7.start();
    }
}
 运行结果：
【要消费的产品数量】:50    【库存量】:0    暂时不能执行生产任务!
【要消费的产品数量】:20    【库存量】:0    暂时不能执行生产任务!
【要消费的产品数量】:30    【库存量】:0    暂时不能执行生产任务!
【已经生产产品数】:10    【现仓储量为】:10
【要消费的产品数量】:30    【库存量】:10    暂时不能执行生产任务!
【要消费的产品数量】:20    【库存量】:10    暂时不能执行生产任务!
【要消费的产品数量】:50    【库存量】:10    暂时不能执行生产任务!
【已经生产产品数】:10    【现仓储量为】:20
【已经生产产品数】:10    【现仓储量为】:30
【要消费的产品数量】:50    【库存量】:30    暂时不能执行生产任务!
【已经消费产品数】:20    【现仓储量为】:10
【要消费的产品数量】:30    【库存量】:10    暂时不能执行生产任务!
【已经生产产品数】:10    【现仓储量为】:20
【要消费的产品数量】:50    【库存量】:20    暂时不能执行生产任务!
【要消费的产品数量】:30    【库存量】:20    暂时不能执行生产任务!
【已经生产产品数】:10    【现仓储量为】:30
【已经消费产品数】:30    【现仓储量为】:0
【要消费的产品数量】:50    【库存量】:0    暂时不能执行生产任务!
【已经生产产品数】:10    【现仓储量为】:10
【要消费的产品数量】:50    【库存量】:10    暂时不能执行生产任务!
【已经生产产品数】:80    【现仓储量为】:90
【已经消费产品数】:50    【现仓储量为】:40
————————————————
版权声明：本文为CSDN博主「土豆是我的最爱」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_37141773/article/details/84138659
```





### 34.Java关键字: protected



 

在开发中，经常遇见protected关键字。特别是一些回调方法中，今天小结一下。

下面先展示一下关于Java中访问权限的修饰符之间的关系，如下图所示：



![image-20200721234123370](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200721234123370.png)



做几个测试，说明protected关键字。



**1.同一个包不同类中，可以访问protected成员，无继承关系**



Java代码 

1. **package** mark.test; 
2. **public** **class** Person { 
3.   **protected** **int** height; 
4.    
5.   **protected** **void** speak(Object obj) { 
6. ​    System.out.println("I'm " + obj + "!"); 
7.   } 
8. } 
9. /** 
10.  \* 同一个包不同类中，可以访问protected成员 
11.  \* 无继承关系 
12.  */ 
13. **class** Man { 
14.    
15.   **public** **static** **void** main(String[] args) { 
16. ​    Person p = **new** Person(); 
17. ​    Man man = **new** Man(); 
18. ​    p.height = 10; 
19. ​    p.speak(man); 
20.   } 
21.    
22.   @Override 
23.   **public** String toString() { 
24. ​    **return** "man"; 
25.   } 
26. } 



**2. 同一个包不同类中，可以访问protected成员，具有继承关系**



Java代码 

1. **package** mark.test; 
2. **public** **class** Person { 
3.   **protected** **int** height; 
4.    
5.   **protected** **void** speak(Object obj) { 
6. ​    System.out.println("I'm " + obj + "!"); 
7.   } 
8. } 
9. /** 
10.  \* 同一个包不同类中，可以访问protected成员 
11.  \* 具有继承关系 
12.  */ 
13. **class** Woman **extends** Person { 
14.    
15.   **public** **static** **void** main(String[] args) { 
16. ​    Woman w = **new** Woman(); 
17. ​    w.speak(w); 
18.   } 
19.    
20.   @Override 
21.   **public** String toString() { 
22. ​    **return** "woman"; 
23.   } 
24. } 



**3. 同包下，间接子类，也可以访问**



Java代码 

1. **package** mark.test; 
2. **public** **class** Person { 
3.   **protected** **int** height; 
4.    
5.   **protected** **void** speak(Object obj) { 
6. ​    System.out.println("I'm " + obj + "!"); 
7.   } 
8. } 
9. /** 
10.  \* 该子类Wife无法访问父类Person的protected成员 
11.  \* 
12.  \* Wife是Person的间接子类 
13.  */ 
14. **class** Wife **extends** Woman { 
15.   Wife wife = **new** Wife(); 
16.   //wife.speak(wife);//出错 
17.   Woman woman = **new** Woman(); 
18.   //woman.speak(woman);//出错 
19.   Person p = **new** Person(); 
20. // p.height = 20; //无法访问 
21. // p.speak(man); //无法访问 
22. } 



**4. 不同包，继承与不继承**

不同包下的，即使具有继承关系的子类中，该父类对象也不可以访问自己的protected成员。



Java代码 

1. **package** mark.zhang; 
2. **import** mark.test.Person; 
3. /** 
4.  \* 不同包下的类不可以访问父类的protected成员 
5.  \* 
6.  \* 不具有继承关系 
7.  */ 
8. **public** **class** Man { 
9.    
10.   **public** **static** **void** main(String[] args) { 
11. ​    Person p = **new** Person(); 
12. //   p.height = 20; //无法访问 
13. //   p.speak(man); //无法访问 
14.   } 
15.    
16.   @Override 
17.   **public** String toString() { 
18. ​    **return** "man"; 
19.   } 
20. } 
21. /** 
22.  \* 不同包下的子类可以访问父类的protected成员 
23.  \* 
24.  \* 具有继承关系 
25.  */ 
26. **class** Woman **extends** Person { 
27.    
28.   **public** **static** **void** main(String[] args) { 
29. ​    Woman w = **new** Woman(); 
30. ​    w.height = 100; 
31. ​    w.speak(w); 
32. ​    Person p = **new** Person(); 
33. //   p.height = 20; //无法访问 
34. //   p.speak(man); //无法访问 
35.   } 
36.    
37.   @Override 
38.   **public** String toString() { 
39. ​    **return** "woman"; 
40.   } 
41. } 



***\*5. 不同包，间接子类\****

**父类的protected方法对于不同包下的间接子类是不可见的，即不可以访问！**



**Java代码** 

1. ***\*package\** mark.zhang;** 
2. ***\*public\** \**class\** Person {** 
3.   ***\*protected\** \**int\** height;** 
4.    
5.   ***\*protected\** \**void\** speak(Object obj) {** 
6. ​    **System.out.println("I'm " + obj + "!");** 
7.   **}** 
8. **}** 
9. ***\*package\** mark.zhang;** 
10. **/\**** 
11.  *** 同一个包不同类中，可以访问protected成员** 
12.  *** 具有继承关系** 
13.  ***/** 
14. ***\*public\** \**class\** Woman \**extends\** Person {** 
15.    
16.   ***\*public\** \**static\** \**void\** main(String[] args) {** 
17. ​    **Woman w = \**new\** Woman();** 
18. ​    **w.speak(w);** 
19.   **}** 
20.    
21.   **@Override** 
22.   ***\*public\** String toString() {** 
23. ​    ***\*return\** "woman";** 
24.   **}** 
25. **}** 
26. ***\*package\** mark.test;** 
27. ***\*import\** mark.zhang.Person;** 
28. ***\*import\** mark.zhang.Woman;** 
29. **/\**** 
30.  *** 该子类Wife不可以访问父类Person的protected成员** 
31.  *****
32.  *** Wife是Person的间接子类** 
33.  ***/** 
34. ***\*class\** Wife \**extends\** Woman {** 
35.   ***\*public\** \**static\** \**void\** main(String[] args) {** 
36. ​    **Wife wife = \**new\** Wife();** 
37. ​    **wife.speak(wife);//出错** 
38. ​    **Woman woman = \**new\** Woman();** 
39. ​    **// woman.speak(woman);//出错,The method speak(Object) from the type Person is not visible** 
40. ​    **Person p = \**new\** Person();** 
41. ​    **// p.height = 20; //无法访问** 
42. ​    **// p.speak(woman); //无法访问** 
43.   **}** 
44.    
45.   **@Override** 
46.   ***\*public\** String toString() {** 
47. ​    ***\*return\** "wife";** 
48.   **}** 
49. **}** 



ok，测试结束！！！



**总结：**



<1> 同包同类中，可以自由访问protected成员

<2>同包不同类中，无任何继承关系，可以自由访问protected成员





<3>同包不同类中，具有继承关系，任何子类或者子类的子类都可以访问protected成员

<4> 不同包不同类中，不具有继承关系，不可以访问其它类protected成员

<5>不同包不同类中，具有继承关系，子类可以访问父类protected成员。但是父类对象不可以访问自己的protected成员，否则报这样的错误：The method speak(Object) from the type Person is not visible

<6>不同包不同类中，具有继承关系，间接子类中除该类对象自己外，它的直接父类，以及间接父类都不可以访问自己的protected成员。其实，这与<5>是一个道理。

### 35.HashTable的使用和原理

（1）Hashtable 是一个散列表，它存储的内容是键值对(key-value)映射。

（2）Hashtable 继承于Dictionary，实现了Map、Cloneable、java.io.Serializable接口。

（3）Hashtable 的函数都是同步的，这意味着它是线程安全的。它的key、value都不可以为null。



	package ThreeWeek;
	
	import java.util.Enumeration;
	import java.util.Hashtable;
	import java.util.Iterator;
	import java.util.Map;
	import java.util.Map.Entry;
	
	public class HashTableTest {
	
	public static void main(String args[]){
		Hashtable<String, Integer> table = new Hashtable<String, Integer>();
		
		//[1]添加元素
		table.put("zhangsan", 22);
		table.put("lisi", 33);
		table.put("wangwu", 44);
		
		//[2]toString()方式打印
		System.out.println(table.toString());
		
		//[3]Iterator遍历方式1--键值对遍历entrySet()
		Iterator<Entry<String, Integer>> iter = table.entrySet().iterator();
		while(iter.hasNext()){
			Map.Entry<String, Integer> entry = (Map.Entry<String, Integer>)iter.next();
			String key = entry.getKey();
			int value = entry.getValue();
			System.out.println("entrySet:"+key+" "+value);
		}
		
		System.out.println("====================================");
		
		//[4]Iterator遍历方式2--key键的遍历
		Iterator<String> iterator = table.keySet().iterator();
		while(iterator.hasNext()){
			String key = (String)iterator.next();
			int value = table.get(key);
			System.out.println("keySet:"+key+" "+value);
		}
		
		System.out.println("====================================");
		
		//[5]通过Enumeration来遍历Hashtable
		Enumeration<String> enu = table.keys();
		while(enu.hasMoreElements()) {
		    System.out.println("Enumeration:"+table.keys()+" "+enu.nextElement());
		} 
			
	}


​	
​	{zhangsan=22, lisi=33, wangwu=44}
​	entrySet:zhangsan 22
​	entrySet:lisi 33
​	entrySet:wangwu 44
​	====================================
​	keySet:zhangsan 22
​	keySet:lisi 33
​	keySet:wangwu 44
​	====================================
​	Enumeration:java.util.Hashtable$Enumerator@139a55 zhangsan
​	Enumeration:java.util.Hashtable$Enumerator@1db9742 lisi
​	Enumeration:java.util.Hashtable$Enumerator@106d69c wangwu

}

二、---内部原理---




1、继承关系


java.lang.Object
   ↳     java.util.Dictionary<K, V>
         ↳     java.util.Hashtable<K, V>

public class Hashtable<K,V> extends Dictionary<K,V>
    implements Map<K,V>, Cloneable, java.io.Serializable { }
与HashMap不同的是Hashtable是继承Dictionary，实现了Map接口。Map是"key-value键值对"接口，Dictionary是声明了操作"键值对"函数接口的抽象类。 


2、构造函数

（1）Hashtable中提供了四个构造函数，如下：

// 默认构造函数。
public Hashtable() 

// 指定“容量大小”的构造函数
public Hashtable(int initialCapacity) 

// 指定“容量大小”和“加载因子”的构造函数
public Hashtable(int initialCapacity, float loadFactor) 

// 包含“子Map”的构造函数
public Hashtable(Map<? extends K, ? extends V> t)


（2）上面的四个构造方法中，第三个是最重要的，指定初始化容量和构造因子



public Hashtable(int initialCapacity, float loadFactor) {  
        //验证初始容量  
        if (initialCapacity < 0)  
            throw new IllegalArgumentException("Illegal Capacity: "+  
                                               initialCapacity);  
        //验证加载因子  
        if (loadFactor <= 0 || Float.isNaN(loadFactor))  
            throw new IllegalArgumentException("Illegal Load: "+loadFactor);  

        if (initialCapacity==0)  
            initialCapacity = 1;  
          
        this.loadFactor = loadFactor;  
          
        //初始化table，获得大小为initialCapacity的table数组  
        table = new Entry[initialCapacity];  
        //计算阀值  
        threshold = (int)Math.min(initialCapacity * loadFactor, MAX_ARRAY_SIZE + 1);  
        //初始化HashSeed值  
        initHashSeedAsNeeded(initialCapacity);  
    }  


3、成员变量


（1）table是一个Entry[]数组类型，而Entry实际上就是一个单向链表。哈希表的"key-value键值对"都是存储在Entry数组中的。 

（2）count是Hashtable的大小，它是Hashtable保存的键值对的数量。 

（3）threshold是Hashtable的阈值，用于判断是否需要调整Hashtable的容量。threshold的值="容量*加载因子"。

（4）loadFactor就是加载因子。

（5）modCount是用来实现fail-fast机制的


 private transient Entry[] table;
// Hashtable中元素的实际数量
private transient int count;
// 阈值，用于判断是否需要调整Hashtable的容量（threshold = 容量*加载因子）
private int threshold;
// 加载因子
private float loadFactor;
// Hashtable被改变的次数
private transient int modCount = 0;


4、put和get方法
（1）put方法

从下面的代码中我们可以看出，Hashtable中的key和value是不允许为空的，当我们想要想Hashtable中添加元素的时候，首先计算key的hash值，然

后通过hash值确定在table数组中的索引位置，最后将value值替换或者插入新的元素，如果容器的数量达到阈值，就会进行扩充。

public synchronized V put(K key, V value) {  
        // 确保value不为null  
        if (value == null) {  
            throw new NullPointerException();  
        }  

        /* 
         * 确保key在table[]是不重复的 
         * 处理过程： 
         * 1、计算key的hash值，确认在table[]中的索引位置 
         * 2、迭代index索引位置，如果该位置处的链表中存在一个一样的key，则替换其value，返回旧值 
         */  
        Entry tab[] = table;  
        int hash = hash(key);    //计算key的hash值  
        int index = (hash & 0x7FFFFFFF) % tab.length;     //确认该key的索引位置  
        //迭代，寻找该key，替换  
        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {  
            if ((e.hash == hash) && e.key.equals(key)) {  
                V old = e.value;  
                e.value = value;  
                return old;  
            }  
        }  
      
        modCount++;  
        if (count >= threshold) {  //如果容器中的元素数量已经达到阀值，则进行扩容操作  
            rehash();  
            tab = table;  
            hash = hash(key);  
            index = (hash & 0x7FFFFFFF) % tab.length;  
        }  
      
        // 在索引位置处插入一个新的节点  
        Entry<K,V> e = tab[index];  
        tab[index] = new Entry<>(hash, key, value, e);  
        //容器中元素+1  
        count++;  
        return null;  
    }  

（2）get方法
同样也是先获得索引值，然后进行遍历，最后返回

public synchronized V get(Object key) {  
        Entry tab[] = table;  
        int hash = hash(key);  
        int index = (hash & 0x7FFFFFFF) % tab.length;  
        for (Entry<K,V> e = tab[index] ; e != null ; e = e.next) {  
            if ((e.hash == hash) && e.key.equals(key)) {  
                return e.value;  
            }  
        }  
        return null;  
    }  



五、---比较不同---


Hashtable和HashMap到底有哪些不同呢
（1）基类不同：HashTable基于Dictionary类，而HashMap是基于AbstractMap。Dictionary是什么？它是任何可将键映射到相应值的类的抽象父类，而AbstractMap是基于Map接口的骨干实现，它以最大限度地减少实现此接口所需的工作。

（2）null不同：HashMap可以允许存在一个为null的key和任意个为null的value，但是HashTable中的key和value都不允许为null。

（3）线程安全：HashMap时单线程安全的，Hashtable是多线程安全的。

（4）遍历不同：HashMap仅支持Iterator的遍历方式，Hashtable支持Iterator和Enumeration两种遍历方式。






尊重作者，尊重原创，参考文章：

http://www.cnblogs.com/skywang12345/p/3310887.html#a1

http://cmsblogs.com/?p=618
————————————————
版权声明：本文为CSDN博主「劲火星空」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/jinhuoxingkong/article/details/52022999

### 36.关键字transient

**一、初识transient关键字**

其实这个关键字的作用很好理解，就是简单的一句话：将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会被序列化。

概念也很好理解，下面使用代码去验证一下：

![image-20200722173823326](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200722173823326.png)

然后我们在Test中去验证一下：



![image-20200722173844633](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200722173844633.png)

从上面可以看出，在序列化SerializeUser方法中，首先创建一个序列化user类，然后将其写入到G://Test/template路径中。在反序列化DeSerializeUser方法中，首先创建一个File，然后读取G://Test/template路径中的数据。

这就是序列化和反序列化的基本实现，而且我们看一下结果，也就是被transient关键字修饰的age属性是否被序列化。

![image-20200722173905214](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200722173905214.png)

从上面的这张图可以看出，age属性变为了0，说明被transient关键字修饰之后没有被序列化。

**二、深入分析transient关键字**

为了更加深入的去分析transient关键字，我们需要带着几个问题去解读：

（1）transient底层实现的原理是什么？

（2）被transient关键字修饰过得变量真的不能被序列化嘛？

（3）静态变量能被序列化吗？被transient关键字修饰之后呢？

带着这些问题一个一个来解决：

**1、transient底层实现原理是什么？**

java的serialization提供了一个非常棒的存储对象状态的机制，说白了serialization就是把对象的状态存储到硬盘上 去，等需要的时候就可以再把它读出来使用。有些时候像银行卡号这些字段是不希望在网络上传输的，transient的作用就是把这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化，意思是transient修饰的age字段，他的生命周期仅仅在内存中，不会被写到磁盘中。

**2、被transient关键字修饰过得变量真的不能被序列化嘛？**

想要解决这个问题，首先还要再重提一下对象的序列化方式：

Java序列化提供两种方式。

一种是实现Serializable接口

另一种是实现Exteranlizable接口。 需要重写writeExternal和readExternal方法，它的效率比Serializable高一些，并且可以决定哪些属性需要序列化（即使是transient修饰的），但是对大量对象，或者重复对象，则效率低。

从上面的这两种序列化方式，我想你已经看到了，使用Exteranlizable接口实现序列化时，我们自己指定那些属性是需要序列化的，即使是transient修饰的。下面就验证一下

首先我们定义User1类：这个类是被Externalizable接口修饰的

![image-20200722173923893](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200722173923893.png)

然后我们就可以测试了





![image-20200722173934291](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200722173934291.png)

上面，代码分了两个方法，一个是序列化，一个是反序列化。里面的代码和一开始给出的差不多，只不过，User1里面少了age这个属性。

然后看一下结果：

![image-20200722173947440](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200722173947440.png)

结果基本上验证了我们的猜想，也就是说，实现了Externalizable接口，哪一个属性被序列化使我们手动去指定的，即使是transient关键字修饰也不起作用。

**3、静态变量能被序列化吗？没被transient关键字修饰之后呢？**

这个我可以提前先告诉结果，静态变量是不会被序列化的，即使没有transient关键字修饰。下面去验证一下，然后再解释原因。

首先，在User类中对age属性添加transient关键字和static关键字修饰。

然后，在Test类中去测试

![img](https://pics4.baidu.com/feed/37d12f2eb9389b5058d0f2a8cdfa1bd9e6116e74.jpeg?token=33146a8e579054466f347c734a684c53&s=5010EC3211BEC5CE4CF985DA0000D0B3)

最后，测试一下，看看结果

![img](https://pics1.baidu.com/feed/4610b912c8fcc3ceea3ea085d58a288cd63f20d9.jpeg?token=d1866c30728ae9d6ad4aacbc8be58fa8&s=0928BD1AC5364C21405561DE020050B1)

结果已经很明显了。现在解释一下，为什么会是这样，其实在前面已经提到过了。因为静态变量在全局区,本来流里面就没有写入静态变量,我打印静态变量当然会去全局区查找,而我们的序列化是写到磁盘上的，所以JVM查找这个静态变量的值，是从全局区查找的，而不是磁盘上。user.setAge(18);年龄改成18之后，被写到了全局区，其实就是方法区，只不过被所有的线程共享的一块空间。因此可以总结一句话：

静态变量不管是不是transient关键字修饰，都不会被序列化

**三、transient关键字总结**

java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。像银行卡、密码等等这些数据。这个需要根据业务情况了。

https://baijiahao.baidu.com/s?id=1636557218432721275&wfr=spider&for=pc

### 37. java断言assert





### 38.Deque

![image-20200802170453098](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200802170453098.png)



```kotlin
interface Deque <E>
```

子接口：

```xml
BlockingDeque <E>
```

实现类：

- [ArrayDeque](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayDeque.html)
- [ConcurrentLinkedDeque](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ConcurrentLinkedDeque.html)
- [LinkedBlockingDeque](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingDeque.html)
- [LinkedList](https://docs.oracle.com/javase/8/docs/api/java/util/LinkedList.html)

线性集合，支持两端的元素插入和移除。Deque是`double ended queue`的简称，习惯上称之为双端队列。大多数Deque 实现对它们可能包含的元素的数量没有固定的限制，但是该接口支持容量限制的deques以及没有固定大小限制的deque。

在大多数实现中，插入操作不会失败。

发音为`deck`,千万因为发音问题出丑哦。

![image-20200802173430514](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200802173430514.png)

Deque同时扩展了Queue接口，当Deque作为队列的时候，会产生FIFO(先进先出)行为。元素添加在双端队列的末尾并从头开始删除。

| Queue 方法 | 等效Deque方法 |
| ---------- | ------------- |
| add(e)     | addLast(e)    |
| offer(e)   | offerLast(e)  |
| remove()   | removeFirst() |
| poll()     | pollFirst()   |
| element()  | getFirst()    |
| peek()     | peekFirst()   |

同时，Deque也可以作为LIFO(后进先出)堆栈,此接口优于传统的Stack类使用。

Stack和Deque方法的比较

| 栈方法  | 等效Deque方法 |
| ------- | ------------- |
| push(e) | addFirst(e)   |
| pop()   | removeFirst() |
| peek()  | peekFirst()   |

与List接口不同，此接口不支持索引访问元素。

这个接口提供了两种方法去除内部元素，removeFirstOccurrence和removeLastOccurrence。

| removeFirstOccurrence(Object o)            | removeLastOccurrence(Object o)             |
| ------------------------------------------ | ------------------------------------------ |
| 从此双端队列中移除指定元素的第一个匹配项。 | 从此双端队列中移除指定元素的最后一次出现。 |

虽然 Deque 实现没有严格要求禁止插入 null 元素，但建议最好这样做。建议任何事实上允许 null 元素的 Deque 实现用户最好不 要利用插入 null 的功能。这是因为各种方法会将null 用作特殊的返回值来指示双端队列为空。

Deque 实现通常不定义基于元素的 equals 和 hashCode 方法，而是从 Object 类继承基于身份的equals 和 hashCode 方法。

**Deque的使用场景**
 在一般情况，不涉及到并发的情况下，有两个实现类，可根据其自身的特性进行选择，分别是：

- LinkedList 大小可变的链表双端队列，允许元素为插入null。
- ArrayDeque 大下可变的数组双端队列，不允许插入null。
- ConcurrentLinkedDeque 大小可变且线程安全的链表双端队列，非阻塞，不允许插入null。
- LinkedBlockingDeque 为线程安全的双端队列，在队列为空的情况下，获取操作将会阻塞，直到有元素添加。



作者：我是吸血鬼
链接：https://www.jianshu.com/p/d78a7c982edb
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 39.[BigDecimal详解](https://www.cnblogs.com/zhangyinhua/p/11545305.html)

```

```

一、BigDecimal概述
 Java在java.math包中提供的API类BigDecimal，用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数，但在实际应用中，可能需要对更大或者更小的数进行运算和处理。一般情况下，对于那些不需要准确计算精度的数字，我们可以直接使用Float和Double处理，但是Double.valueOf(String) 和Float.valueOf(String)会丢失精度。所以开发中，如果我们需要精确计算的结果，则必须使用BigDecimal类来操作。

 BigDecimal所创建的是对象，故我们不能使用传统的+、-、*、/等算术运算符直接对其对象进行数学运算，而必须调用其相对应的方法。方法中的参数也必须是BigDecimal的对象。构造器是类的特殊方法，专门用来创建对象，特别是带有参数的对象。

二、BigDecimal常用构造函数
2.1、常用构造函数
BigDecimal(int)

创建一个具有参数所指定整数值的对象

BigDecimal(double)

创建一个具有参数所指定双精度值的对象

BigDecimal(long)

创建一个具有参数所指定长整数值的对象

BigDecimal(String)

创建一个具有参数所指定以字符串表示的数值的对象

2.2、使用问题分析
使用示例：

        BigDecimal a =new BigDecimal(0.1);
        System.out.println("a values is:"+a);
        System.out.println("=====================");
        BigDecimal b =new BigDecimal("0.1");
        System.out.println("b values is:"+b);
结果示例：

a values is:0.1000000000000000055511151231257827021181583404541015625

b values is:0.1
原因分析：

1）参数类型为double的构造方法的结果有一定的不可预知性。有人可能认为在Java中写入newBigDecimal(0.1)所创建的BigDecimal正好等于 0.1（非标度值 1，其标度为 1），但是它实际上等于0.1000000000000000055511151231257827021181583404541015625。这是因为0.1无法准确地表示为 double（或者说对于该情况，不能表示为任何有限长度的二进制小数）。这样，传入到构造方法的值不会正好等于 0.1（虽然表面上等于该值）。

2）String 构造方法是完全可预知的：写入 newBigDecimal(“0.1”) 将创建一个 BigDecimal，它正好等于预期的 0.1。因此，比较而言， 通常建议优先使用String构造方法。

3）当double必须用作BigDecimal的源时，请注意，此构造方法提供了一个准确转换；它不提供与以下操作相同的结果：先使用Double.toString(double)方法，然后使用BigDecimal(String)构造方法，将double转换为String。要获取该结果，请使用static valueOf(double)方法。

三、BigDecimal常用方法详解
3.1、常用方法
add(BigDecimal)

BigDecimal对象中的值相加，返回BigDecimal对象

subtract(BigDecimal)

BigDecimal对象中的值相减，返回BigDecimal对象

multiply(BigDecimal)

BigDecimal对象中的值相乘，返回BigDecimal对象

divide(BigDecimal)

BigDecimal对象中的值相除，返回BigDecimal对象

toString()

将BigDecimal对象中的值转换成字符串

doubleValue()

将BigDecimal对象中的值转换成双精度数

floatValue()

将BigDecimal对象中的值转换成单精度数

longValue()

将BigDecimal对象中的值转换成长整数

intValue()

将BigDecimal对象中的值转换成整数

3.2、BigDecimal大小比较
java中对BigDecimal比较大小一般用的是bigdemical的compareTo方法

int a = bigdemical.compareTo(bigdemical2)
返回结果分析：

a = -1,表示bigdemical小于bigdemical2；
a = 0,表示bigdemical等于bigdemical2；
a = 1,表示bigdemical大于bigdemical2；
举例：a大于等于b

new bigdemica(a).compareTo(new bigdemical(b)) >= 0
四、BigDecimal格式化
由于NumberFormat类的format()方法可以使用BigDecimal对象作为其参数，可以利用BigDecimal对超出16位有效数字的货币值，百分值，以及一般数值进行格式化控制。

以利用BigDecimal对货币和百分比格式化为例。首先，创建BigDecimal对象，进行BigDecimal的算术运算后，分别建立对货币和百分比格式化的引用，最后利用BigDecimal对象作为format()方法的参数，输出其格式化的货币值和百分比。


    NumberFormat currency = NumberFormat.getCurrencyInstance(); //建立货币格式化引用 
    NumberFormat percent = NumberFormat.getPercentInstance();  //建立百分比格式化引用 
    percent.setMaximumFractionDigits(3); //百分比小数点最多3位 
    
    BigDecimal loanAmount = new BigDecimal("15000.48"); //贷款金额
    BigDecimal interestRate = new BigDecimal("0.008"); //利率   
    BigDecimal interest = loanAmount.multiply(interestRate); //相乘
     
    System.out.println("贷款金额:\t" + currency.format(loanAmount)); 
    System.out.println("利率:\t" + percent.format(interestRate)); 
    System.out.println("利息:\t" + currency.format(interest)); 
结果：

贷款金额: ￥15,000.48 利率: 0.8% 利息: ￥120.00
BigDecimal格式化保留2为小数，不足则补0：

public class NumberFormat {
	
	public static void main(String[] s){
		System.out.println(formatToNumber(new BigDecimal("3.435")));
		System.out.println(formatToNumber(new BigDecimal(0)));
		System.out.println(formatToNumber(new BigDecimal("0.00")));
		System.out.println(formatToNumber(new BigDecimal("0.001")));
		System.out.println(formatToNumber(new BigDecimal("0.006")));
		System.out.println(formatToNumber(new BigDecimal("0.206")));
	}
	/**
	 * @desc 1.0~1之间的BigDecimal小数，格式化后失去前面的0,则前面直接加上0。
	 * 2.传入的参数等于0，则直接返回字符串"0.00"
	 * 3.大于1的小数，直接格式化返回字符串
	 * @param obj传入的小数
	 * @return
	 */
	public static String formatToNumber(BigDecimal obj) {
		DecimalFormat df = new DecimalFormat("#.00");
		if(obj.compareTo(BigDecimal.ZERO)==0) {
			return "0.00";
		}else if(obj.compareTo(BigDecimal.ZERO)>0&&obj.compareTo(new BigDecimal(1))<0){
			return "0"+df.format(obj).toString();
		}else {
			return df.format(obj).toString();
		}
	}
}
结果为：

3.44
0.00
0.00
0.00
0.01
0.21
五、BigDecimal常见异常
5.1、除法的时候出现异常
java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result
原因分析：

 通过BigDecimal的divide方法进行除法时当不整除，出现无限循环小数时，就会抛异常：java.lang.ArithmeticException: Non-terminating decimal expansion; no exact representable decimal result.

解决方法：

 divide方法设置精确的小数点，如：divide(xxxxx,2)

六、BigDecimal总结
6.1、总结
在需要精确的小数计算时再使用BigDecimal，BigDecimal的性能比double和float差，在处理庞大，复杂的运算时尤为明显。故一般精度的计算没必要使用BigDecimal。
尽量使用参数类型为String的构造函数。
BigDecimal都是不可变的（immutable）的， 在进行每一次四则运算时，都会产生一个新的对象 ，所以在做加减乘除运算时要记得要保存操作后的值。
6.2、工具类推荐
package com.vivo.ars.util;
import java.math.BigDecimal;

/**
 * 用于高精确处理常用的数学运算
 */
public class ArithmeticUtils {
    //默认除法运算精度
    private static final int DEF_DIV_SCALE = 10;

    /**
     * 提供精确的加法运算
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */

    public static double add(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.add(b2).doubleValue();
    }

    /**
     * 提供精确的加法运算
     *
     * @param v1 被加数
     * @param v2 加数
     * @return 两个参数的和
     */
    public static BigDecimal add(String v1, String v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.add(b2);
    }

    /**
     * 提供精确的加法运算
     *
     * @param v1    被加数
     * @param v2    加数
     * @param scale 保留scale 位小数
     * @return 两个参数的和
     */
    public static String add(String v1, String v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.add(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();
    }

    /**
     * 提供精确的减法运算
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static double sub(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.subtract(b2).doubleValue();
    }

    /**
     * 提供精确的减法运算。
     *
     * @param v1 被减数
     * @param v2 减数
     * @return 两个参数的差
     */
    public static BigDecimal sub(String v1, String v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.subtract(b2);
    }

    /**
     * 提供精确的减法运算
     *
     * @param v1    被减数
     * @param v2    减数
     * @param scale 保留scale 位小数
     * @return 两个参数的差
     */
    public static String sub(String v1, String v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.subtract(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();
    }

    /**
     * 提供精确的乘法运算
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static double mul(double v1, double v2) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.multiply(b2).doubleValue();
    }

    /**
     * 提供精确的乘法运算
     *
     * @param v1 被乘数
     * @param v2 乘数
     * @return 两个参数的积
     */
    public static BigDecimal mul(String v1, String v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.multiply(b2);
    }

    /**
     * 提供精确的乘法运算
     *
     * @param v1    被乘数
     * @param v2    乘数
     * @param scale 保留scale 位小数
     * @return 两个参数的积
     */
    public static double mul(double v1, double v2, int scale) {
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return round(b1.multiply(b2).doubleValue(), scale);
    }

    /**
     * 提供精确的乘法运算
     *
     * @param v1    被乘数
     * @param v2    乘数
     * @param scale 保留scale 位小数
     * @return 两个参数的积
     */
    public static String mul(String v1, String v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.multiply(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();
    }

    /**
     * 提供（相对）精确的除法运算，当发生除不尽的情况时，精确到
     * 小数点以后10位，以后的数字四舍五入
     *
     * @param v1 被除数
     * @param v2 除数
     * @return 两个参数的商
     */

    public static double div(double v1, double v2) {
        return div(v1, v2, DEF_DIV_SCALE);
    }

    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示表示需要精确到小数点以后几位。
     * @return 两个参数的商
     */
    public static double div(double v1, double v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(Double.toString(v1));
        BigDecimal b2 = new BigDecimal(Double.toString(v2));
        return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).doubleValue();
    }

    /**
     * 提供（相对）精确的除法运算。当发生除不尽的情况时，由scale参数指
     * 定精度，以后的数字四舍五入
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 表示需要精确到小数点以后几位
     * @return 两个参数的商
     */
    public static String div(String v1, String v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v1);
        return b1.divide(b2, scale, BigDecimal.ROUND_HALF_UP).toString();
    }

    /**
     * 提供精确的小数位四舍五入处理
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static double round(double v, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException("The scale must be a positive integer or zero");
        }
        BigDecimal b = new BigDecimal(Double.toString(v));
        return b.setScale(scale, BigDecimal.ROUND_HALF_UP).doubleValue();
    }

    /**
     * 提供精确的小数位四舍五入处理
     *
     * @param v     需要四舍五入的数字
     * @param scale 小数点后保留几位
     * @return 四舍五入后的结果
     */
    public static String round(String v, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b = new BigDecimal(v);
        return b.setScale(scale, BigDecimal.ROUND_HALF_UP).toString();
    }

    /**
     * 取余数
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 小数点后保留几位
     * @return 余数
     */
    public static String remainder(String v1, String v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        return b1.remainder(b2).setScale(scale, BigDecimal.ROUND_HALF_UP).toString();
    }

    /**
     * 取余数  BigDecimal
     *
     * @param v1    被除数
     * @param v2    除数
     * @param scale 小数点后保留几位
     * @return 余数
     */
    public static BigDecimal remainder(BigDecimal v1, BigDecimal v2, int scale) {
        if (scale < 0) {
            throw new IllegalArgumentException(
                    "The scale must be a positive integer or zero");
        }
        return v1.remainder(v2).setScale(scale, BigDecimal.ROUND_HALF_UP);
    }

    /**
     * 比较大小
     *
     * @param v1 被比较数
     * @param v2 比较数
     * @return 如果v1 大于v2 则 返回true 否则false
     */
    public static boolean compare(String v1, String v2) {
        BigDecimal b1 = new BigDecimal(v1);
        BigDecimal b2 = new BigDecimal(v2);
        int bj = b1.compareTo(b2);
        boolean res;
        if (bj > 0)
            res = true;
        else
            res = false;
        return res;
    }
}

### 40.寻找两个有序数列的第k小的元素

```
public int getKthElement(int[] nums1, int[] nums2, int k) {
    /* 主要思路：要找到第 k (k>1) 小的元素，那么就取 pivot1 = nums1[k/2-1] 和 pivot2 = nums2[k/2-1] 进行比较
     * 这里的 "/" 表示整除
     * nums1 中小于等于 pivot1 的元素有 nums1[0 .. k/2-2] 共计 k/2-1 个
     * nums2 中小于等于 pivot2 的元素有 nums2[0 .. k/2-2] 共计 k/2-1 个
     * 取 pivot = min(pivot1, pivot2)，两个数组中小于等于 pivot 的元素共计不会超过 (k/2-1) + (k/2-1) <= k-2 个
     * 这样 pivot 本身最大也只能是第 k-1 小的元素
     * 如果 pivot = pivot1，那么 nums1[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums1 数组
     * 如果 pivot = pivot2，那么 nums2[0 .. k/2-1] 都不可能是第 k 小的元素。把这些元素全部 "删除"，剩下的作为新的 nums2 数组
     * 由于我们 "删除" 了一些元素（这些元素都比第 k 小的元素要小），因此需要修改 k 的值，减去删除的数的个数
     */

    int length1 = nums1.length, length2 = nums2.length;
    int index1 = 0, index2 = 0;
    int kthElement = 0;

    while (true) {
        // 边界情况
        if (index1 == length1) {
            return nums2[index2 + k - 1];
        }
        if (index2 == length2) {
            return nums1[index1 + k - 1];
        }
        if (k == 1) {
            return Math.min(nums1[index1], nums2[index2]);
        }

        // 正常情况
        int half = k / 2;
        int newIndex1 = Math.min(index1 + half, length1) - 1;
        int newIndex2 = Math.min(index2 + half, length2) - 1;
        int pivot1 = nums1[newIndex1], pivot2 = nums2[newIndex2];
        if (pivot1 <= pivot2) {
            k -= (newIndex1 - index1 + 1);
            index1 = newIndex1 + 1;
        } else {
            k -= (newIndex2 - index2 + 1);
            index2 = newIndex2 + 1;
        }
    }
}
```





### 41.字典序案例

#### 一、字典序

字典序，就是按照字典中出现的先后顺序进行排序。

1、单个字符

在计算机中，25个字母以及数字字符，字典排序如下：

> ```
> '0' < '1' < '2' < ... < '9' < 'a' < 'b' < ... < 'z'
> ```

比如在 python 中， `'0' < '9' < 'a' < 'z'` 这个表达式就会返回 `True`。

2、多个字符

这是单个字符的大小情况，那么如果是两个字符串比较大小呢？在计算机中，两个字符串比较大小，是按照从左到右的顺序进行比较，如果第1位相等，就比较第2位，直至有一位可以比较出大小来，则不再继续比较。

使用计算机属于来描述：

> 对于任意两个序列 (a,b) 和 (a’,b’)，字典序定义为： `(a,b) ≤ (a′,b′)` 当且仅当 `a < a′` 或 `(a = a′ 且 b ≤ b′)`.

比如在 python 中，`'ab' < 'ac'`、`'abc' < 'ac'`、`'abc' < 'abcd'` 都会返回 `True`。

3、全排列的字典序

给定多个字符，可以按照任意顺序进行排列，所有排列称为全排列。

每一种排列对应一个字符串，如果这些字符串按照字符串大小的顺序进行排序，那么就这种排序是基于字典序的全排列。

比如给定三个字符 `a,b,c`，则他们基于字典序的全排列为：
`abc > acb > bac > bca > cab > cba`

##### 二、字典序算法

字典序算法用来解决这样一个问题：给定其中一种排列，求基于字典序的下一种排列。

比如给定一种排列为 `abc`，则其基于字典序的下一种排列为 `acb`。

要求下一种排列既要比原排列大，又不能有第三种排列位于他俩之间。即下一种排列为大于原排列的最小排列。

【例】 如何得到346987521的下一个
    1，从尾部往前找第一个P(i-1) < P(i)的位置
            3 4 6 < 9 < 8 <  7 <  5 < 2 < 1
        最终找到6是第一个变小的数字，记录下6的位置i-1
    2，从i位置往后找到最后一个大于6的数
            3 4 6 -> 9 -> 8 -> 7 5 2 1
        最终找到7的位置，记录位置为m
    3，交换位置i-1和m的值
            3 4 7 9 8 6 5 2 1
    4，倒序i位置后的所有数据
            3 4 7 1 2 5 6 8 9
    则347125689为346987521的下一个排列

以输入为 `358764` 为例，字典序算法的步骤：
1、从原排列中，从右至左，找到第一个左邻小于右邻的字符，记左邻位置为 a。
示例中 a=1，list[a] = 5。
2、重新从右至左，找到第一个比 list[a] 大的字符，记为位置为 b。
示例中 b=4，list[b] = 6。
3、交换 a 和 b 两个位置的值。
示例变为了 `368754`。
4、将 a 后面的数，由小到大排列。
示例变为了 `364578`。

算法结束，输出 `364578`。

注意：
1、第1步中，如果找不到左邻小于右邻的数，则说明给定的排列已经是全排列的最后一个排列了，则直接返回全排列的第一个排列，即所有排列中最小的排列，形成一个循环。
2、在第3步交换前，a 后面的数是按照从大到小进行排列（否则第1步中就可以找到左邻小于右邻的数了）。
3、在交换之后，a 后面的数仍然是按照从大到小排列的，尽管 b 位置的值变成了 list[a]，但是由于 b 位置是第一个比 list[a] 大的，因此交换之后 list[a] 仍然比左邻小，比右邻大。
4、既然 a 后面的数是从大到小排列的，那么第4步的排序，直接将 a 后面的数倒序即可。

算法的时间复杂度为 O(n) + O(n) + O(n) = O(n)。

`1,2,3` 的全排列的示例：

![image-20200804152119821](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200804152119821.png)





​           

```java
  public  void PermutationWithDictionary(char chs[])
    {
        Arrays.sort(chs);
        //先对数组的元素进行依次排序
        while(true)
        {
            System.out.println(chs);
            int j=chs.length-1;
            int index=0;
            for(j=chs.length-2;j>=0;j--)
            {
                if(chs[j]<chs[j+1])
                {
                    index=j;
                    break;
                    //从右向左找到第一个非递增的元素
                }
                else if(j==0){
                    return;
                }
            }     

for(j=chs.length-1;j>=0;j--)
        {
            if(chs[j]>chs[index])
                break;
                //从右向左找到第一个比非递增元素大的元素
        }
            Swap(chs,index,j);
            //交换找到的两个元素
            Reverse(chs,index+1);
            //对非递增元素位置后面的数组进行逆序排列
    }       
}
public static void Reverse(char chs[],int i)
{
    int k=i,j=chs.length-1;
    while(k<j)
    {
        Swap(chs,k,j);
        k++;
        j--;
    }
}
 
public static void Swap(char chs[],int i,int j)
{
    char temp;
    temp=chs[i];
    chs[i]=chs[j];
    chs[j]=temp;
}
```
**递归算法：**

 

固定第一个字符，然后依次将后面的字符串与前面的交换，那么排列的个数就是除了第一个字符以外，其他字符的排列个数+1。也就是固定一个字符串之后，之后再将问题变小，只需求出后面子串的排列个数就可以得出结果。

![image-20200804153331551](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200804153331551.png)

递归的出口，就是只剩一个字符的时候，递归的循环过程，就是从每个子串的第二个字符开始依次与第一个字符交换，然后继续处理子串。

```
public static void main (String[] args){
        Solution p = new Solution();
        System.out.println(p.Permutation("abc").toString());
    }
    public ArrayList<String> Permutation(String str) {
        List <String> res = new ArrayList();
        if (str != null&& str.length() > 0 ){
            per(str.toCharArray(),0,res);
            Collections.sort(res);
        }
        return (ArrayList)res;
    }
    public void per(char[] ch, int i,List<String> res){
        if ( i == ch.length-1){
            String val =String.valueOf(ch);
            if (!res.contains(val))//判断是否重复，重复则不加入
                res.add(val);
        }
        else{for (int j = i ;j<ch.length;j++){
        swap(ch,i,j);
        per(ch,i+1,res);
        swap(ch,i,j);
    }}}
 
     public void swap(char[] cs, int i, int j) {
        char temp = cs[i];
        cs[i] = cs[j];
        cs[j] = temp;
    }
```



##### 三、案例

方法二：一遍扫描
算法

首先，我们观察到对于任何给定序列的降序，没有可能的下一个更大的排列。

例如，以下数组不可能有下一个排列：

[9, 5, 4, 3, 1]
我们需要从右边找到第一对两个连续的数字 a[i] 和 a[i-1]，它们满足 a[i]>a[i-1]。现在，没有对 a[i-1] 右侧的重新排列可以创建更大的排列，因为该子数组由数字按降序组成。因此，我们需要重新排列 a[i-1] 右边的数字，包括它自己。

现在，什么样子的重新排列将产生下一个更大的数字呢？我们想要创建比当前更大的排列。因此，我们需要将数字 a[i-1] 替换为位于其右侧区域的数字中比它更大的数字，例如 a[j]。

![image-20200804153439954](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200804153439954.png)

我们交换数字 a[i-1] 和 a[j]。我们现在在索引 i-1 处有正确的数字。 但目前的排列仍然不是我们正在寻找的排列。我们需要通过仅使用 a[i-1]右边的数字来形成最小的排列。 因此，我们需要放置那些按升序排列的数字，以获得最小的排列。

但是，请记住，在从右侧扫描数字时，我们只是继续递减索引直到我们找到 a[i] 和 a[i-1] 这对数。其中，a[i] > a[i-1]。因此，a[i-1] 右边的所有数字都已按降序排序。此外，交换 a[i-1] 和 a[j]并未改变该顺序。因此，我们只需要反转 a[i-1] 之后的数字，以获得下一个最小的字典排列。





```java
class Solution {
        public void nextPermutation(int[] nums) {
            int i=nums.length-2;
            while (i>=0&&nums[i]=>nums[i+1]){//从右往左找到第一个左边比右边大的值，3 4 6 < 9 < 8 <  7 <  5 < 2 < 1
                i--;
            }
            if (i>0){//如果不是第一个，从右往左找第一个大于i的值3 4 6 -> 9 -> 8 -> 7 5 2 1
                int j = nums.length - 1;
                while (j >= 0 && nums[j] <= nums[i]) {
                    j--;
                }
                swap(nums, i, j);//交换这两个数的位置  3 4 7 9 8 6 5 2 1


            }
            reverse(nums, i + 1);
//            倒序i位置后的所有数据
//            3 4 7 1 2 5 6 8 9
//            则347125689为346987521的下一个排列

        }
        private void reverse(int[] nums, int start) {
            int i = start, j = nums.length - 1;
            while (i < j) {
                swap(nums, i, j);
                i++;
                j--;
            }
        }

        private void swap(int[] nums, int i, int j) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
        
    }
```



### 42.回文串

#### 一、回文对

![image-20200813151259579](1.LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200813151259579.png)

![image-20200806162653375](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200806162653375.png)

![image-20200806162711269](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200806162711269.png)

![image-20200806162721163](LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/image-20200806162721163.png)

```java
class Solution {
    class Node {
        int[] ch = new int[26];
        int flag;

        public Node() {
            flag = -1;
        }
    }

    List<Node> tree = new ArrayList<Node>();

    public List<List<Integer>> palindromePairs(String[] words) {
        tree.add(new Node());
        int n = words.length;
        for (int i = 0; i < n; i++) {
            insert(words[i], i);
        }
        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        for (int i = 0; i < n; i++) {
            int m = words[i].length();
            for (int j = 0; j <= m; j++) {
                if (isPalindrome(words[i], j, m - 1)) {
                    int leftId = findWord(words[i], 0, j - 1);
                    if (leftId != -1 && leftId != i) {
                        ret.add(Arrays.asList(i, leftId));
                    }
                }
                if (j != 0 && isPalindrome(words[i], 0, j - 1)) {
                    int rightId = findWord(words[i], j, m - 1);
                    if (rightId != -1 && rightId != i) {
                        ret.add(Arrays.asList(rightId, i));
                    }
                }
            }
        }
        return ret;
    }

    public void insert(String s, int id) {
        int len = s.length(), add = 0;
        for (int i = 0; i < len; i++) {
            int x = s.charAt(i) - 'a';
            if (tree.get(add).ch[x] == 0) {
                tree.add(new Node());
                tree.get(add).ch[x] = tree.size() - 1;
            }
            add = tree.get(add).ch[x];
        }
        tree.get(add).flag = id;
    }

    public boolean isPalindrome(String s, int left, int right) {
        int len = right - left + 1;
        for (int i = 0; i < len / 2; i++) {
            if (s.charAt(left + i) != s.charAt(right - i)) {
                return false;
            }
        }
        return true;
    }

    public int findWord(String s, int left, int right) {
        int add = 0;
        for (int i = right; i >= left; i--) {
            int x = s.charAt(i) - 'a';
            if (tree.get(add).ch[x] == 0) {
                return -1;
            }
            add = tree.get(add).ch[x];
        }
        return tree.get(add).flag;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/palindrome-pairs/solution/hui-wen-dui-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



```java
class Solution {
    List<String> wordsRev = new ArrayList<String>();
    Map<String, Integer> indices = new HashMap<String, Integer>();

    public List<List<Integer>> palindromePairs(String[] words) {
        int n = words.length;
        for (String word: words) {
            wordsRev.add(new StringBuffer(word).reverse().toString());
        }
        for (int i = 0; i < n; ++i) {
            indices.put(wordsRev.get(i), i);
        }

        List<List<Integer>> ret = new ArrayList<List<Integer>>();
        for (int i = 0; i < n; i++) {
            String word = words[i];
            int m = words[i].length();
            if (m == 0) {
                continue;
            }
            for (int j = 0; j <= m; j++) {
                if (isPalindrome(word, j, m - 1)) {
                    int leftId = findWord(word, 0, j - 1);
                    if (leftId != -1 && leftId != i) {
                        ret.add(Arrays.asList(i, leftId));
                    }
                }
                if (j != 0 && isPalindrome(word, 0, j - 1)) {
                    int rightId = findWord(word, j, m - 1);
                    if (rightId != -1 && rightId != i) {
                        ret.add(Arrays.asList(rightId, i));
                    }
                }
            }
        }
        return ret;
    }

    public boolean isPalindrome(String s, int left, int right) {
        int len = right - left + 1;
        for (int i = 0; i < len / 2; i++) {
            if (s.charAt(left + i) != s.charAt(right - i)) {
                return false;
            }
        }
        return true;
    }

    public int findWord(String s, int left, int right) {
        return indices.getOrDefault(s.substring(left, right + 1), -1);
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/palindrome-pairs/solution/hui-wen-dui-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### 二、马拉车算法

https://leetcode-cn.com/problems/palindromic-substrings/solution/hui-wen-zi-chuan-by-leetcode/

### 43.java中的两种排序工具Arrays和Collections的使用

java中的排序工具主要是有两个Arrays和Collections。我们一个一个来讲解。

本来写好了每一种方法的测试代码，后来又给删了，因为我觉得如果想要去了解的话，可以直接查看这些常用的即可。因为使用起来真的太简单。篇幅太长也不好。

#### 一、Arrays

Arrays类位于 java.util 包中，主要包含了操纵数组的各种方法。

1、Array.sort(Object[] array)：

对数组按照升序排序

2、Arrays.sort(Object[] array, int from, int to)：

对数组元素指定范围进行排序（排序范围是从元素下标为from,到下标为to-1的元素进行排序

3、Arrays.fill(Object[] array,Object object)：

可以为数组元素填充相同的值

4、Arrays.fill(Object[] array,int from,int to,Object object)：

对数组的部分元素填充一个值,从起始位置到结束位置，取头不取尾

5、Arrays.toString(Object[] array)：

返回数组的字符串形式

6、Arrays.deepToString(Object[][] arrays)：

返回多维数组的字符串形式。

7、Arrays.binarySearch(Object[] array,element);

在数组array中查找element。并返回下表

#### 二、Collections

Collections是针对集合类的一个帮助类，它提供了一系列静态方法实现了对各种集合的排序，搜索和线程安全等操作。

1.Shuffle（element）：洗牌方法，将当前集合内的数据进行随机排序。

2.Reverse（element）：逆序排序，对当前集合的元素按照相反的顺序进行排序

3.Sort（element）：对当前集合进行升序排序,实现Comparable接口的类，只能使用一种排序方案，这种方案叫作“自然比较”方案。

4.binarySearch(Collection,Object):查找指定集合中的元素，返回所查找元素的索引

5.max(Collection),max(Collection,Comparator)：

前者采用Collection内含自然比较法，后者采用Comparator进行比较

6、indexOfSubList(List list,List subList)

查找subList在list中首次出现位置的索引

7、replaceAll(List list,Object old,Object new)：

替换批定元素为某元素,若要替换的值存在刚返回true,反之返回false

8、rotate(List list,int m)：

集合中的元素向后移m个位置，在后面被遮盖的元素循环到前面来

9、copy(List m,List n)：

将集合n中的元素全部复制到m中,并且覆盖相应索引的元素

#### java.util.Collections.reverseOrder()方法实例

![img](1.LeetCode%E5%88%B7%E9%A2%98%E6%80%BB%E7%BB%93.assets/20170925171253418.png)

使用Collections.reverse结合一定方法可以实现对list集合降序排序，但是直接使用Collections.reverse(list)这种方式来降序是错误的。
reverse的意思是反转，而不是降序。只是将list集合原来的顺序反转了一下，反转并不意味着降序了。所以要想实现降序，可以先对集合进行升序，然后再反转，这样就降序了。
举个例子：

```
import java.util.*;

public class Test {
  private static Map<Integer, String> map = new HashMap<Integer, String>();

  public static void main(String[] args) {
    long[] data = {1506326821000l, 1506327060000l, 1506326880000l, 1506327000000l, 1506326940000l, 1506326760000l, 1506326700000l};
    List list = new ArrayList<>();
    for (long key : data) {
      list.add(key);
    }
    System.out.println(list);
    //先升序
    Collections.sort(list);
    System.out.println(list);
    //再反转
    Collections.reverse(list);
    System.out.println(list);
  }
}
```





```
下面的例子显示java.util.Collections.reverseOrder()方法的使用

package com.yiibai;

import java.util.*;

public class CollectionsDemo {
   public static void main(String args[]) {  
      // create linked list object  	   
      LinkedList list = new LinkedList();  
      
      // populate the list 
      list.add(-28);  
      list.add(20);  
      list.add(-12);  
      list.add(8);  
      
      // create comparator for reverse order
      Comparator cmp = Collections.reverseOrder();  

      // sort the list
      Collections.sort(list, cmp);  
		  
      System.out.println("List sorted in ReverseOrder: ");      
      for(int i : list){
         System.out.println(i+ " ");
      }	
   }
}
现在编译和运行上面的代码示例，将产生以下结果。

List sorted in ReverseOrder: 
20 
8 
-12 
-28
```



### 44.java 两种比较器的详细介绍及实例

https://blog.csdn.net/u012289441/article/details/45154401?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.edu_weight

\1. Comparator 和 Comparable 相同的地方

他们都是java的一个接口, 并且是用来对自定义的class比较大小的,

如 StringList{"hello1" , "hello3" , "hello2"}, Collections.sort( stringList ) 能够得到正确的排序, 那是因为
String 这个对象已经帮我们实现了 Comparable接口 , 所以我们的 Person 如果想排序, 也要实现一个比较器。

\2. Comparator 和 Comparable 的区别

**Comparable**

Comparable 定义在 Person类的内部:

public class Persion implements Comparable {..比较Person的大小..},

因为已经实现了比较器,那么我们的Person现在是一个可以比较大小的对象了,它的比较功能和String完全一样,可以随时随地的拿来
比较大小,因为Person现在自身就是有大小之分的。Collections.sort(personList)可以得到正确的结果。

**Comparator**

Comparator 是定义在Person的外部的, 此时我们的Person类的结构不需要有任何变化,如

public class Person{ String name; int age },

然后我们另外定义一个比较器:

public PersonComparator implements Comparator() {..比较Person的大小..},

在PersonComparator里面实现了怎么比较两个Person的大小. 所以,用这种方法,当我们要对一个 personList进行排序的时候,
我们除了了要传递personList过去, 还需要把PersonComparator传递过去,因为怎么比较Person的大小是在PersonComparator
里面实现的, 如:



Collections.sort( personList , new PersonComparator() ).

```java
package com.kk.Collection;
 
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
 
public class CompareTest {
    public static void main(String[] args) {
        List<Student> list=new ArrayList<Student>(10);
        list.add(new Student(1,"jj"));
        list.add(new Student(0,"ww"));
        list.add(new Student(0,"kk"));
        list.add(new Student(2,"ll"));
        Collections.sort(list); //内部比较器:要排序的对象实现Comparable接口,可以对自身进行比较
        System.out.println(list);
        
        List<Teacher> t=new ArrayList<Teacher>(10);
        t.add(new Teacher(1,12));
        t.add(new Teacher(0,13));
        t.add(new Teacher(0,14));
        t.add(new Teacher(2,15));
        Collections.sort(t,new StudentComparator()); //外部比较器:通过实现Comparator接口
        System.out.println(t);
    }
}
 
class Student implements Comparable {
    int num;
 
    String name;
 
    public Student(int num, String name) {
        this.num = num;
        this.name = name;
    }
    
    @Override
    public String toString() {
        return "\r\tnum:"+num+" name:"+name+"\r";
    }
 
    public int compareTo(Object o) {
        Student tmp=(Student) o;
        int result=tmp.num>num?1:(tmp.num==num?0:-1);
        if (result==0) {
            result=tmp.name.indexOf(0)>name.indexOf(0)?1:-1;
        }
        return result;
    }
}
 
class Teacher{
    int num;
 
    double salary;
    
    public Teacher(int num, double salary) {
        this.num = num;
        this.salary = salary;
    }
 
    @Override
    public String toString() {
        return "\r\tnum:"+num+" salary:"+salary+"\r";
    }    
}
 
class StudentComparator implements Comparator{
 
    public int compare(Object o1, Object o2) {
        Teacher t1=(Teacher) o1;
        Teacher t2=(Teacher) o2;
        int result=t1.num>t2.num?1:(t1.num==t2.num?0:-1);
        return result=result==0?(t1.salary<t2.salary?1:-1):result;
    }
    
}
```

### 45.基本类型占用字节

1.字节：byte：用来计量存储容量的一种计量单位；位：bit

2.一个字节等于8位  1byte = 8bit

char占用的是2个字节 16位，所以一个char类型的可以存储一个汉字。

整型：

byte:1个字节 8位 -128~127

short ：2个字节 16位

int ：4个字节 32位

long：8个字节 64位

浮点型：

float：4个字节 32 位

double ：8个字节 64位

注：默认的是double类型，如3.14是double类型的，加后缀F（3.14F）则为float类型的。

char类型：

char：2个字节。

Boolean 类型

boolean: （true or false）（并未指明是多少字节  1字节  1位 4字节）

补充：BigInteger类实现了任意精度的整数运算，BigDecimal实现了任意精度的浮点数运算。

### 46.Math常用方法

*n**u**m**s*[∣*n**u**m**s*[*i*]∣−1]×−1 

#### 1.Math.abs()

```
public static int abs(int a)
```

返回 `int` 值的绝对值。如果参数为非负数，则返回该参数。如果参数为负数，则返回该参数的相反数。

注意，如果参数等于 `Integer.MIN_VALUE` 的值（即能够表示的最小负 `int` 值），那么结果与该值相同且为负。

如下代码：

int a=Integer.MIN_VALUE;
System.out.println(a);//-2147483648
int num=Math.abs(a);
System.out.println(num);//-2147483648

因为最大值为2147483647，而绝对值为2147483648已经溢出，+1后变为最小值

**参数：**

`a` - 要确定绝对值的参数。

**返回：**

参数的绝对值。

```
public static long abs(long a)
```

返回 `long` 值的绝对值。如果参数为非负数，则返回该参数。如果参数为负数，则返回该参数的相反数。

注意，如果参数等于 `Long.MIN_VALUE` 的值（即能够表示的最小负 `long` 值），则结果与该值相同且为负。



- **参数：**

  `a` - 要确定绝对值的参数。

- **返回：**

  参数的绝对值。

- **另请参见：**

  [`Long.MIN_VALUE`](http://www.javaweb.cc/help/JavaAPI1.6/java/lang/Long.html#MIN_VALUE)

  ```
  public static float abs(float a)
  ```

返回 `float` 值的绝对值。如果参数为非负数，则返回该参数。如果参数为负数，则返回该参数的相反数。特殊情况如下：

- 如果参数为正 0 或负 0，那么结果为正 0。
- 如果参数为无穷大，那么结果为正无穷大。
- 如果参数为 NaN，那么结果为 NaN。

换句话说，结果等于以下表达式的值：



```
Float.intBitsToFloat(0x7fffffff & Float.floatToIntBits(a))
```



- **参数：**

  `a` - 要确定绝对值的参数。

- **返回：**

  参数的绝对值。

```
public static double abs(double a)
```

返回 `double` 值的绝对值。如果参数为非负数，则返回该参数。如果参数为负数，则返回该参数的相反数。特殊情况如下：

- 如果参数为正 0 或负 0，那么结果为正 0。
- 如果参数为无穷大，那么结果为正无穷大。
- 如果参数为 NaN，那么结果为 NaN。

换句话说，结果等于以下表达式的值：

```
Double.longBitsToDouble((Double.doubleToLongBits(a)<<1)>>>1)
```



- **参数：**

  `a` - 要确定绝对值的参数。

- **返回：**

  参数的绝对值。