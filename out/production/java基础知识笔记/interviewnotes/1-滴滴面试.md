**先问[项目]()，问了我布隆过滤器是处理什么内容的，怎么触发。我回答缓存穿透，讲了讲缓存穿透的场景，讲了讲布隆过滤器的使用原理，但是怎么触发我不了解就没说。** 

  布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。

具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。

加入布隆过滤器之后的缓存处理流程图如下。 

![image](1-%E6%BB%B4%E6%BB%B4%E9%9D%A2%E8%AF%95.assets/%E5%8A%A0%E5%85%A5%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8%E5%90%8E%E7%9A%84%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png)

  ======================================

问了我怎么处理[redis]()和数据库的一致性，我说用update操作时的双重延迟删除，问我缓存命中率，我说不了解，[项目]()比较小，没必要搞这些花里胡哨的，再问[项目]()是不是没有必要用[redis]()，答是，只是当作练手。 

  细说的话可以扯很多，但是我觉得其实没太大必要（小声BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。

下面单独对 **Cache Aside Pattern（旁路缓存模式）** 来聊聊。

Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。

如果更新数据库成功，而**删除缓存**这一步失败的情况的话，简单说两个解决方案：

1. **缓存失效时间变短（不推荐，治标不治本）** ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。
2. **增加cache更新重试机制（常用）**： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。

======================================================

  简历上写了线程池，问了我四个拒绝策略。 

  
 

  狂问数据库索引优化，问我怎么优化为什么这么优化，怎么避免回表，这段答得不是很好，毕竟没有真的优化过，但是基本流程答出来了。 

  
 

  手撕[算法]()，Leetcode 647，回文子串中等难度，做过所以五分钟就写出来了。 

  给一个无序数组求第K大的数值，答快排和堆排，接着问堆排内容，答了堆的数据结构和[算法]()复杂度，这段没有手撕就答了思路（幸好没有手撕，我没怎么写过堆[排序]()手撕可能要出事）。 

  问给一个select怎么建立索引，主要考察联合索引内容和索引失效情况。 

 
 

  问范型，这段没答的特别好，但是还是答出来了，不过没有什么条理，毕竟半年前看过的东西，问范型是什么，问范型有什么缺点，最后漏了一点，面试官提示我反射获取范型类对象会获取什么。









后端 

  一面 

 1、[算法]() [手撕二分查找]() 这个比较容易 

  2、[算法]() 复制一个[链表]()，这个[链表]()三个指针，val next 还有一个random随机指向任意一个节点 

  我想的方法先复制正常的[链表]()，不管random节点。然后是用[哈希表]()存储 random指针指向的节点。 

  3、[项目]()经历 随便聊聊，感觉面试官对我[项目]()也不了解，没有问出什么。 

  4、数据库索引，b树b+树啥关系 



  5、给了一个联合索引，问查找了几次，这个我真是忘了联合索引的意思了。 



  6、乐观锁悲观锁 

当要对数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。这种借助数据库锁机制，在修改数据之前先锁定，再修改的方式被称之为悲观并发控制【Pessimistic Concurrency Control，缩写“PCC”，又名“悲观锁”】。

2️⃣**悲观锁主要分为[共享锁和排他锁](https://www.jianshu.com/p/b4731a7d255a)：**

- 共享锁【shared locks】又称为读锁，简称S锁。顾名思义，共享锁就是多个事务对于同一数据可以共享一把锁，都能访问到数据，但是只能读不能修改。
- 排他锁【exclusive locks】又称为写锁，简称X锁。顾名思义，排他锁就是不能与其他锁并存，如果一个事务获取了一个数据行的排他锁，其他事务就不能再获取该行的其他锁，包括共享锁和排他锁，但是获取排他锁的事务是可以对数据行读取和修改。

3️⃣说明
 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会。另外还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。

 乐观锁：

1️⃣理解
 乐观锁是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则返回给用户错误的信息，让用户决定如何去做。乐观锁适用于读操作多的场景，这样可以提高程序的吞吐量。

乐观锁机制采取了更加宽松的加锁机制。乐观锁是相对悲观锁而言，也是为了避免数据库幻读、业务处理时间过长等原因引起数据处理错误的一种机制，但乐观锁不会**刻意使用数据库本身的锁机制，而是依据数据本身来保证数据的正确性**。乐观锁的实现：

1. [CAS 实现](https://www.jianshu.com/p/98220486426a)：Java 中java.util.concurrent.atomic包下面的**原子变量**使用了乐观锁的一种 CAS 实现方式。
2. 版本号控制：一般是在数据表中加上一个数据版本号 version 字段，表示数据被修改的次数。当数据被修改时，version 值会+1。当线程A要更新数据值时，在读取数据的同时也会读取 version 值，在提交更新时，若刚才读取到的 version 值与当前数据库中的 version 值相等时才更新，否则重试更新操作，直到更新成功。

2️⃣说明
 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。



  7、mvcc 

MVCC(Mutil-Version Concurrency Control)，就是**多版本并发控制**。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。

在Mysql的InnoDB引擎中就是指在**已提交读(READ COMMITTD)和可重复读**(REPEATABLE READ)这**两种隔离级别下的事务**对于SELECT操作会访问版本链中的记录的过程。

这就使得别的事务可以修改这条记录，反正每次修改都会在版本链中记录。SELECT可以去版本链中拿记录，这就实现了读-写，写-读的并发执行，提升了系统的性能。

###### MVCC带来的好处是？

多版本并发控制（MVCC）是一种用来解决**读-写冲突**的无锁并发控制，也就是为事务分配单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。 所以MVCC可以为数据库解决以下问题

- 在并发读写数据库时，可以做到在读操作时不用阻塞写操作，写操作也不用阻塞读操作，提高了数据库并发读写的性能
- 同时还可以解决脏读，幻读，不可重复读等事务隔离问题，但不能解决**更新丢失**问题



  8、[redis]()随便问了问，[redis]()的string和c语言的string的区别 





  9、观察者模式 



  10、计网内容 比如http返回码 401 402 403 502的意思，有几个记不清了。 

| 分类 | 分类描述                                       |
| :--- | :--------------------------------------------- |
| 1**  | 信息，服务器收到请求，需要请求者继续执行操作   |
| 2**  | 成功，操作被成功接收并处理                     |
| 3**  | 重定向，需要进一步的操作以完成请求             |
| 4**  | 客户端错误，请求包含语法错误或无法完成请求     |
| 5**  | 服务器错误，服务器在处理请求的过程中发生了错误 |

- 200 - 请求成功

- 301 - 资源（网页等）被永久转移到其它URL

- 404 - 请求的资源（网页等）不存在

- 500 - 内部服务器错误

- | 502  | Bad Gateway | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应 |
  | ---- | ----------- | ------------------------------------------------------------ |
  |      |             |                                                              |

| 400  | Bad Request      | 客户端请求的语法错误，服务器无法理解                         |
| ---- | ---------------- | ------------------------------------------------------------ |
| 401  | Unauthorized     | 请求要求用户的身份认证                                       |
| 402  | Payment Required | 保留，将来使用                                               |
| 403  | Forbidden        | 服务器理解请求客户端的请求，但是拒绝执行此请求               |
| 404  | Not Found        | 服务器无法根据客户端的请求找到资源（网页）。通过此代码，网站设计人员可设置"您所请求的资源无法找到"的个性页面 |

| 301  | Moved Permanently | 永久移动。请求的资源已被永久的移动到新URI，返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替 |
| ---- | ----------------- | ------------------------------------------------------------ |
| 302  | Found             | 临时移动。与301类似。但资源只是临时被移动。客户端应继续使用原有URI |

  11、高并发如何保证数据安全性。 



  12、反问

作者：奔驰201811071856977
链接：https://www.nowcoder.com/discuss/450893?type=post&order=time&pos=&page=1&channel=1009&source_id=search_post
来源：牛客网



二面 

  1、用面向对象的方法解决一个问题 母牛 生小母牛，小母牛五年长成母牛，最后50年以后多少母牛，自己用面向对象的方法解决问题 

  2、数据库mysql 写sql语句，一个表挑出成绩排名前多少的同学还有一些其他要求，具体记不清了。 

  3、python装饰器（这因为我上一段实习是python工程师，所以问了问python） 

  4、python和C语言区别

string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 **简单动态字符串**（simple dynamic string，**SDS**）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。

### sleep和wait的区别

https://blog.csdn.net/qq_20009015/article/details/89980966

对于sleep()方法，我们首先要知道该方法是属于Thread类中的。而wait()方法，则是属于Object类中的。

sleep()方法导致了程序暂停执行指定的时间，让出cpu该其他线程，但是他的监控状态依然保持者，当指定的时间到了又会自动恢复运行状态。

在调用sleep()方法的过程中，线程不会**释放对象锁**。

而当调用wait()方法的时候，**线程会放弃对象锁，进入等待此对象的等待锁定池**，只有针对此对象调用notify()方法后本线程才进入对象锁定池准备

从使用角度看，**sleep是Thread线程类的方法，而wait是Object顶级类**的方法。

**sleep可以在任何地方使用，而wait只能在同步方法或者同步块中使用**。

CPU及资源锁释放

sleep,wait调用后都会暂停当前线程并让出cpu的执行时间，但不同的是sleep不会释放当前持有的对象的锁资源，到时间后会继续执行，而wait会放弃所有锁并需要notify/notifyAll后重新获取到对象锁资源后才能继续执行。

sleep和wait的区别：
1、sleep是Thread的静态方法，wait是Object的方法，任何对象实例都能调用。
2、**sleep不会释放锁，它也不需要占用锁。wait会释放锁，但调用它的前提是当前线程占有锁(即代码要在synchronized中)。**
3、它们都可以被interrupted方法中断。

具体来说：

Thread.Sleep(1000) 意思是在未来的1000毫秒内本线程不参与CPU竞争，1000毫秒过去之后，这时候也许另外一个线程正在使用CPU，那么这时候操作系统是不会重新分配CPU的，直到那个线程挂起或结束，即使这个时候恰巧轮到操作系统进行CPU 分配，那么当前线程也不一定就是总优先级最高的那个，CPU还是可能被其他线程抢占去。另外值得一提的是Thread.Sleep(0)的作用，就是触发操作系统立刻重新进行一次CPU竞争，竞争的结果也许是当前线程仍然获得CPU控制权，也许会换成别的线程获得CPU控制权。

wait(1000)表示将锁释放1000毫秒，到时间后如果锁没有被其他线程占用，则再次得到锁，然后wait方法结束，执行后面的代码，如果锁被其他线程占用，则等待其他线程释放锁。注意，设置了超时时间的wait方法一旦过了超时时间，并不需要其他线程执行notify也能自动解除阻塞，但是如果没设置超时时间的wait方法必须等待其他线程执行notify。
![在这里插入图片描述](1-%E6%BB%B4%E6%BB%B4%E9%9D%A2%E8%AF%95.assets/2019050816141738.png)

### B树与B+树的区别以及在MySQL数据库中的应用

> ### M阶B树（B-树）特点

1. 一种二叉搜索树。
2. 除根节点外的所有非叶节点至少含有（**M/2（向上取整）-1**）个关键字，每个节点最**多有M-1**个关键字，并且以**升序排列**。所以M阶B树的除根节点外的所有非叶节点的关键字取值区间为**[M/2-1(向上取整),M-1]**。
3. 每个节点最多有M-1个关键字。

B树

 每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。

 ![img](1-%E6%BB%B4%E6%BB%B4%E9%9D%A2%E8%AF%95.assets/20170920132504569)

 

B+树

 只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。

 ![img](1-%E6%BB%B4%E6%BB%B4%E9%9D%A2%E8%AF%95.assets/20170920132523536)

> ### B树与B+树的区别

- B树每个节点都存储数据，所有节点组成这棵树。B+树只有叶子节点存储数据（B+数中有两个头指针：一个指向根节点，另一个指向关键字最小的叶节点），叶子节点包含了这棵树的所有数据，所有的叶子结点使用链表相连，便于区间查找和遍历，所有非叶节点起到索引作用。
- B树中叶节点包含的关键字和其他节点包含的关键字是不重复的，B+树的索引项只包含对应子树的最大关键字和指向该子树的指针，不含有该关键字对应记录的存储地址。
- B树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整)-1,m-1](根节点为[1,m-1])，并且具有n个关键字的节点包含（n+1）棵子树。B+树中每个节点（非根节点）关键字个数的范围为[m/2(向上取整),m](根节点为[1,m])，具有n个关键字的节点包含（n）棵子树。
- B+树中查找，无论查找是否成功，每次都是一条从根节点到叶节点的路径。



### java堆栈大小设置相关

| 参数                         | 描述                                   |
| ---------------------------- | -------------------------------------- |
| -Xms                         | 设置初始 Java 堆大小                   |
| -Xmx                         | 设置最大的java堆大小                   |
| -Xmn                         | 设置Young区大小                        |
| -Xss                         | 设置java线程堆栈大小                   |
| -Xoss                        | 设置本地方法栈大小                     |
| -Dproject.name=${admin-web}  | 指定工程名称                           |
| -XX:PermSize and MaxPermSize | 设置持久带的大小                       |
| -XX:NewRatio                 | 设置年轻代和老年代的比值               |
| -XX:NewSize                  | 设置年轻代的大小                       |
| -XX:SurvivorRation=n         | 设置年轻代中E去与俩个S去的比值         |
| -XX:PermSize=128m            | 设置永久代内存大小（JDK7之前有效）     |
| -XX:MaxPermSize=128m         | 设置永久代最大内存大小（JDK7之前有效） |