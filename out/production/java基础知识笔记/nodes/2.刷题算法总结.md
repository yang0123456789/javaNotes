![image-20200818101631955](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200818101631955.png)![image-20200814103438989](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200814103438989.png)

![image-20200814103429068](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200814103429068.png)![image-20200722173856722](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200722173856722.png)面试/考试速查，
常考数据结构类型速查速补表
\* P16~P23 单链表
P24~P26 双向链表
P27~P29 约瑟夫环
P30~P35 栈·栈实现计算器
\* P36~P42 前缀，中缀，后缀表达式，逆波兰计算器的实现
\* P43~P49 递归，迷宫回溯，八皇后
P50~P53 排序算法基础
\* 54~56 冒泡排序
57~59 选择排序
60~62 插入排序
63~65 希尔排序
\* 66~68 快速排序
69~71 归并排序
72~75 基数排序
76各种排序的比较
*127~131 二叉排序树
132~134 BST删除一棵子树的节点
\* 135 二叉平衡树
\* 146~151 图，图的深度优先和广度优先
\* 156~159 动态规划
\* 160~163 暴力匹配和KMP算法
\* 164~ 167 贪心算法

## 一、分治算法



#### 1.[合并K个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists) 

23题

1.分治算法

![image-20200803222618513](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803222618513.png)

![image-20200803222912781](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803222912781.png)

整体时间复杂度为O(N*log(k)), k为链表个数，N为链表数组中节点总个数。
整体思路为

合并数组中第k个链表到第1个链表，合并数组中第k-1个链表到第2个链表，依次这样操作...


一轮合并之后，新链表分布在数组的 第1 到 第(k+1)/2个链表中，继续1这样的合并直到新链表只在数组第一个位置。
返回数组第一个元素，即合并之后的链表。

![image-20200803223017075](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803223017075.png)
    

    class Solution {
        public ListNode mergeKLists(ListNode[] lists) {
            int len = lists.length;
            if (len == 0) {
                return null;
            }    
            // 将n个链表以中间为对称，合并，即合并 
            while(len>1) {
                for (int i=0; i<len/2; i++) {
                    lists[i] = mergeTwoLists(lists[i], lists[len-1-i]);
                }
                len = (len+1)/2;
            }
            return lists[0];
        }
    
    // 合并两个链表
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode head = new ListNode(-1);
        ListNode p = head;
        while(l1 != null && l2 != null) {
            if (l1.val < l2.val) {
                p.next = l1;
                l1 = l1.next;
            } else {
                p.next = l2;
                l2 = l2.next;
            }
            p = p.next;
        }
        if (l1 != null) {
            p.next = l1;
        } else if (l2 != null) {
            p.next = l2;
        }
        return head.next;
    }

}









2.逐个比较，逐个比较每个列表的第一个值，将最小的接在头结点后面，然后该列表指针往后推一个，直至最后



3.暴力求解

![image-20200803222249510](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803222249510.png)





#### [53. 最大子序和](https://leetcode-cn.com/problems/maximum-subarray/)

![image-20200822171804793](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822171804793.png)



![image-20200822195904894](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822195904894.png)



![image-20200822170036036](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822170036036.png)

```
public int maxSubArray(int[] nums) {

    int pre = 0, maxAns = nums[0];
    for (int x:nums){
        pre = Math.max(pre + x, x);
        maxAns = Math.max(maxAns, pre);
    }
    return maxAns;
}
```

##### 方法二：分治

**思路和算法**

![image-20200822200518030](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822200518030.png)

![image-20200822200539502](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822200539502.png)



#### [169. 多数元素](https://leetcode-cn.com/problems/majority-element/)

如果将数组 nums 中的所有元素按照单调递增或单调递减的顺序排序，那么下标为n/2 的元素（下标从 0 开始）一定是众数。

![image-20200826012017408](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826012017408.png)

```
class Solution {
    public int majorityElement(int[] nums) {
        int cand_num = nums[0], count = 1;
        for (int i = 1; i < nums.length; ++i) {
            if (cand_num == nums[i])
                ++count;
            else if (--count == 0) {
                cand_num = nums[i];
                count = 1;
            }
        }
        return cand_num;
    }
}

```

![image-20200826012413706](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826012413706.png)

https://leetcode-cn.com/problems/majority-element/solution/duo-shu-yuan-su-by-leetcode-solution/





## 二、动态规划dynamic planning

DP就是动态规划，没怎么弄懂

![image-20200514105320654](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514105320654.png)

![image-20200704094951579](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200704094951579.png)
![image-20200704095259993](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200704095259993.png)









![image-20200704095450436](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200704095450436.png)

![image-20200704095540377](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200704095540377.png)







建议看完灯神的再来看这个，B站直接搜动态规划，你会回来感谢我的

大家不懂的去看up正月点灯笼的动态规划，很好理解
参考这个视频《算法设计与分析 屈婉玲教授》，直接搜就行了



#### 解题思路

：本质是对递归进行剪枝减少运算量

1.设置状态opt（n），表示在第n个物品下的最优解，

2.然后根据题意分支，①看包含n的集中情况下，与前面的opt[n-1] ......opt[0]的关联情况

​					②看不包含n的集中情况下，与前面的opt[n-1] ......opt[0]的关联情况

![image-20200814164309965](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814164309965.png)

然后比较关于opt（n）的几个分支，选出最优解作为opt（n）的值

![image-20200814164355106](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814164355106.png)

3. 对子条件进行相同的分支



![image-20200814164533603](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814164533603.png)

然后就出现画红圈的重叠的子问题，这些问题在dp算法中从下往上迭代的过程中存储起来，直接拿过去用，就比原始的迭代节省了好多的计算

4.根据前几步分析总结dp算法的计算通用公式opy[i],

![image-20200814164802069](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814164802069.png)

确定递归的出口，也就是递归的最底层，不能再分解的最底层的子问题

出口可以理解为结束条件，就像斐波那契，最后都是到了n=1或n=2就走完了

![image-20200814164833950](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814164833950.png)

5.根据第四部，编写代码，有两种方式。递归recursion和非递归（一般是动态规划的写法）

​	**递归**

![image-20200814165232513](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814165232513.png)

**非递归：**

可以建一个opt数组，保存每个opt的值，这样递归时先询问是否有现成的，可以降到O（n）

1.创建一个数组，存储opt[n]的值。

2.先把递归的出口，也就是最初的不能再切割的子问题 opt[0]已经opt[1]...opt[i]等放进去，

3.然后创建一个for循环，从opt[i+1]开始，由前面opt[i]个结果推算opt[i+1],将结果存入opt数组中，

4.for循环结束以后，返回opt数组最后一个数字

![image-20200814165838621](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814165838621.png)







#### 1.背包问题

物品只有两种状态，装入或者不装，所以每个物品可以分成两种情况，第一种放入这个物品，然后减去这个物品的重量，背包的总价值就是这个物品的价值+减去这个物品重量以后的背包剩下的容量能放下前几种物品的最大价值，
第二种就是不放入这个物品，那么就是这个背包的容量能放入的前几种商品的最大价值，
比较两种情况就能得出背包最大的价值

##### [494. 目标和](https://leetcode-cn.com/problems/target-sum/)

给定一个非负整数数组，a1, a2, ..., an, 和一个目标数，S。现在你有两个符号 `+` 和 `-`。对于数组中的任意一个整数，你都可以从 `+` 或 `-`中选择一个符号添加在前面。

返回可以使最终数组和为目标数 S 的所有添加符号的方法数。

**提示：**

- 数组非空，且长度不会超过 20 。
- 初始的数组的和不会超过 1000 。
- 保证返回的最终结果能被 32 位整数存下。



这道题也是一个常见的背包问题，我们可以用类似求解背包问题的方法来求出可能的方法数。

我们用` dp[i][j] `表示用数组中的前 i 个元素，组成和为 j 的方案数。考虑第 i 个数 nums[i]，它可以被添加 + 或 -，因此状态转移方程如下：

`dp[i][j] = dp[i - 1][j - nums[i]] + dp[i - 1][j + nums[i]]`

也可以写成递推的形式：

`dp[i][j + nums[i]] += dp[i - 1][j]`
`dp[i][j - nums[i]] += dp[i - 1][j]`

由于数组中所有数的和不超过 1000，那么 j 的最小值可以达到 -1000。在很多语言中，是不允许数组的下标为负数的，因此我们需要给 dp[i][j] 的第二维预先增加 1000，即：

`dp[i][j + nums[i] + 1000] += dp[i - 1][j + 1000]`
`dp[i][j - nums[i] + 1000] += dp[i - 1][j + 1000]`

```java 
public class Solution {
    public int findTargetSumWays(int[] nums, int S) {
        int[][] dp = new int[nums.length][2001];//-1000,1000，加上0 共2001个
        dp[0][nums[0] + 1000] = 1;//初试条件，第一行组合成nums[i]的元素，为1，只有1种方案是nums[0]的符号为+，
        dp[0][-nums[0] + 1000] += 1;//初试条件，第一行组合成-nums[i]的元素，为1，只有1种，就是nums[0]的符号为-，然后第一行其余位置都是0中方案
        for (int i = 1; i < nums.length; i++) {//一行一行遍历，根据上一行确定下一行
            for (int sum = -1000; sum <= 1000; sum++) {
                if (dp[i - 1][sum + 1000] > 0) {//nums[sum]符号为+和为-的两种情况，都加在
                    dp[i][sum + nums[i] + 1000] += dp[i - 1][sum + 1000];//根据上一行确定下一行
                    dp[i][sum - nums[i] + 1000] += dp[i - 1][sum + 1000];//根据上一行确定下一行
                }
            }
        }
        return S > 1000 ? 0 : dp[nums.length - 1][S + 1000];//返回最终的一个值，也就是二维数组的最后一个值。
    }
}


```

#### 2.回文子串

##### 方法一：动态规划

思路与算法

对于一个子串而言，如果它是回文串，并且长度大于 22，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串rm{``ababa''}“ababa”，如果我们已经知道 \textrm{``bab''}“bab” 是回文串，那么 \textrm{``ababa''}“ababa” 一定是回文串，这是因为它的首尾两个字母都是 \textrm{``a''}“a”。

根据这样的思路，我们就可以用动态规划的方法解决本题。我们用 P(i,j) 表示字符串 s 的第 ii到 j 个字母组成的串（下文表示成 s[i:j]）是否为回文串：

![image-20200803143451604](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803143451604.png)

![image-20200803143739726](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803143739726.png)

![image-20200803143828203](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200803143828203.png)
![image-20200803145706182](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803145706182.png)

```java
public String longestPalindrome(String s) {
    if(s.length()<=1) return s;
    int len =s.length();
    int begin=0;
    int maxLen=1;//至少一个字符，也就是s的第一个
    boolean[][] dp=new boolean[len][len];
    for(int i=0;i<len ;i++){
        dp[i][i]=true;
    }
    //一列一列填写,从上往下填写
    for(int j=1;j<len ;j++){
        for(int i=0;i<j ;i++){
            if (s.charAt(i)!=s.charAt(j)){
                dp[i][j]=false;
            }else {
                //s[i+1][j-1]的长度为0或者1，也就是少于二，则dp[i+1][j-1]的值为true
                if (j-1-(i+1)+1<=1){
                    dp[i][j]=true;
                }
                //s[i+1][j-1]的长度大于1
                else {
                    dp[i][j]=dp[i+1][j-1];//左下一个dp的值，正好是一列一列填写

                }
            }
            if (dp[i][j]==true){
                if (j-i+1>maxLen){
                    begin=i;
                    maxLen=j-i+1;
                }
            }
        }

    }
    return s.substring(begin,begin+maxLen);
}
```

![image-20200803144151052](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803144151052.png)



##### 方法二 暴力破解

```java
 //暴力解法
    public String longestPalindrome(String s) {
        int len =s.length();
        if (len<2) return s;
        int maxLen=1;
        int begin=0;
        char[] chars = s.toCharArray();
        for(int i=0;i<len ;i++){
            for(int j=i+1;j<len ; j++){
                if (j-i+1>maxLen&&isPalindrome(chars,i,j)){
                    maxLen=j-i+1;
                    begin=i;
                }
            }
        }
        return s.substring(begin,begin+maxLen);

    }


}

public boolean isPalindrome(char[] chars, int left, int right) {
    while (left<right){
        if (chars[left]!=chars[right]){
            return false;
        }
        left++;
        right--;
    }
    return true;
}
```

##### 方法三 中心扩散法

![image-20200803110655050](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803110655050.png)



![image-20200803141201999](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200803141201999.png)
![image-20200803110825509](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803110825509.png)

![image-20200803141327523](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803141327523.png)

##### 方法四  Manacher 

https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-by-leetcode-solution/

- 方法一（暴力解法）：00:50；
- 方法二（中心扩散）：01:52；
- 方法三（动态规划）：05:34；
- 方法四（Manacher 算法）：12:43。

#### 3.组合数字问题

从一个数组中选择若干数字组成一个值s，有的话返回true，没有的话，返回false。数组都是正数

![image-20200814170124827](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814170124827.png)



1.分析opt[n]，n是最后一个值，也就是最终的结果，要保证opt[n]选项的和为S需要保证下面两种情况

①包含arr[n]，则opt[n-1]前面的选项的和应该是s-arr[n],

②不包含arr[n]，则opt[n-1]前面的选项应该是S,

只要上面有一个成立，结果就成立

![image-20200814171033959](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814171033959.png)



所以递归的方程可以设计为：三个参数，原始的数组，正在分支的位置，以及s减去前面的选项以后剩下的需要的值，也就是剩下的数组需要拼凑成的数值

![image-20200814172129299](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814172129299.png)





2.确定出口，也就是原始条件

正解，只要是boolean的方法都得有1和0两个出口

①如果前面的条件已经加起来是S了，则不需要进行迭代了，直接返回true

②当只剩一个数字的时候，并且前面的和不为s，则剩下的数字必须加上前面的数字正好是s，返回ture，否则返回false

从前往后把减变成加





![image-20200814171509875](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814171509875.png)

③剪枝情况的出口：如果遇到一个数字，已经大于需要的数字，则再往左边走就不需要了，直接返回false，这就是剪枝，节省计算量

预先判断大于S的元素，直接删除，再选子集

如果有负数就不能舍弃了

![image-20200814171736471](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814171736471.png)

![image-20200814172238128](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814172238128.png)







编写代码：

先写出口代码：

**递归**

```java
public boolean isInArr(int[] arr,int s){
    //从最高位开始操作，也可以从最低位开始操作，结果是一样的
    return rec_subset(arr,arr.length-1,s);

}

public boolean rec_subset(int[] arr,int i,int s){
    //1.先写出口条件
    if (s==0) {return true;}
    else if (i==0){
        return arr[0]==s;
    }
    else if (arr[i]>s){//这一步是进行剪枝 预先判断大于S的元素，直接删除，再选子集
        return rec_subset(arr,i-1,s);
    }
    else {//进行递归的条件
        return rec_subset(arr,i-1,s) ||rec_subset(arr,i-1,s-arr[i]);
    }
}
```



**非递归**

动态规划是迭代，不是递归

可以用一个二维数组保存，
二维数组的横轴表示的是从0到S，用s表示，
纵轴是arr的n个数，0——`len-1`，用i表示
二维数组对应的值是subset（arr[i],s），是一个boolean的值，即表示在arr[i]的位置以前没有添加的数能不能凑成s，

先填写第一行，就是只有arr[0]的情况，能不能凑成0-s的值，也就是i=0时的出口![image-20200814175451326](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814175451326.png)

![image-20200814175540721](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814175540721.png)



再填写第一列，表示s=0的时候，这个数组的各个值能不能凑成，所以这一列全是true，

相当于第二个出口

![image-20200814175700098](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814175700098.png)

![image-20200814175636959](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814175636959.png)

然后从左往右 从上往下依次填写表的各项。一行一行按照j自增填写填写表

首先创建一个二维数组，

```java
  public boolean dp_subset(int[] arr, int s) {
//        二维数组的横轴表示的是从0到S，用s表示，共s+1个
//        纵轴是arr的n个数，0——`len-1`，用i表示，共arr.length个
        boolean[][] subsets = new boolean[arr.length][s + 1];
        //第一列设置为true，因为 s=0，不选都可以组合成0
        for (int i = 0; i < arr.length; i++) {
            subsets[i][0] = true;
        }
        //设置第一行，也就是arr[0]是不是等于s,(0, 0)这个位置是True还是False其实无所谓。
        for (int i = 0; i <= s; i++) {
            if (arr[0] == i) {
                subsets[0][i] = true;
            }
        }
        for (int i = 1; i < arr.length; i++) {//一行一行填写，第一行已经填写过
            for (int j = 1; j <= s; j++) {//第一列也已经填写过
                if (arr[i] > s) {
                    subsets[i][j] = subsets[i - 1][j];//如果arr[i]大于s，则直接等于arr[i-1]的位置的情况，也就是上一列，因为arr[i]肯定不在这一列中
                }else {
                    subsets[i][j]=subsets[i-1][s-arr[i]]||subsets[i-1][s];//分为两种情况，包含和不包含，这个地方设置的是这两个值
                }
            }
        }
        return subsets[arr.length-1][s];//返回最后一个值，就是最终的结果
    }
```

#### [

#### 4.树形动态规划问题

##### [337. 打家劫舍 III](https://leetcode-cn.com/problems/house-robber-iii/)

说明
本题目本身就是动态规划的树形版本，通过此题解，可以了解一下树形问题在动态规划问题解法
我们通过三个方法不断递进解决问题

解法一通过递归实现，虽然解决了问题，但是复杂度太高
解法二通过解决方法一中的重复子问题，实现了性能的百倍提升
解法三直接省去了重复子问题，性能又提升了一步
解法一、暴力递归 - 最优子结构
在解法一和解法二中，我们使用爷爷、两个孩子、4 个孙子来说明问题
首先来定义这个问题的状态
爷爷节点获取到最大的偷取的钱数呢

首先要明确相邻的节点不能偷，也就是爷爷选择偷，儿子就不能偷了，但是孙子可以偷
二叉树只有左右两个孩子，一个爷爷最多 2 个儿子，4 个孙子
根据以上条件，我们可以得出单个节点的钱该怎么算
4 个孙子偷的钱 + 爷爷的钱 VS 两个儿子偷的钱 哪个组合钱多，就当做当前节点能偷的最大钱数。这就是动态规划里面的最优子结构

由于是二叉树，这里可以选择计算所有子节点

4 个孙子投的钱加上爷爷的钱如下
int method1 = root.val + rob(root.left.left) + rob(root.left.right) + rob(root.right.left) + rob(root.right.right)
两个儿子偷的钱如下
int method2 = rob(root.left) + rob(root.right);
挑选一个钱数多的方案则
int result = Math.max(method1, method2);
将上述方案写成代码如下

Java

public int rob(TreeNode root) {
    if (root == null) return 0;

    int money = root.val;
    if (root.left != null) {
        money += (rob(root.left.left) + rob(root.left.right));
    }
    
    if (root.right != null) {
        money += (rob(root.right.left) + rob(root.right.right));
    }
    
    return Math.max(money, rob(root.left) + rob(root.right));

}
信心满满的提交，一次通过，然而 执行用时:837 ms,在所有 java 提交中击败了24.49%的用户 这个结果太没面子了，下个解法进行优化

解法二、记忆化 - 解决重复子问题
针对解法一种速度太慢的问题，经过分析其实现，我们发现爷爷在计算自己能偷多少钱的时候，同时计算了 4 个孙子能偷多少钱，也计算了 2 个儿子能偷多少钱。这样在儿子当爷爷时，就会产生重复计算一遍孙子节点。

于是乎我们发现了一个动态规划的关键优化点

重复子问题

我们这一步针对重复子问题进行优化，我们在做斐波那契数列时，使用的优化方案是记忆化，但是之前的问题都是使用数组解决的，把每次计算的结果都存起来，下次如果再来计算，就从缓存中取，不再计算了，这样就保证每个数字只计算一次。
由于二叉树不适合拿数组当缓存，我们这次使用哈希表来存储结果，TreeNode 当做 key，能偷的钱当做 value

解法一加上记忆化优化后代码如下：

Java

public int rob(TreeNode root) {
    HashMap<TreeNode, Integer> memo = new HashMap<>();
    return robInternal(root, memo);
}

public int robInternal(TreeNode root, HashMap<TreeNode, Integer> memo) {
    if (root == null) return 0;
    if (memo.containsKey(root)) return memo.get(root);
    int money = root.val;

    if (root.left != null) {
        money += (robInternal(root.left.left, memo) + robInternal(root.left.right, memo));
    }
    if (root.right != null) {
        money += (robInternal(root.right.left, memo) + robInternal(root.right.right, memo));
    }
    int result = Math.max(money, robInternal(root.left, memo) + robInternal(root.right, memo));
    memo.put(root, result);
    return result;

}
提交代码，执行用时：4 ms, 在所有 java 提交中击败了 54.92% 的用户，速度提高了 200 倍。太开心了。别着急，还有一个终极方案呢，连记忆化消耗的时间都省了，能省则省么。

解法三、终极解法
上面两种解法用到了孙子节点，计算爷爷节点能偷的钱还要同时去计算孙子节点投的钱，虽然有了记忆化，但是还是有性能损耗。

我们换一种办法来定义此问题

每个节点可选择偷或者不偷两种状态，根据题目意思，相连节点不能一起偷

当前节点选择偷时，那么两个孩子节点就不能选择偷了
当前节点选择不偷时，两个孩子节点只需要拿最多的钱出来就行(两个孩子节点偷不偷没关系)
我们使用一个大小为 2 的数组来表示 int[] res = new int[2] 0 代表不偷，1 代表偷
任何一个节点能偷到的最大钱的状态可以定义为

当前节点选择不偷：当前节点能偷到的最大钱数 = 左孩子能偷到的钱 + 右孩子能偷到的钱
当前节点选择偷：当前节点能偷到的最大钱数 = 左孩子选择自己不偷时能得到的钱 + 右孩子选择不偷时能得到的钱 + 当前节点的钱数
表示为公式如下


root[0] = Math.max(rob(root.left)[0], rob(root.left)[1]) + Math.max(rob(root.right)[0], rob(root.right)[1])
root[1] = rob(root.left)[0] + rob(root.right)[0] + root.val;
将公式做个变换就是代码啦

Java

public int rob(TreeNode root) {
    int[] result = robInternal(root);
    return Math.max(result[0], result[1]);
}

public int[] robInternal(TreeNode root) {
    if (root == null) return new int[2];
    int[] result = new int[2];

    int[] left = robInternal(root.left);
    int[] right = robInternal(root.right);
    
    result[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
    result[1] = left[0] + right[0] + root.val;
    
    return result;

}
再提交一次：
执行用时 1 ms, 在所有 java 提交中击败了 99.87% 的用户，这样的结果，我觉得可以了。


后记
当个现代化的小偷不容易啊，还得学习动态规划。
如有错误，欢迎指出

作者：reals
链接：https://leetcode-cn.com/problems/house-robber-iii/solution/san-chong-fang-fa-jie-jue-shu-xing-dong-tai-gui-hu/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#### 5.零钱问题

##### [322. 零钱兑换](https://leetcode-cn.com/problems/coin-change/)

![image-20200818101612605](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200818101612605.png)



```java
public class Solution {

  public int coinChange(int[] coins, int amount) {
    return coinChange(0, coins, amount);
  }

  private int coinChange(int idxCoin, int[] coins, int amount) {
    if (amount == 0)
      return 0;
    if (idxCoin < coins.length && amount > 0) {
      int maxVal = amount / coins[idxCoin];
      int minCost = Integer.MAX_VALUE;
      for (int x = 0; x <= maxVal; x++) {
        if (amount >= x * coins[idxCoin]) {
          int res = coinChange(idxCoin + 1, coins, amount - x * coins[idxCoin]);
          if (res != -1)
            minCost = Math.min(minCost, res + x);
        }
      }
      return (minCost == Integer.MAX_VALUE)? -1: minCost;
    }
    return -1;
  }
}


```

![image-20200818102421034](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200818102421034.png)

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/e0fd2252775b89649ceb6e867ff0e546ec77621edb566693482c8588a98066b8-file_1583404923188.jpg)

```java
public class Solution {
  public int coinChange(int[] coins, int amount) {
    if (amount < 1) return 0;
    return coinChange(coins, amount, new int[amount]);
  }
  private int coinChange(int[] coins, int rem, int[] count) {
    if (rem < 0) return -1;
    if (rem == 0) return 0;
    if (count[rem - 1] != 0) return count[rem - 1];
    int min = Integer.MAX_VALUE;
    for (int coin : coins) {
      int res = coinChange(coins, rem - coin, count);
      if (res >= 0 && res < min)
        min = 1 + res;
    }
    count[rem - 1] = (min == Integer.MAX_VALUE) ? -1 : min;
    return count[rem - 1];
  }
}

```

方法三、动态规划：自下而上 [通过]

![image-20200818103727096](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200818103727096.png)
![image-20200818103741608](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200818103741608.png)
![image-20200818104304476](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200818104304476.png)



```java
public class Solution {
  public int coinChange(int[] coins, int amount) {
    int max = amount + 1;
    int[] dp = new int[amount + 1];
    Arrays.fill(dp, max);
    dp[0] = 0;
    for (int i = 1; i <= amount; i++) {
      for (int j = 0; j < coins.length; j++) {
        if (coins[j] <= i) {
          dp[i] = Math.min(dp[i], dp[i - coins[j]] + 1);
        }
      }
    }
    return dp[amount] > amount ? -1 : dp[amount];
  }
}

```



https://leetcode-cn.com/problems/coin-change/solution/322-by-ikaruga/

```java
//    暴力+剪枝
class Solution7 {
    int res = Integer.MAX_VALUE;
    public int coinChange(int[] coins, int amount){
        if(amount==0){
            return 0;
        }
        Arrays.sort(coins);
        mincoin(coins,amount,coins.length-1,0);
        return res==Integer.MAX_VALUE? -1:res;
    }
    private void mincoin(int[] coins,int amount, int index, int count){
        if(amount==0){
            res = Math.min(res,count);
            return;
        }
        if(index<0){
            return;
        }
        for(int i = amount/coins[index];i>=0 && i+count<res; i--){
            mincoin(coins,amount - (i*coins[index]), index-1, count+i);
        }
    }
```



#### 6.股票买卖

##### [121. 买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

假如计划在第 i 天卖出股票，那么最大利润的差值一定是在[0, i-1] 之间选最低点买入；所以遍历数组，依次求每个卖出时机的的最大差值，再从中取最大值。

方法二：一次遍历
算法

假设给定的数组为：[7, 1, 5, 3, 6, 4]

如果我们在图表上绘制给定数组中的数字，我们将会得到：



我们来假设自己来购买股票。随着时间的推移，每天我们都可以选择出售股票与否。那么，假设在第 i 天，如果我们要在今天卖股票，那么我们能赚多少钱呢？

显然，如果我们真的在买卖股票，我们肯定会想：如果我是在历史最低点买的股票就好了！太好了，在题目中，我们只要用一个变量记录一个历史最低价格 minprice，我们就可以假设自己的股票是在那天买的。那么我们在第 i 天卖出股票能得到的利润就是 prices[i] - minprice。

因此，我们只需要遍历价格数组一遍，记录历史最低点，然后在每一天考虑这么一个问题：如果我是在历史最低点买进的，那么我今天卖出能赚多少钱？当考虑完所有天数之时，我们就得到了最好的答案。

javapythonC++

```java
public class Solution {
    public int maxProfit(int prices[]) {
        int minprice = Integer.MAX_VALUE;
        int maxprofit = 0;
        for (int i = 0; i < prices.length; i++) {
            if (prices[i] < minprice)
                minprice = prices[i];
            else if (prices[i] - minprice > maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
    }
}

class Solution {
 public int maxProfit(int[] prices) {
//            定义两个变量，minPrice表示第i天以前的最低价格
//                          maxProfit表示第i天经过操作能获得的最大利润
            //遍历一次数组，同时更新这两个值，让price[i]-minprice的值与maxProfit比较，更新maxProfit更新maxProfit的值
            if (prices.length<=1) return 0;
            int minPrice=prices[0];//第一天开始最小的价格就是当天的价格，
            int maxProfit=0;//不操作，利润就是0；
            for(int i=1;i<prices.length ;i++){
                if (prices[i]<minPrice){
                    minPrice=prices[i];
                }else {
                    if (prices[i]-minPrice>maxProfit){
                        maxProfit=prices[i]-minPrice;
                    }
                }
            
            }
            return maxProfit;
    }
}
```

##### 一个方法团灭 6 道股票问题

这篇文章用状态机的技巧来解决，可以全部提交通过。不要觉得这个名词高大上，文学词汇而已，实际上就是 DP table，看一眼就明白了。

第一题是只进行一次交易，相当于 k = 1；第二题是不限交易次数，相当于 k = +infinity（正无穷）；第三题是只进行 2 次交易，相当于 k = 2；剩下两道也是不限次数，但是加了交易「冷冻期」和「手续费」的额外条件，其实就是第二题的变种，都很容易处理。



![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/30ffef5e0bf9bbdfa2b8fb3954ecccffa86e107607c09ae75d2440c319e0b868.png)

我们不用递归思想进行穷举，而是利用「状态」进行穷举。我们具体到每一天，看看总共有几种可能的「状态」，再找出每个「状态」对应的「选择」。我们要穷举所有「状态」，穷举的目的是根据对应的「选择」更新状态。听起来抽象，你只要记住「状态」和「选择」两个词就行，下面实操一下就很容易明白了。

```
for 状态1 in 状态1的所有取值：
    for 状态2 in 状态2的所有取值：
        for ...
            dp[状态1][状态2][...] = 择优(选择1，选择2...)
```


比如说这个问题，每天都有三种「选择」：买入、卖出、无操作，我们用 buy, sell, rest 表示这三种选择。但问题是，并不是每天都可以任意选择这三种选择的，因为 sell 必须在 buy 之后，buy 必须在 sell 之后。那么 rest 操作还应该分两种状态，一种是 buy 之后的 rest（持有了股票），一种是 sell 之后的 rest（没有持有股票）。而且别忘了，我们还有交易次数 k 的限制，就是说你 buy 还只能在 k > 0 的前提下操作。

很复杂对吧，不要怕，我们现在的目的只是穷举，你有再多的状态，老夫要做的就是一把梭全部列举出来。这个问题的「状态」有三个，第一个是天数，第二个是允许交易的最大次数，第三个是当前的持有状态（即之前说的 rest 的状态，我们不妨用 1 表示持有，0 表示没有持有）。然后我们用一个三维数组就可以装下这几种状态的全部组合：

```
dp[i][k][0 or 1]
0 <= i <= n-1, 1 <= k <=大K
n 为天数，大 K 为最多交易数
此问题共 n × 大K × 2 种状态，全部穷举就能搞定。

for 0 <= i < n:
    for 1 <= k <= K:
        for s in {0, 1}:
            dp[i][k][s] = max(buy, sell, rest)
```

而且我们可以用自然语言描述出每一个状态的含义，比如说` dp[3][2][1]` 的含义就是：今天是第三天，我现在手上持有着股票,这里指的是第三天操作完以后的状态，至今最多进行 2 次交易。再比如` dp[2][3][0]` 的含义：今天是第二天，我现在手上没有持有股票，至今最多进行 3 次交易。很容易理解，对吧？

我们想求的最终答案是` dp[n - 1][K][0]，`即最后一天，最多允许 K 次交易，最多获得多少利润。读者可能问为什么不是 `dp[n - 1][K][1]？`因为 [1] 代表手上还持有股票，[0] 表示手上的股票已经卖出去了，很显然后者得到的利润一定大于前者。

记住如何解释「状态」，一旦你觉得哪里不好理解，把它翻译成自然语言就容易理解了。

二、状态转移框架

现在，我们完成了「状态」的穷举，我们开始思考每种「状态」有哪些「选择」，应该如何更新「状态」。只看「持有状态」，可以画个状态转移图。

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/9ac1cc748e47ce0b5a1987323cb4b2cd8b40d9dfb5bf29a0449a391139b3c958.png)



```
通过这个图可以很清楚地看到，每种状态（0 和 1）是如何转移而来的。根据这个图，我们来写一下状态转移方程：


dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
              max(   选择 rest  ,             选择 sell      )

解释：今天我没有持有股票，有两种可能：
要么是我昨天就没有持有，然后今天选择 rest，所以我今天还是没有持有；
要么是我昨天持有股票，但是今天我 sell 了，所以我今天没有持有股票了。

dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
              max(   选择 rest  ,           选择 buy         )

解释：今天我持有着股票，有两种可能：
要么我昨天就持有着股票，然后今天选择 rest，所以我今天还持有着股票；
要么我昨天本没有持有，但今天我选择 buy，所以今天我就持有股票了。


```

这个解释应该很清楚了，如果 buy，就要从利润中减去 prices[i]，如果 sell，就要给利润增加 prices[i]。今天的最大利润就是这两种可能选择中较大的那个。而且注意 k 的限制，我们在选择 buy 的时候，把 k 减小了 1，很好理解吧，当然你也可以在 sell 的时候减 1，一样的。

现在，我们已经完成了动态规划中最困难的一步：状态转移方程。**如果之前的内容你都可以理解，那么你已经可以秒杀所有问题了，只要套这个框架就行了。**不过还差最后一点点，就是定义 base case，即最简单的情况。

```
`dp[-1][k][0] = 0`
解释：因为 i 是从 0 开始的，所以 i = -1 意味着还没有开始，这时候的利润当然是 0 。
`dp[-1][k][1] = -infinity`
解释：还没开始的时候，是不可能持有股票的，用负无穷表示这种不可能。
dp[i][0][0] = 0
解释：因为 k 是从 1 开始的，所以 k = 0 意味着根本不允许交易，这时候利润当然是 0 。
dp[i][0][1] = -infinity
解释：不允许交易的情况下，是不可能持有股票的，用负无穷表示这种不可能。
把上面的状态转移方程总结一下：
base case：
dp[-1][k][0] = dp[i][0][0] = 0
dp[-1][k][1] = dp[i][0][1] = -infinity

状态转移方程：
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
```


读者可能会问，这个数组索引是 -1 怎么编程表示出来呢，负无穷怎么表示呢？这都是细节问题，有很多方法实现。现在完整的框架已经完成，下面开始具体化。

三、秒杀题目

第一题，k = 1

直接套状态转移方程，根据 base case，可以做一些化简：

```
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], dp[i-1][0][0] - prices[i]) 
            = max(dp[i-1][1][1], -prices[i])
解释：k = 0 的 base case，所以 dp[i-1][0][0] = 0。
```



```
现在发现 k 都是 1，不会改变，即 k 对状态转移已经没有影响了。
可以进行进一步化简去掉所有 k：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], -prices[i])
直接写出代码：
int n = prices.length;
int[][] dp = new int[n][2];
for (int i = 0; i < n; i++) {
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
}
return dp[n - 1][0];
显然 i = 0 时 dp[i-1] 是不合法的。这是因为我们没有对 i 的 base case 进行处理。可以这样处理：

for (int i = 0; i < n; i++) {
    if (i - 1 == -1) {
        dp[i][0] = 0;
        // 解释：
        //   dp[i][0] 
        // = max(dp[-1][0], dp[-1][1] + prices[i])
        // = max(0, -infinity + prices[i]) = 0
        dp[i][1] = -prices[i];
        //解释：
        //   dp[i][1] 
        // = max(dp[-1][1], dp[-1][0] - prices[i])
        // = max(-infinity, 0 - prices[i]) 
        // = -prices[i]
        continue;
    }
    dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
    dp[i][1] = Math.max(dp[i-1][1], -prices[i]);
}
return dp[n - 1][0];
第一题就解决了，但是这样处理 base case 很麻烦，而且注意一下状态转移方程，新状态只和相邻的一个状态有关，其实不用整个 dp 数组，只需要一个变量储存相邻的那个状态就足够了，这样可以把空间复杂度降到 O(1):


// k == 1
int maxProfit_k_1(int[] prices) {
    int n = prices.length;
    // base case: dp[-1][0] = 0, dp[-1][1] = -infinity
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        // dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        // dp[i][1] = max(dp[i-1][1], -prices[i])
        dp_i_1 = Math.max(dp_i_1, -prices[i]);
    }
    return dp_i_0;
}
两种方式都是一样的，不过这种编程方法简洁很多。但是如果没有前面状态转移方程的引导，是肯定看不懂的。后续的题目，我主要写这种空间复杂度 O(1) 的解法。

第二题，k = +infinity

如果 k 为正无穷，那么就可以认为 k 和 k - 1 是一样的。可以这样改写框架：


dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
            = max(dp[i-1][k][1], dp[i-1][k][0] - prices[i])

我们发现数组中的 k 已经不会改变了，也就是说不需要记录 k 这个状态了：
dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i])
直接翻译成代码：


int maxProfit_k_inf(int[] prices) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
    }
    return dp_i_0;
}
第三题，k = +infinity with cooldown

每次 sell 之后要等一天才能继续交易。只要把这个特点融入上一题的状态转移方程即可：


dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-2][0] - prices[i])
解释：第 i 天选择 buy 的时候，要从 i-2 的状态转移，而不是 i-1 。
翻译成代码：


int maxProfit_with_cool(int[] prices) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    int dp_pre_0 = 0; // 代表 dp[i-2][0]
    for (int i = 0; i < n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, dp_pre_0 - prices[i]);
        dp_pre_0 = temp;
    }
    return dp_i_0;
}
第四题，k = +infinity with fee

每次交易要支付手续费，只要把手续费从利润中减去即可。改写方程：


dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i] - fee)
解释：相当于买入股票的价格升高了。
在第一个式子里减也是一样的，相当于卖出股票的价格减小了。
直接翻译成代码：


int maxProfit_with_fee(int[] prices, int fee) {
    int n = prices.length;
    int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
    for (int i = 0; i < n; i++) {
        int temp = dp_i_0;
        dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
        dp_i_1 = Math.max(dp_i_1, temp - prices[i] - fee);
    }
    return dp_i_0;
}
第五题，k = 2

k = 2 和前面题目的情况稍微不同，因为上面的情况都和 k 的关系不太大。要么 k 是正无穷，状态转移和 k 没关系了；要么 k = 1，跟 k = 0 这个 base case 挨得近，最后也没有存在感。

这道题 k = 2 和后面要讲的 k 是任意正整数的情况中，对 k 的处理就凸显出来了。我们直接写代码，边写边分析原因。


原始的动态转移方程，没有可化简的地方
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
按照之前的代码，我们可能想当然这样写代码（错误的）：


int k = 2;
int[][][] dp = new int[n][k + 1][2];
for (int i = 0; i < n; i++)
    if (i - 1 == -1) { /* 处理一下 base case*/ }
    dp[i][k][0] = Math.max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
    dp[i][k][1] = Math.max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
}
return dp[n - 1][k][0];
为什么错误？我这不是照着状态转移方程写的吗？

还记得前面总结的「穷举框架」吗？就是说我们必须穷举所有状态。其实我们之前的解法，都在穷举所有状态，只是之前的题目中 k 都被化简掉了。比如说第一题，k = 1：

「代码截图」

这道题由于没有消掉 k 的影响，所以必须要对 k 进行穷举：


int max_k = 2;
int[][][] dp = new int[n][max_k + 1][2];
for (int i = 0; i < n; i++) {
    for (int k = max_k; k >= 1; k--) {
        if (i - 1 == -1) { /*处理 base case */ }
        dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
        dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);
    }
}
// 穷举了 n × max_k × 2 个状态，正确。
return dp[n - 1][max_k][0];
如果你不理解，可以返回第一点「穷举框架」重新阅读体会一下。

这里 k 取值范围比较小，所以可以不用 for 循环，直接把 k = 1 和 2 的情况全部列举出来也可以：


dp[i][2][0] = max(dp[i-1][2][0], dp[i-1][2][1] + prices[i])
dp[i][2][1] = max(dp[i-1][2][1], dp[i-1][1][0] - prices[i])
dp[i][1][0] = max(dp[i-1][1][0], dp[i-1][1][1] + prices[i])
dp[i][1][1] = max(dp[i-1][1][1], -prices[i])

int maxProfit_k_2(int[] prices) {
    int dp_i10 = 0, dp_i11 = Integer.MIN_VALUE;
    int dp_i20 = 0, dp_i21 = Integer.MIN_VALUE;
    for (int price : prices) {
        dp_i20 = Math.max(dp_i20, dp_i21 + price);
        dp_i21 = Math.max(dp_i21, dp_i10 - price);
        dp_i10 = Math.max(dp_i10, dp_i11 + price);
        dp_i11 = Math.max(dp_i11, -price);
    }
    return dp_i20;
}
有状态转移方程和含义明确的变量名指导，相信你很容易看懂。其实我们可以故弄玄虚，把上述四个变量换成 a, b, c, d。这样当别人看到你的代码时就会大惊失色，对你肃然起敬。

第六题，k = any integer

有了上一题 k = 2 的铺垫，这题应该和上一题的第一个解法没啥区别。但是出现了一个超内存的错误，原来是传入的 k 值会非常大，dp 数组太大了。现在想想，交易次数 k 最多有多大呢？

一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。

直接把之前的代码重用：


int maxProfit_k_any(int max_k, int[] prices) {
    int n = prices.length;
    if (max_k > n / 2) 
        return maxProfit_k_inf(prices);

    int[][][] dp = new int[n][max_k + 1][2];
    for (int i = 0; i < n; i++) 
        for (int k = max_k; k >= 1; k--) {
            if (i - 1 == -1) { /* 处理 base case */ }
            dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i]);
            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i]);     
        }
    return dp[n - 1][max_k][0];

}



public class 买卖股票的最佳时机IV188 {
    //    一次交易由买入和卖出构成，至少需要两天。所以说有效的限制 k 应该不超过 n/2，
//    如果超过，就没有约束作用了，相当于 k = +infinity。这种情况是之前解决过的。题目122中的不限次数买卖
    //买入的时候
    class Solution {
        int maxProfit_k_any(int max_k, int[] prices) {
            if (max_k == 0) return 0;
            int n = prices.length;
            if (max_k > n / 2)
                return maxProfit_k_inf(prices);
            int[][][] dp = new int[n][max_k + 1][2];
            for (int i = 0; i < n; i++)
                for (int k = max_k; k >= 1; k--) {
                    if (i - 1 == -1) {//也就是第一天操作 i=0
                        dp[i][k][0] = 0;//第一天保持不买入，收益为0
                        dp[i][k][1] = 0 - prices[i];//第一天买入，收益为0-price[0];
                        continue;
                        //初始化第一行 i=0的时候
                    }
                    //i=1,也就是第二天开始操作
                    dp[i][k][0] = Math.max(dp[i - 1][k][0], dp[i - 1][k][1] + prices[i]);
                    dp[i][k][1] = Math.max(dp[i - 1][k][1], dp[i - 1][k - 1][0] - prices[i]);
                }
            return dp[n - 1][max_k][0];
        }

        //题目122中的不限次数买卖
        int maxProfit_k_inf(int[] prices) {
            int n = prices.length;
            int dp_i_0 = 0, dp_i_1 = Integer.MIN_VALUE;
            for (int i = 0; i < n; i++) {
                int temp = dp_i_0;
                dp_i_0 = Math.max(dp_i_0, dp_i_1 + prices[i]);
                dp_i_1 = Math.max(dp_i_1, temp - prices[i]);
            }
            return dp_i_0;
        }
    }

    class Solution2 {
        public int maxProfit(int k, int[] prices) {
            if (k < 1) {
                return 0;
            }

            // k 超过了上限，也就变成了 无限次交易问题
            if (k > prices.length / 2) {
                return maxProfitOfII(prices);
            }
            // 状态定义
            int[][] dp = new int[k][2];

            // 初始化
            for (int i = 0; i < k; i++) {
                dp[i][0] = Integer.MIN_VALUE;
            }
            // 遍历每一天，模拟 k 次交易，计算并更新状态
            for (int p : prices) {

                dp[0][0] = Math.max(dp[0][0], 0 - p);                  // 第 1 次买
                dp[0][1] = Math.max(dp[0][1], dp[0][0] + p);           // 第 1 次卖

                for (int i = 1; i < k; i++) {
                    dp[i][0] = Math.max(dp[i][0], dp[i - 1][1] - p);   // 第 i 次买
                    dp[i][1] = Math.max(dp[i][1], dp[i][0] + p);       // 第 i 次卖
                }
            }
            return dp[k - 1][1];
        }

        // 解决无限次交易的方法
        public int maxProfitOfII(int[] prices) {
            int res = 0;
            for (int i = 1; i < prices.length; i++) {
                if (prices[i] > prices[i - 1]) {
                    res += prices[i] - prices[i - 1];
                }
            }
            return res;
        }
    }
}

至此，6 道题目通过一个状态转移方程全部解决。

四、最后总结

本文给大家讲了如何通过状态转移的方法解决复杂的问题，用一个状态转移方程秒杀了 6 道股票买卖问题，现在想想，其实也不算难对吧？这已经属于动态规划问题中较困难的了。

关键就在于列举出所有可能的「状态」，然后想想怎么穷举更新这些「状态」。一般用一个多维 dp 数组储存这些状态，从 base case 开始向后推进，推进到最后的状态，就是我们想要的答案。想想这个过程，你是不是有点理解「动态规划」这个名词的意义了呢？

具体到股票买卖问题，我们发现了三个状态，使用了一个三维数组，无非还是穷举 + 更新，不过我们可以说的高大上一点，这叫「三维 DP」，怕不怕？这个大实话一说，立刻显得你高人一等，名利双收有没有，所以给个在看/分享吧，鼓励一下我。

作者：labuladong
链接：https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/solution/yi-ge-fang-fa-tuan-mie-6-dao-gu-piao-wen-ti-by-l-3/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


```





#### [312. 戳气球](https://leetcode-cn.com/problems/burst-balloons/)

https://www.cnblogs.com/niuyourou/p/11964842.html

```
class Solution {
    public int[][] rec;
    public int[] val;

    public int maxCoins(int[] nums) {
        int n = nums.length;
        val = new int[n + 2];
        for (int i = 1; i <= n; i++) {
            val[i] = nums[i - 1];
        }
        val[0] = val[n + 1] = 1;
        rec = new int[n + 2][n + 2];
        for (int i = 0; i <= n + 1; i++) {
            Arrays.fill(rec[i], -1);
        }
        return solve(0, n + 1);
    }

    public int solve(int left, int right) {
        if (left >= right - 1) {
            return 0;
        }
        if (rec[left][right] != -1) {
            return rec[left][right];
        }
        for (int i = left + 1; i < right; i++) {
            int sum = val[left] * val[i] * val[right];
            sum += solve(left, i) + solve(i, right);
            rec[left][right] = Math.max(rec[left][right], sum);
        }
        return rec[left][right];
    }
}

```



***回溯法***

　　刚看到这个题目，脑中可以很轻易的想象出解空间的结构：一个n层的数组，每层的元素相同，我们从第一层走到第n层，每层走动时不能使用之前走过的元素。然后按照规则计算获取的金币，我们尝试所有可以走的路径并记录下每条路径所能获得的金币和，最大值即题目的解。在层数不确定的情况下，使用递归比for循环的嵌套更加方便，算法的框架如下：

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
//维护一个最大值
int maxCoin=0;
public void getCoins(int[] nums,int currentLevel，int currentCoin){
     //每层的气球数，也是层级数
     int length=nums.length;
     //回归条件，我们走完最后一层了
     if(currentLevel==length){
         //如果该路径所得金币数大于当前最大值，更新最大值
         if(currentCoin>maxCoin){
            maxCoin=currentCoin;
         }
     }
     //尝试该层所有可走的路径
     for(int i=0;i<length;i++){
         //to do something
     }

}
```

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

　　因为被戳破的气球等于不存在，我们在计算获得的金币时需要做一点小小的处理。因为气球上的数字是大于等于0的，我们将走过的气球标志为-1。在计算可以获得的金币数时，如果相邻的气球是-1，则略过取相邻的下一个气球即可。另外，出于两边的气球只有一个相邻气球，需要做一下特殊处理。我们将上述代码的“尝试所有可走路径”中的“to do something”完善起来：

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
//尝试该层所有可走的路径
     for(int i=0;i<length;i++){
         //to do something
         //如果气球已经被戳破了，略过
         if(nums[i]==-1){continue;}
         //标记已经戳破的气球,并保存气球上的标号
         int temp = nums[i];
         nums[i] = -1;
         //获取上一个气球的数字
         int before = i - 1;
         int beforeNum = 0;
         //略过被戳破的气球
         while (before > -1 && nums[before] == -1) {
              before--;
         }
         //到达边界时的处理
         if (before < 0) {
             beforeNum = 1;
         } else {
             beforeNum = nums[before];
         }
         //获取下一个气球的数字
         int next = i + 1;
         int nextNum = 0;
         //略过被戳破的气球
         while (next < length && nums[next] == -1) {
              next++;
          }
          //到达边界时的处理
          if (next > length - 1) {
              nextNum = 1;
          } else {
              nextNum = nums[next];
          }
          //计算戳破当前气球的coin
          int tempCoin = temp * nextNum * beforeNum;
          //递归搜索下一层，进行变量传递
          maxCoins(nums,currentCoin+tempCoin,currentLevel+1);
     }    
```

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

　　按上面的思路，这就是一个很简单的搜索问题，但每走一层都会对下面的路径造成影响，所以我们需要通过回溯的手法，每尝试完一种可能性后，在尝试下一种路径前我们都要把之前路径戳破的气球恢复。回溯很简单，只需要加一行代码，即递归调用结束后将当前for循环中戳破的气球恢复，即下方代码标红部分：

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
//尝试该层所有可走的路径
     for(int i=0;i<length;i++){
         //to do something
         //如果气球已经被戳破了，略过
         if(nums[i]==-1){continue;}
         //标记已经戳破的气球,并保存气球上的标号
         int temp = nums[i];
         nums[i] = -1;
         //获取上一个气球的数字
         int before = i - 1;
         int beforeNum = 0;
         //略过被戳破的气球
         while (before > -1 && nums[before] == -1) {
              before--;
         }
         //到达边界时的处理
         if (before < 0) {
             beforeNum = 1;
         } else {
             beforeNum = nums[before];
         }
         //获取下一个气球的数字
         int next = i + 1;
         int nextNum = 0;
         //略过被戳破的气球
         while (next < length && nums[next] == -1) {
              next++;
          }
          //到达边界时的处理
          if (next > length - 1) {
              nextNum = 1;
          } else {
              nextNum = nums[next];
          }
          //计算戳破当前气球的coin
          int tempCoin = temp * nextNum * beforeNum;
          //递归搜索下一层，进行变量传递
          maxCoins(nums,currentCoin+tempCoin,currentLevel+1);          //回溯          nums[i]=temp;
     }    
```

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

　　回溯的完整代码如下：

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
 /**
    *   @Author Nyr
    *   @Date 2019/11/30 22:24
    *   @Param nums:气球数组，
               y：递归层级，即currentLevel,
               length：数组长度，防止每层都计算一次， 
               beforeCoins：之前所有层获得的金币和，即currentCoin
    *   @Return 
    *   @Exception 
    *   @Description  回溯解法 
    */
    public static void maxCoins2(int[] nums, int y, int length, int beforeCoins) {
        //回归条件
        if (y == length) {
            if (beforeCoins > maxCoin) {
                maxCoin = beforeCoins;
            }
            return;
        }
        for (int i = 0; i < length; i++) {
            //略过已经戳破的气球
            if (nums[i] == -1) {
                continue;
            }
            //标记已经戳破的气球
            int temp = nums[i];
            nums[i] = -1;
            //获取上一个气球的数字
            int before = i - 1;
            int beforeNum = 0;
            while (before > -1 && nums[before] == -1) {
                before--;
            }
            if (before < 0) {
                beforeNum = 1;
            } else {
                beforeNum = nums[before];
            }
            //获取下一个气球的数字
            int next = i + 1;
            int nextNum = 0;
            while (next < length && nums[next] == -1) {
                next++;
            }
            if (next > length - 1) {
                nextNum = 1;
            } else {
                nextNum = nums[next];
            }
            //计算戳破当前气球的coin
            int tempCoin = temp * nextNum * beforeNum;
            //递归进行下一戳
            maxCoins2(nums, y + 1, length, beforeCoins + 
            tempCoin);
            //回溯尝试其它戳法
            nums[i] = temp;
        }
    }
```

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

　　上述解法通过与样例代码跑的结果比较进行测试，结果是正确的。

　　为什么要与样例代码的结果比较而不直接提交呢，当然是超时导致提交不通过。细想下当前解法的时间复杂度就可以知道，不通过是有原因的。

　　每层有n中选择，第i层有n-i中选择，时间复杂度为n*(n-1)*(n-2)...*1即 !n。n的阶乘，指数级的时间复杂度，太可怕，我们应该想办法优化它。

　　我们都都知道，算法的时间复杂度分为多项式级时间复杂度与非多项式级时间复杂度，我们来重温一下时间复杂度的排名：

　　O(1) < O(logn) < O(n) < O(nlogn) < O(n^2) < O(n^3) < O(2^n)< O(!n)

　　其中 O(!n)与O(2^n)被称为非多项式级时间复杂度，增长速度大于且远远大于前面的多项式级时间复杂度。

　　当遇到时间复杂度为 !n 的算法时，首先考虑的是使用分治的方式将问题规模缩小。因为 !n 的增长率是恐怖的，缩小问题规模，时间复杂度的优化效果也将是立竿见影的。下面看一个很简单的例子，8的阶乘是远大于两个4的阶乘的和的：

　　8的阶乘是40320。我们如果将问题分解，比如对半分则我们将得到两个问题规模为4的子问题，时间复杂度为4的阶乘加4的阶乘等于48。

　　在将规模为8的原问题分解为两个子问题时，我们将会有6种分法，为了覆盖解空间我们需要将所有子问题的分解方式都尝试一次，则尝试所有分法的计算次数为∑( !k +!(n-k)),其中0<k<n。以问题规模为8时为例，将问题分为两个子问题的计算次数将是1804，与原问题计算40320次时相比，性能得到了极大的提升。

　　下面我们就尝试使用分治法来求解该问题。

　　***分治法****

***

　　在使用分治法时，我们应该考虑的核心问题是如何用子问题的解来表示原问题的解，也就是子问题该如何划分才能通过子问题来求解原问题。我们把描述子问题的解与原问题的解之间的关系的表达式称为状态转移方程。

　　首先我们尝试每戳破一个气球，以该气球为边界将气球数组分为两部分，使用这两部分的解来求解原问题。

　　我们设戳破区间 i 到 j 间的气球我们得到的最大金币数为coin。及coin = def( i , j )。

　　则当我们戳破气球 k 时，两边区间的最大值分别是 def( i , k-1 ) 与 def( k+1 , j )。

　　此时我们发现了问题，因为戳破了气球 k ，气球数组的相邻关系发生了改变，k-1 与 k+1 原本都与 k 相邻，而 k 戳破后他们两个直接相邻了。而且先戳破 k+1 与先戳破 k-1 得到的结果将完全不同，也就是说**两个子问题间发生了依赖**。如果先戳破 k-1 ，则 k+1 左边的相邻气球变成了 k-2；反之 k-1 右边相邻的气球变成了 k+2 。

　　子问题的处理顺序将影响到每个子问题的解，这将使我们的状态转移方程极为复杂和低效，我们**应当换一种划分子问题的方式，使每个子问题都是独立的**。

　　那么我们换一种划分方式，既然两个子问题都依赖 k 和两个边界，那么我们划分子问题时，k 与两个边界的气球我们都不戳破，求出 i+1 到 k-1 与 k+1 到 j-1 之间的解。这样两个子问题间的依赖便被消除了，两个边界及气球 k 不被戳破，两个子问题的依赖都不会越过 k 到另一个子问题上，子问题间是相互独立的。

　　并且在两个子问题解决后，气球序列还剩下 k 与两个边界的气球没有戳破，那么我们用两个子问题的解与戳破 k 与两个边界的最大值即可求出原问题的解。

　　那么 def( i , j ) 函数的定义则为，不戳破 i 与 j ，仅戳破 i 与 j 之间的气球我们能得到的最大金币数。

　　如此划分，状态转移方程为： def( i, j ) = def( i , k ) + def( k , j )+nums[ i ][ j ][ k ]

　　其中 nums[ i ][ j ][ k ] 为戳破气球 k 时我们能得到的金币数，因为def( i , j )表示戳破 i 到 j 之间的气球，自然包括 k 。

　　上述方程其实还有问题，前面说过，为了保证我们可以完整的搜索解空间，我们需要尝试所有的子问题划分方式，对于上述状态转移方程，也就是 k 的取值。k 的取值应当介于 i+1 与 j-1 之间，我们尝试所有 k 的取值并从中挑选最大值，这才是原问题真正的解。

　　真正的状态转移方程应该为：def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j

　　这样我们便找到了用子问题的解来表示原问题的解的方法，或者说子问题的划分方式。因为我们要划分子问题，必然不是只划分一次这么简单。而是要把问题一直划分到不能继续划分，也就是划分到问题规模最小的最小子问题，使效率最大化。

　　因为 k 是介于 i 与 j 之间的，那么当 i 与 j 相邻时我们的问题将不能再继续划分。此时按照我们对问题的定义，“不戳破 i 与 j ，仅戳破 i 与 j 之间的气球”，因为 i 与 j 之间没有气球，我们得到的金币数是 0 。

　　为了保证问题定义的正确性，我们向上推演一次。def( i , i+2 ) = def( i , i+1 ) + def( i+1 , i+2 ) + nums[i]*nums[ i+1]*nums[i+2]

　　def( i , i+1 ) , def( i+1 , i+2 ) 都是最小子问题，返回0。即 def( i , i+2 ) = nums[i]*nums[ i+1]*nums[i+2] 。因为问题的定义我们不戳破 i 与 i+2，所以我们只能戳破 i+1，戳破 i+1得到的金币确实是 nums[i]*nums[ i+1]*nums[i+2] 即 def( i , i+2 ) 。

　　所以说对于我们的状态转移方程 def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j ，回归条件 def( i , i+1 ) = 0 是正确的。

　　状态转移方程与回归条件都找到了，实现起来就很简单了：

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
 /**
    *   @Author Nyr
    *   @Date 2019/11/30 0:23
    *   @Param  nums:气球数组；length:数组长度，避免每层都计算一次；begin:开始下标；end:结束下标；cache:缓存，避免重复计算
    *   @Return 
    *   @Exception 
    *   @Description 状态转移方程 def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j 的实现
    */
    public static int maxCoins4(int[] nums, int length, int begin, int end,int[][] cache) {
        //回归条件，问题分解到最小子问题
        if (begin == end - 1) {
            return 0;
        }
        //缓存，避免重复计算
        if(cache[begin][end]!=0){
            return cache[begin][end];
        }
        //维护一个最大值
        int max = 0;
        //状态转移方程 def( i, j ) = max { def( i , k ) + def( k , j )+nums[ i ][ j ][ k ] } | i<k<j
        for (int i = begin + 1; i < end; i++) {
            int temp = maxCoins4(nums, length, begin, i,cache) +
                    maxCoins4(nums, length, i, end,cache) + nums[begin] * nums[i] * nums[end];
            if (temp > max) {
                max = temp;
            }
        }
        //缓存，避免重复计算
        cache[begin][end]=max;
        return max;
    }
```

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

　　我们再封装一层方法，对空数组进行处理。因为 def( i , j ) 并不戳破两个边界的气球，我们为气球数组加上虚拟的边界：

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
    public static final int maxCoins4MS(int[] nums) {
        //空数组处理
        if (nums == null) {
            return maxCoin;
        }
        //加虚拟边界
        int length = nums.length;
        int[] nums2=new int[length+2];
        System.arraycopy(nums,0,nums2,1,length);
        nums2[0]=1;
        nums2[length+1]=1;
        length=nums2.length;
        //创建缓存数组
        int[][] cache=new int[length][length];
        //调用分治函数
        return maxCoins4M(nums2, length,cache);
    }

    public static int maxCoins4M(int[] nums, int length,int[][] cache) {
        int max = maxCoins4(nums, length, 0, length - 1,cache);
        return max;
    }
```

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

　　实现很简单，一个带缓存的递归调用，我们来看一下效果，测试代码如下：

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
public static void main(String[] args) {
        int[] nums = {3,4,5,6,7,5,7,8,5,3,2,5};
        long start = System.currentTimeMillis();
        start = System.currentTimeMillis();
        System.out.println(maxCoins(nums));
        System.out.println("原始回溯用时   ：   " + 
        String.valueOf(System.currentTimeMillis() - start)+"  运算次 
        数："+sum3);
        start = System.currentTimeMillis();
        System.out.println(maxCoins4MS(nums));
        System.out.println("分治用时   ：   " + 
        String.valueOf(System.currentTimeMillis() - start)+"  运算次 
        数："+sum1+"  实际运算次数："+sum2);
    }
```

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/1858706-20191201004025044-993043804.png)

　　我在运算时加入和调用次数的计数以及计时，因为使用的是System.currentTimeMillis()进行计时，时间的精度是毫秒级，可以看到结果完全相同，分治法甚至在1毫秒之内解决了回溯使用26秒才能解决的问题。

　　运算次数上回溯运算了 8亿次 而分治法只运算了 573次，并且其中真正的运算只有 78次，另外的 495次是通过缓存避免的重复计算。

　　指数级（非多项式级时间复杂度的一种）时间复杂度的可怕可见一斑！

　　用分治法提交：

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/1858706-20191202112216927-1190509194.png)

　　效率提升到这里好像挺完美了，但我们还忽略了一点：即使使用了分治使时间复杂度大幅下降，但我们的实现中还存在着递归调用。递归调用的效率是很低的，因为牵扯到大量的函数调用，即栈帧的创建与释放。而且由于临时变量的存在以及需要保存之前栈帧的esp、程序计数器等寄存器值，在递归层数加深时会占用大量的栈空间，非常容易引起爆栈。这样的代码是绝对不可以放到生产环境上的，我们应该去思考递归调用的回归过程，通过模拟回归过程来用递推实现上述代码。

　　用递推模拟回归过程的方法，就是在上述实现的缓存 cache[i][j] 中逐渐推演，通过一步步的解决小问题来得到最终问题的解，这便是动态规划解法。

　　***动态规划***

　　动态规划算法通常用于求解具有某种最优性质的问题。在这类问题中，可能会有许多可行解。每一个解都对应于一个值，我们希望找到具有最优值的解。动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解。与分治法不同的是，适合于用动态规划求解的问题，经分解得到子问题往往不是互相独立的。对于分治法求解的问题，子问题的相互独立仅仅是同层级的子问题间没有互相依赖。但对于动态规划而言，同层级的子问题可能会依赖相同的低层级问题，这就导致低层级问题可能会被计算多次。

　　若用分治法来解这类问题，则分解得到的子问题数目太多，有些子问题被重复计算了很多次。如果我们能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，这样就可以避免大量的重复计算，节省时间。我们可以用一个表来记录所有已解的子问题的答案。不管该子问题以后是否被用到，只要它被计算过，就将其结果填入表中。这就是动态规划法的基本思路。具体的动态规划算法多种多样，但它们具有相同的填表格式。

　　其实在上面的分治解法，我加入了一个二维数组用于缓存已经计算过的子问题的结果，将缓存去掉才是概念上的分治解法。而加入了缓存避免了子问题的重复计算，已经是一个动态规划解法的雏形，我们只需要将递归改为递推便是动态规划解法。正如上面所说，通常情况下，递归的解法是不可以放在生产环境的，因为我们很难控制问题规模的大小，无法预料何时会有爆栈的风险。

　　具有最优子结构性质以及重叠子问题性质的问题可以通过动态规划求解。

　　***最优子结构***

- 如果一个问题的最优解包含其子问题的最优解，我们就称此问题具有最优子结构
- 一个问题具有最优子结构，可能使用动态规划方法，也可能使用贪心方法。所以最优子结构只是一个线索，不是看到有最优子结构就一定是用动态规划求解

　　***重叠子问题***

- 子问题空间必须足够“小”，即在不断的递归过程中，是在反复求解大量相同的子问题，而不是每次递归时都产生新的子问题。
- 一般的，不同子问题的总数是输入规模的多项式函数为好
- 如果递归算法反复求解相同的子问题，我们就称最优化问题具有重叠子问题性质

　　对于前面的分治解法，我们的计算过程分为两个阶段：

　　1、递归的不断的分解问题，直到问题不可继续分解。

　　2、当问题不可继续分解，也就是分解到最小子问题后，由最小子问题的解逐步向上回归，逐层求出上层问题的解。

　　阶段1我们称为递归过程，而阶段2我们称为递归调用的回归过程。我们要做的，就是省略递归分解子问题的过程，将阶段2用递推实现出来。

　　举个例子，对于区间 0 到 4 之间的结果，递归过程是：

　　dp[0][4] =max { dp[0][1]+dp[1][4]+nums[0]*nums[1]*nums[4] , dp[0][2]+dp[2][4]+nums[0]*nums[2]*nums[4] , dp[0][3]+dp[3][4]+nums[0]*nums[3]*nums[4] }

　　标红部分没有达到回归条件，会继续向下分解，以 dp[1][4] 为例：

　　dp[1][4]= max { dp[1][2]+dp[2][4]+nums[1]*nums[2]*nums[4] ,  dp[1][3]+dp[3][4]+nums[1]*nums[3]*nums[4] }

　　标红部分继续分解：

　　dp[2][4]= dp[2][3] + dp[3][4] + nums[2]*nums[3]*nums[4]

　　dp[1][3] = dp[1][2] + dp[1][3] + nums[1]*nums[2]*nums[3]

　　到这里因为已经分解到了最小子问题，最小子问题会带着它们的解向上回归，也就是说我们的回归过程是：dp[3][4] , dp[2][3] , dp[2][4] , dp[1][2] , dp[1][3] , dp[1][4] , dp[0][1] , dp[0][2] , dp[0][3] , dp[0][4] 。因为 dp[i][j] 依赖的是 dp[i][k] 与 dp[k][j] 其中 i < k < j ，也就是说如果要**求解 dp[ i ][ j ] 依赖了 [ i ][ 0 ] 到 [ i ][ j-1 ] 以及 [ i+1 ][ j ] 到 [ j-1 ][ j ]** 的值。那么我们在dp表中 i 从 length 递减到 0， j 从 i+1 递增到 j 推演即可。

　　如果觉着顺序抽象，可以在上述分治解法的基础上，打印出缓存数组的演变过程，来理解回归的计算顺序。

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
    /**
     * @Author Nyr
     * @Date 2019/11/30 01:43
     * @Param
     * @Return
     * @Exception
     * @Description 动态规划解法
     */
    public static int maxCoins4DP(int[] nums) {
        //避免空指针异常
        if (nums == null) {
            return 0;
        }

        //创建虚拟边界
        int length = nums.length;
        int[] nums2 = new int[length + 2];
        System.arraycopy(nums, 0, nums2, 1, length);
        nums2[0] = 1;
        nums2[length + 1] = 1;
        length = nums2.length;

        //创建dp表
        length = nums2.length;
        int[][] dp = new int[length][length];

        //开始dp：i为begin，j为end，k为在i、j区间划分子问题时的边界
        for (int i = length - 2; i > -1; i--) {
            for (int j = i + 2; j < length; j++) {
                //维护一个最大值；如果i、j相邻，值为0
                int max = 0;
                for (int k = i + 1; k < j; k++) {
                    int temp = dp[i][k] + dp[k][j] + nums2[i] * nums2[k] * nums2[j];
                    if (temp > max) {
                        max = temp;
                    }
                }
                dp[i][j] = max;
            }
        }
        return dp[0][length-1];
    }
```

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

　　用动态规划法提交：

 ![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/1858706-20191202123108553-193836935.png)

当你看清人们的真相，于是你知道了，你可以忍受孤独

#### [300. 最长上升子序列](https://leetcode-cn.com/problems/longest-increasing-subsequence/)

![image-20200820164809348](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200820164809348.png)

```java
public class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        dp[0] = 1;
        int maxans = 1;
        for (int i = 1; i < dp.length; i++) {
            int maxval = 0;
            for (int j = 0; j < i; j++) {
                if (nums[i] > nums[j]) {
                    maxval = Math.max(maxval, dp[j]);
                }
            }
            dp[i] = maxval + 1;
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
    
```

##### 方法二：贪心 + 二分查找

https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/

方法二：修改状态定义（同时用到了贪心算法、二分查找）
依然是着眼于一个上升子序列的结尾的元素；
如果已经得到的上升子序列的结尾的数越小，遍历的时候后面接上一个数，就会有更大的可能性构成一个更长的上升子序列；
既然结尾越小越好，我们可以记录在长度固定的情况下，结尾最小的那个元素的数值，这样定义也是为了方便得到「状态转移方程」。
为了与之前的状态区分，这里将状态数组命名为 tail。

第 1 步：定义新状态（特别重要）
tail[i] 表示长度为 i + 1 的所有上升子序列的结尾的最小值。

说明：

tail[0] 表示长度为 11 的所有上升子序列中，结尾最小的那个元素的数值，以题目中的示例为例 [10, 9, 2, 5, 3, 7, 101, 18] 中，容易发现长度为 2 的所有上升子序列中，结尾最小的是子序列 [2, 3] ，因此 tail[1] = 3
下标和长度有一个 1 的偏差；
状态定义其实也描述了状态转移方程。

第 2 步：思考状态转移方程
从直觉上看，数组 tail 也是一个严格上升数组。我们需要证明一下。

我们只需要维护状态数组 tail 的定义，它的长度就是最长上升子序列的长度。

下面说明如何在遍历中，如何维护状态数组 tail 的定义：

算法的执行流程
1、设置一个数组 tail，初始时为空；

注意：数组 tail 虽然是有序数组，但它不是问题中的「最长上升子序列」（下文还会强调），不能命名为 LIS。有序数组 tail 只是用于求解 LIS 问题的辅助数组。

2、在遍历数组 nums 的过程中，每来一个新数 num，如果这个数严格大于有序数组 tail 的最后一个元素，就把 num 放在有序数组 tail 的后面，否则进入第 3 点；

注意：这里的大于是「严格大于」，不包括等于的情况。

3、在有序数组 tail 中查找第 1 个等于大于 num 的那个数，试图让它变小；

如果有序数组 tail 中存在等于 num 的元素，什么都不做，因为以 num 结尾的最短的「上升子序列」已经存在；
如果有序数组 tail 中存在大于 num 的元素，找到第 1 个，让它变小，这样我们就找到了一个结尾更小的相同长度的上升子序列。
说明：我们再看一下数组 tail[i] 的定义：长度为 i + 1 的所有最长上升子序列的结尾的最小值。因此，在遍历的过程中，我们试图让一个大的值变小是合理的。

这一步可以认为是「贪心算法」，总是做出在当前看来最好的选择，当前「最好的选择」是：当前只让让第 1 个严格大于 nums[i] 的数变小，变成 nums[i]，这一步操作是“无后效性”的。

由于是在有序数组中的操作，因此可以使用「二分查找算法」。

4、遍历新的数 num ，先尝试上述第 2 点，第 2 点行不通则执行第 3 点，直到遍历完整个数组 nums，最终有序数组 tail 的长度，就是所求的“最长上升子序列”的长度。

第 3 步：思考初始化
dp[0] = nums[0]，在只有 1 个元素的情况下，它当然是长度为 1 并且结尾最小的元素。

第 4 步：思考输出
数组 tail 的长度，上文其实也已经说了，还是依据定义，tail[i] 表示长度固定为 i + 1 的所有「上升子序列」的结尾元素中最小的那个，长度最多就是数组 tail 的长度。

第 5 步：思考状态压缩
无法压缩。

下面看一下这个算法在示例上的的执行流程，以加深体会，我在示例的数组后面加上了 4、8、6、12，依然是先让幻灯片动起来，看思想就好了。

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

```java
public class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len <= 1) {
            return len;
        }

        // tail 数组的定义：长度为 i + 1 的上升子序列的末尾最小是几
        int[] tail = new int[len];
        // 遍历第 1 个数，直接放在有序数组 tail 的开头
        tail[0] = nums[0];
        // end 表示有序数组 tail 的最后一个已经赋值元素的索引
        int end = 0;

        for (int i = 1; i < len; i++) {
            // 【逻辑 1】比 tail 数组实际有效的末尾的那个元素还大
            if (nums[i] > tail[end]) {
                // 直接添加在那个元素的后面，所以 end 先加 1
                end++;
                tail[end] = nums[i];
            } else {
                // 使用二分查找法，在有序数组 tail 中
                // 找到第 1 个大于等于 nums[i] 的元素，尝试让那个元素更小
                int left = 0;
                int right = end;
                while (left < right) {
                    // 选左中位数不是偶然，而是有原因的，原因请见 LeetCode 第 35 题题解
                    // int mid = left + (right - left) / 2;
                    int mid = left + ((right - left) >>> 1);
                    if (tail[mid] < nums[i]) {
                        // 中位数肯定不是要找的数，把它写在分支的前面
                        left = mid + 1;
                    } else {
                        right = mid;
                    }
                }
                // 走到这里是因为 【逻辑 1】 的反面，因此一定能找到第 1 个大于等于 nums[i] 的元素
                // 因此，无需再单独判断
                tail[left] = nums[i];
            }
            // 调试方法
            // printArray(nums[i], tail);
        }
        // 此时 end 是有序数组 tail 最后一个元素的索引
        // 题目要求返回的是长度，因此 +1 后返回
        end++;
        return end;
    }

    // 调试方法，以观察是否运行正确
    private void printArray(int num, int[] tail) {
        System.out.print("当前数字：" + num);
        System.out.print("\t当前 tail 数组：");
        int len = tail.length;
        for (int i = 0; i < len; i++) {
            if (tail[i] == 0) {
                break;
            }
            System.out.print(tail[i] + ", ");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        int[] nums = new int[]{3, 5, 6, 2, 5, 4, 19, 5, 6, 7, 12};
        Solution solution = new Solution8();
        int lengthOfLIS = solution8.lengthOfLIS(nums);
        System.out.println("最长上升子序列的长度：" + lengthOfLIS);
    }
}

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/longest-increasing-subsequence/solution/dong-tai-gui-hua-er-fen-cha-zhao-tan-xin-suan-fa-p/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)

![image-20200820232010502](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200820232010502.png)

![image-20200820235356924](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200820235356924.png)

![image-20200820235703612](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200820235703612.png)

![image-20200821002706962](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821002706962.png)

```java
public class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        int dp[] = new int[s.length()];
        for (int i = 1; i < s.length(); i++) {
            if (s.charAt(i) == ')') {
                if (s.charAt(i - 1) == '(') {
                    dp[i] = (i >= 2 ? dp[i - 2] : 0) + 2;
                } else if (i - dp[i - 1] > 0 && s.charAt(i - dp[i - 1] - 1) == '(') {
                    dp[i] = dp[i - 1] + ((i - dp[i - 1]) >= 2 ? dp[i - dp[i - 1] - 2] : 0) + 2;
                }
                maxans = Math.max(maxans, dp[i]);
            }
        }
        return maxans;
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/longest-valid-parentheses/solution/zui-chang-you-xiao-gua-hao-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

![image-20200821002251832](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821002251832.png)

方法二：栈
思路和算法

撇开方法一提及的动态规划方法，相信大多数人对于这题的第一直觉是找到每个可能的子串后判断它的有效性，但这样的时间复杂度会达到 O(n^3)，无法通过所有测试用例。但是通过栈，我们可以在遍历给定字符串的过程中去判断到目前为止扫描的子串的有效性，同时能得到最长有效括号的长度。

具体做法是我们始终保持栈底元素为当前已经遍历过的元素中「最后一个没有被匹配的右括号的下标」，这样的做法主要是考虑了边界条件的处理，栈里其他元素维护左括号的下标：

对于遇到的每个‘(’ ，我们将它的下标放入栈中
对于遇到的每个 ‘)’ ，我们先弹出栈顶元素表示匹配了当前右括号：
如果栈为空，说明当前的右括号为没有被匹配的右括号，我们将其下标放入栈中来更新我们之前提到的「最后一个没有被匹配的右括号的下标」
如果栈不为空，当前右括号的下标减去栈顶元素即为「以该右括号为结尾的最长有效括号的长度」
我们从前往后遍历字符串并更新答案即可。

需要注意的是，如果一开始栈为空，第一个字符为左括号的时候我们会将其放入栈中，这样就不满足提及的「最后一个没有被匹配的右括号的下标」，为了保持统一，我们在一开始的时候往栈中放入一个值为 -1−1 的元素。



```
public class Solution {
    public int longestValidParentheses(String s) {
        int maxans = 0;
        Stack<Integer> stack = new Stack<>();
        stack.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                stack.push(i);
            } else {
                stack.pop();
                if (stack.empty()) {
                    stack.push(i);
                } else {
                    maxans = Math.max(maxans, i - stack.peek());
                }
            }
        }
        return maxans;
    }
}


```



![image-20200821002346979](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821002346979.png)

![image-20200821002601031](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821002601031.png)

![image-20200821002634409](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821002634409.png)

![image-20200821004129365](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821004129365.png)

```java
public class Solution {
    public int longestValidParentheses(String s) {
        int left = 0, right = 0, maxlength = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = Math.max(maxlength, 2 * right);
            } else if (right > left) {
                left = right = 0;
            }
        }
        left = right = 0;
        for (int i = s.length() - 1; i >= 0; i--) {
            if (s.charAt(i) == '(') {
                left++;
            } else {
                right++;
            }
            if (left == right) {
                maxlength = Math.max(maxlength, 2 * left);
            } else if (left > right) {
                left = right = 0;
            }
        }
        return maxlength;
    }
}


```

#### [42. 接雨水](https://leetcode-cn.com/problems/trapping-rain-water/)

![image-20200821155017539](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821155017539.png)



```
//方法一、暴力解法：
//每一根柱子上面的水是由她左边最大值 和右边 最大值 中较小的一个与它的差。把每根柱子上面的水都加起来，就是最终的容积
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int len = height.length;
        for (int i = 1; i < len - 1; i++) {
            int max_left = 0;
            int max_right = 0;
            //计算左边和右边最大值的时候，将i的位置也计算进去，就不用考虑两边最大值都比i位置小的情况
            for (int j = 0; j <= i; j++) {

                    max_left =Math.max(max_left, height[j]);

            }
            for (int j = i ; j < len ; j++) {
                max_right =Math.max(max_right, height[j]);
            }
            ans += Math.min(max_left, max_right) - height[i];
        }
        return ans;
    }

}
```

![image-20200821160734899](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821160734899.png)

```
class Solution2 {
    public int trap(int[] height) {
        {
            if (height == null)
                return 0;
            int ans = 0;
            int size = height.length;
            int[] left_max =new int [size];
            int[] right_max=new int [size];
            left_max[0] = height[0];
            for (int i = 1; i < size; i++) {
                left_max[i] = Math.max(height[i], left_max[i - 1]);
            }
            right_max[size - 1] = height[size - 1];
            for (int i = size - 2; i >= 0; i--) {
                right_max[i] =Math.max(height[i], right_max[i + 1]);
            }
            for (int i = 1; i < size - 1; i++) {
                ans += Math.min(left_max[i], right_max[i]) - height[i];
            }
            return ans;
        }

    }
}
```





![image-20200821161853014](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821161853014.png)

![image-20200821162312226](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821162312226.png)

![image-20200821162415775](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821162415775.png)

st中存储的是数组下标

![image-20200821163001383](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821163001383.png)

![image-20200821163109771](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821163109771.png)

![image-20200821164553511](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821164553511.png)

![image-20200821165500713](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821165500713.png)

![image-20200821164951263](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821164951263.png)

![image-20200821165007177](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821165007177.png)

![image-20200821165531476](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821165531476.png)

#### [64. 最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)

![image-20200823002440592](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823002440592.png)

```
class Solution {
    public int minPathSum(int[][] grid) {
        if (grid == null || grid.length == 0 || grid[0].length == 0) {
            return 0;
        }
        int rows = grid.length, columns = grid[0].length;
        int[][] dp = new int[rows][columns];
        dp[0][0] = grid[0][0];
        for (int i = 1; i < rows; i++) {
            dp[i][0] = dp[i - 1][0] + grid[i][0];
        }
        for (int j = 1; j < columns; j++) {
            dp[0][j] = dp[0][j - 1] + grid[0][j];
        }
        for (int i = 1; i < rows; i++) {
            for (int j = 1; j < columns; j++) {
                dp[i][j] = Math.min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];
            }
        }
        return dp[rows - 1][columns - 1];
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/minimum-path-sum/solution/zui-xiao-lu-jing-he-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### [70. 爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

![image-20200823003932908](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823003932908.png)

![image-20200823003958721](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823003958721.png)

![image-20200823004048018](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823004048018.png)

![image-20200823004058629](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823004058629.png)



```
 class Solution {
        public int climbStairs(int n) {
            if (n <= 1) return n;
//            每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？

            int[] dp = new int[n + 1];
            dp[0] = 1;//假设只有一种
            dp[1] = 1;//到第一个位置只有一种方法
            for (int i = 2; i <= n; i++) {

                dp[i] = dp[i - 1] + dp[i - 2];
            }
            return dp[n];


        }
    }
    public int climbStairs2(int n) {
        if (n <= 1) return n;
//            每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？


        int cur1 = 1;//假设只有一种
        int cur2 = 1;//到第一个位置只有一种方法
        int res=0;
        for (int i = 2; i <= n; i++) {


           res=cur1+cur2;
           cur1=cur2;
           cur2=res;
        }
        return res;


    }
```

![image-20200823004649073](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823004649073.png)

![image-20200823004734578](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823004734578.png)

![image-20200823005009963](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823005009963.png)

![image-20200823005815004](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823005815004.png)

![image-20200823005835640](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823005835640.png)

![image-20200823005846458](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823005846458.png)

```
 //矩阵方法
    public class Solution3 {
        public int climbStairs(int n) {
            int[][] q = {{1, 1}, {1, 0}};
            int[][] res = pow(q, n);
            return res[0][0];
        }
        public int[][] pow(int[][] a, int n) {
            int[][] ret = {{1, 0}, {0, 1}};
            while (n > 0) {
                if ((n & 1) == 1) {
                    ret = multiply(ret, a);
                }
                n >>= 1;
                a = multiply(a, a);
            }
            return ret;
        }
        public int[][] multiply(int[][] a, int[][] b) {
            int[][] c = new int[2][2];
            for (int i = 0; i < 2; i++) {
                for (int j = 0; j < 2; j++) {
                    c[i][j] = a[i][0] * b[0][j] + a[i][1] * b[1][j];
                }
            }
            return c;
        }
    }
```

![image-20200823005645768](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823005645768.png)

![image-20200823005708884](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823005708884.png)

```
public class Solution {
    public int climbStairs(int n) {
        double sqrt5 = Math.sqrt(5);
        double fibn = Math.pow((1 + sqrt5) / 2, n + 1) - Math.pow((1 - sqrt5) / 2, n + 1);
        return (int)(fibn / sqrt5);
    }
}

```

#### [72. 编辑距离](https://leetcode-cn.com/problems/edit-distance/)

![image-20200823101852437](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823101852437.png)

递归的出口：一方为0，另一方对剩余的字符串挨个进行插入或删除操作

如果最后一位字符相同，就看递归 前推 一步的结果

否则进行插入、删除 替换操作，根据每个不同的操作，加上对应的递归子问题的步骤的最小解决子问题的步骤数+1，就是当前问题的最优解

![image-20200823102049174](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823102049174.png)

![image-20200823102545749](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823102545749.png)

会超时

![image-20200823102615937](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823102615937.png)

因此，我们就可以使用动态规划来解决这个问题了。我们用 `opt[i][j]` 表示 `A` 的前 `i` 个字母和 `B` 的前 `j` 个字母之间的编辑距离。

状态转移方程：

![image-20200823105746116](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823105746116.png)



`对于边界情况，一个空串和一个非空串的编辑距离为 D[i][0] = i 和 D[0][j] = j，D[i][0] 相当于对 word1 执行 i 次删除操作，D[0][j] 相当于对 word1执行 j 次插入操作。`



![image-20200823102821249](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823102821249.png)
![image-20200823102838635](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200823102838635.png)
![image-20200823102905339](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200823102905339.png)
![72_fig1.PNG](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/426564dbe63a8cdec3de2ebe83ea2a2640bbff41d18c1bac739c9ae4542854af-72_fig1.PNG)
![image-20200823102942456](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200823102942456.png)
![image-20200823103004784](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200823103004784.png)

#### [85. 最大矩形](https://leetcode-cn.com/problems/maximal-rectangle/)

##### 方法一: 动态规划 - 使用柱状图的优化暴力方法

遍历每个点，求以这个点为矩阵右下角的所有矩阵面积。如下图的两个例子，橙色是当前遍历的点，然后虚线框圈出的矩阵是其中一个矩阵。

![image-20200824094513897](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824094513897.png)

1.首先求出高度是 1 的矩形面积，也就是它自身的数，如图中橙色的 4，面积就是 4。

![image.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/cb03542bb14becd73ddc9af3700f25cda782b5bb049c8bc13e3ab344bc1e09f4-image.png)

2.然后向上扩展一行，高度增加一，选出当前列最小的数字，作为矩阵的宽，求出面积，对应上图的矩形框。

![image.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/23c8266cd3f7d1d004b4ab1890097865ddafb524f95e103fccbb79f11b672051-image.png)

3.然后继续向上扩展，重复步骤 2。

![image.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/2fef628d76686b283691d8989e08bf4ba24e4639dd8d1149f8a19b22cd254ddd-image.png)

按照上边的方法，遍历所有的点，求出所有的矩阵就可以了。

以橙色的点为右下角，高度为 1。

```java
public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) {
        return 0;
    }
    //保存以当前数字结尾的连续 1 的个数
    int[][] width = new int[matrix.length][matrix[0].length];
    int maxArea = 0;
    //遍历每一行
    for (int row = 0; row < matrix.length; row++) {
        for (int col = 0; col < matrix[0].length; col++) {
            //更新 width
            if (matrix[row][col] == '1') {//这个点是1才找该行以该点结尾的连续1的长度
                if (col == 0) {
                    width[row][col] = 1;//这个点在最左边
                } else {
                    width[row][col] = width[row][col - 1] + 1;
                    //等于前一个点该行以该点结尾的连续1的长度+1
                }
            } else {
                width[row][col] = 0;//不是1 长度就是0
            }
            //记录所有行中最小的数
            int minWidth = width[row][col];
            //向上扩展行
            for (int up_row = row; up_row >= 0; up_row--) {
                int height = row - up_row + 1;//高度就是两行之间的高度[up_row,row]都是闭区间
                //找最小的数作为矩阵的宽
                minWidth = Math.min(minWidth, width[up_row][col]);
                //更新面积
                maxArea = Math.max(maxArea, height * minWidth);
            }
        }
    }
    return maxArea;
}

```



参考[这里](https://leetcode.com/problems/maximal-rectangle/discuss/29064/A-O(n2)-solution-based-on-Largest-Rectangle-in-Histogram)，接下来的解法，会让这道题变得异常简单。还记得 [84 题](https://leetcode.wang/leetCode-84-Largest-Rectangle-in-Histogram.html)吗？求一个直方图矩形的最大面积。

![image-20200824100038407](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824100038407.png)

```
public int maximalRectangle(char[][] matrix) {
    if (matrix.length == 0) {
        return 0;
    }
    int[] heights = new int[matrix[0].length];
    int maxArea = 0;
    for (int row = 0; row < matrix.length; row++) {
        //遍历每一列，更新高度
        for (int col = 0; col < matrix[0].length; col++) {
            if (matrix[row][col] == '1') {
                heights[col] += 1;
            } else {
                heights[col] = 0;
            }
        }
        //调用上一题的解法，更新函数
        maxArea = Math.max(maxArea, largestRectangleArea(heights));
    }
    return maxArea;
}

public int largestRectangleArea(int[] heights) {
    int maxArea = 0;
    Stack<Integer> stack = new Stack<>();
    int p = 0;
    while (p < heights.length) {
        //栈空入栈
        if (stack.isEmpty()) {
            stack.push(p);
            p++;
        } else {
            int top = stack.peek();
            //当前高度大于栈顶，入栈
            if (heights[p] >= heights[top]) {
                stack.push(p);
                p++;
            } else {
                //保存栈顶高度
                int height = heights[stack.pop()];
                //左边第一个小于当前柱子的下标
                int leftLessMin = stack.isEmpty() ? -1 : stack.peek();
                //右边第一个小于当前柱子的下标
                int RightLessMin = p;
                //计算面积
                int area = (RightLessMin - leftLessMin - 1) * height;
                maxArea = Math.max(area, maxArea);
            }
        }
    }
    while (!stack.isEmpty()) {
        //保存栈顶高度
        int height = heights[stack.pop()];
        //左边第一个小于当前柱子的下标
        int leftLessMin = stack.isEmpty() ? -1 : stack.peek();
        //右边没有小于当前高度的柱子，所以赋值为数组的长度便于计算
        int RightLessMin = heights.length;
        int area = (RightLessMin - leftLessMin - 1) * height;
        maxArea = Math.max(area, maxArea);
    }
    return maxArea;
}


```

暴力算法的本质：

![image.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/ffba9c5b4b0799150e5b798a73d96c8313522362e9b5290dcff7d9a43f46ba14-image.png)

于是，上述方法本质上是 [84 - 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/) 题中优化暴力算法的复用。

##### 方法三：使用柱状图 - 栈

算法

在上一方法中我们讨论了将输入拆分成一系列的柱状图，每个柱状图代表一列的子结构。为了计算长方形的最大面积，我们仅仅需要计算每个柱状图中的最大面积并找到全局最大值（注意后面的解法对每一行而非列建立了柱状图，两者思想一致）。

既然我们已经有了 84 - 柱状图中最大的矩形，可以直接使用该题题解中最快的基于栈的解法 点击这里 ，并将其应用在我们生成的柱状图中。想详细了解该算法的原理，请点击上面的链接。

```
class Solution {

    // Get the maximum area in a histogram given its heights
    public int leetcode84(int[] heights) {
        Stack < Integer > stack = new Stack < > ();
        stack.push(-1);
        int maxarea = 0;
        for (int i = 0; i < heights.length; ++i) {
            while (stack.peek() != -1 && heights[stack.peek()] >= heights[i])
                maxarea = Math.max(maxarea, heights[stack.pop()] * (i - stack.peek() - 1));
            stack.push(i);
        }
        while (stack.peek() != -1)
            maxarea = Math.max(maxarea, heights[stack.pop()] * (heights.length - stack.peek() -1));
        return maxarea;
    }

    public int maximalRectangle(char[][] matrix) {

        if (matrix.length == 0) return 0;
        int maxarea = 0;
        int[] dp = new int[matrix[0].length];

        for(int i = 0; i < matrix.length; i++) {
            for(int j = 0; j < matrix[0].length; j++) {

                // update the state of this row's histogram using the last row's histogram
                // by keeping track of the number of consecutive ones

                dp[j] = matrix[i][j] == '1' ? dp[j] + 1 : 0;
            }
            // update maxarea with the maximum area from this row's histogram
            maxarea = Math.max(maxarea, leetcode84(dp));
        } return maxarea;
    }
}

```

其中 `力扣 84` 下的代码是从 [84 - 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)的题解中复制来的。

复杂度分析

时间复杂度 : O(NM)O(NM)。对每一行运行 力扣 84 需要 M (每行长度) 时间，运行了 N 次，共计 O(NM)O(NM)。

空间复杂度 : O(M)O(M)。我们声明了长度等于列数的数组，用于存储每一行的宽度。

##### 方法四：动态规划 - 每个点的最大高度

![image-20200824102932472](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824102932472.png)

![image-20200824103048284](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824103048284.png)
![image-20200824103139966](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200824103139966.png)
![image-20200824103343195](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200824103343195.png)

#### [96. 不同的二叉搜索树](https://leetcode-cn.com/problems/unique-binary-search-trees/)

![image-20200824143035089](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200824143035089.png)
![image-20200824143102449](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200824143102449.png)
![image-20200824143118436](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824143118436.png)

```
class Solution {
    public int numTrees(int n) {
int[] g = new int[n + 1];
            g[0] = 1;
            g[1] = 1;
            for (int i = 2; i <= n; i++) {// G(i): 长度为 i 的序列能构成的不同二叉搜索树的个数。
                for (int j = 1; j <= i; j++) {//j表示由1到i节点分别作为二叉搜索树的根有几种方案
                    g[i]+=g[j-1]*g[i-j];

                }
            }
            return g[n];
    }
}
```

![image-20200824144713628](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824144713628.png)

https://baike.baidu.com/item/catalan/7605685?fr=aladdin

#### [139. 单词拆分](https://leetcode-cn.com/problems/word-break/)

##### dp

![image-20200825090122768](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200825090122768.png)

```
 //动态规划，关键是用set保存字典，然后用set.contains来查找子字符串是否在字典中,set的应用
    class Solution {
        public boolean wordBreak(String s, List<String> wordDict) {
            int len = s.length();
            Set<String> wordDictSet = new HashSet<>(wordDict);
            boolean[] dp = new boolean[len + 1];
            dp[0] = true;//初试状态 表示没有字符的时候，肯定是true
            for (int i = 1; i <= len; i++) {
                for (int j = 0; j < i; j++) {
                    if (dp[j] && wordDictSet.contains(s.substring(j, i))) {
                        dp[i] = true;
                        break;
                    }
                }

            }
            return dp[s.length()];
        }
    }
//    优化一下，dp[i]只需要往前探索到词典里最长的单词即可，优化后击败100%

    class Solution2 {
        public boolean wordBreak(String s, List<String> wordDict) {
            int len = s.length(), maxw = 0;
            boolean[] dp = new boolean[len + 1];
            dp[0] = true;
            Set<String> set = new HashSet();
            for(String str : wordDict){
                set.add(str);
                maxw = Math.max(maxw, str.length());
            }
            for(int i = 1; i < len + 1; i++){
                for(int j = i; j >= 0 && j >= i - maxw; j--){
                    if(dp[j] && set.contains(s.substring(j, i))){
                        dp[i] = true;
                        break;
                    }
                }
            }
            return dp[len];
        }
    }
    // dfs
    // 来自java最快提交，很简洁，只是有面向用例痕迹
    public class Solution3 {
        public boolean wordBreak(String s, List<String> wordDict) {
            if (s.length() == 0) return true;
            if (s.length() >= 151) return false;
            for (int i = 0; i < wordDict.size(); i++) {
                String word = wordDict.get(i);
                if (s.startsWith(word)) {
                    // substring (int beginIndex)从beginIndex开始截取字符串到字符串结尾
                    if (wordBreak(s.substring(word.length()), wordDict))
                        return true;
                }
            }
            return false;
        }
    }
```

##### dfs

抄个提交最快的dfs和自己写的作了简单优化的dfs。提交的时候还有点怕超时，没想到99.81%。 简单说就是加了个长度判断外带访问数组来剪枝。（还加了个奇怪东西跳递归）想法上如果能获得字典中，不同单词是否互为前缀，比方说，我找到了cat，我知道字典中存在的以cat为前缀的单词只有cats,cattle，cataclysm的话，问题会变得很简单。但没想到简洁有效的做法。

另外不知道两边同时往里跑会不会更快一些，比方说"leetcodeog"，["leet"."code"]，在人的视角，看到后缀是og，一眼就能看出不匹配，程序视角，匹配到 odeog的时候也应当知道不匹配。

顺便，推荐把相似里的[单词拆分II](https://leetcode-cn.com/problems/word-break-ii/)一块做了，可以用相似的方法做，剪枝麻烦点。

```java
// 来自java最快提交，很简洁，只是有面向用例痕迹
public class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        if (s.length() == 0) return true;
        if (s.length() >= 151) return false;
        for (int i = 0; i < wordDict.size(); i++) {
            String word = wordDict.get(i);
            if (s.startsWith(word)) {
                if (wordBreak(s.substring(word.length()), wordDict))
                    return true;
            }
        }
        return false;
    }
}
```

#### [Trie（前缀树/字典树）及其应用](https://www.cnblogs.com/bonelee/p/8830825.html)

#### [140. 单词拆分 II](https://leetcode-cn.com/problems/word-break-ii/)

```java
class Solution {
// 异常
    static class StopMsgException extends RuntimeException {
    }

    boolean[] visited;// 访问数组

    /**
     * 给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。
     * 说明： 拆分时可以重复使用字典中的单词。 你可以假设字典中没有重复的单词。
     *  使用hashSet暴力dfs，用访问数组作简单优化
     * @param s        非空字符串
     * @param wordDict 字典
     * @return 若字符串能由字典单词组成，返回true，反之，false
     */
    public boolean wordBreak(String s, List<String> wordDict) {
        // 输入校验
        if (s == null || wordDict == null)
            return false;
        // 对应字典中最长最短字符串的长度
        int minWordLen = Integer.MAX_VALUE;
        int maxWordLen = Integer.MIN_VALUE;
        visited = new boolean[s.length() + 1];// 记录哪个索引开始的地方已经搜索过,因为subString奇怪的特性，长度加1
        HashSet<String> dict = new HashSet<String>();
        // 获得set表示的字典，和字典最长最短字符串长度
        for (String word : wordDict) {
            dict.add(word);
            minWordLen = Math.min(minWordLen, word.length());
            maxWordLen = Math.max(maxWordLen, word.length());
        }
        // 又是跳递归
        try {
            dfs(s, dict, 0, minWordLen, maxWordLen);
        } catch (StopMsgException e) {
            return true;
        }
        return false;
    }

    /**
     * 递归子方法，判断对应非空字符串能否由字典中的单词构成
     * 
     * @param s          非空字符串
     * @param dict       字典集合
     * @param index      当前索引
     * @param minWordLen 字典中最短字符串长度
     * @param maxWordLen 字典中最长字符串长度
     * @return 若字符串能由字典单词组成，返回true，反之，false
     */
    private void dfs(String s, HashSet<String> dict, int index, int minWordLen, int maxWordLen) {
        int start = index;
        index += minWordLen;// 下一个字符串长度至少为最短字符串长度
        // 寻找所有长度为min-max之间的字符串
        // 注意这里index的取值，是有可能取到s.length的，避免visited越界，还特地加长了
        for (; index <= start + maxWordLen && index <= s.length(); index++) {
            String currString = s.substring(start, index);
            // 若字典中存在当前字符串，且从该索引还未开始过dfs,开始一次dfs
            if (dict.contains(currString) && !visited[index]) {
                // 当当前索引指向字符串终点时，说明完全匹配
                if (index == s.length())
                    throw new StopMsgException();
                visited[index] = true;
                dfs(s, dict, index, minWordLen, maxWordLen);
            }
        }
    }
}   
```

#### [152. 乘积最大子数组](https://leetcode-cn.com/problems/maximum-product-subarray/)

![image-20200826002115035](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200826002115035.png)
![image-20200826002157956](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826002157956.png)





![image-20200826002320224](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826002320224.png)

![image-20200826002812026](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826002812026.png)

![image-20200826002831687](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826002831687.png)

```java 
class Solution {
    public int maxProduct(int[] nums) {
        int max = Integer.MIN_VALUE, imax = 1, imin = 1;
        for(int i=0; i<nums.length; i++){
            if(nums[i] < 0){ 
              int tmp = imax;
              imax = imin;
              imin = tmp;
            }
            imax = Math.max(imax*nums[i], nums[i]);
            imin = Math.min(imin*nums[i], nums[i]);
            
            max = Math.max(max, imax);
        }
        return max;
    }
}

```





![image-20200826014017790](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826014017790.png)

![image-20200826014627293](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826014627293.png)

```java
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int length = nums.length;
        if (length == 1) {
            return nums[0];
        }
        int[] dp = new int[length];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for (int i = 2; i < length; i++) {
            dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[length - 1];
    }
}

```

上述方法使用了数组存储结果。考虑到每间房屋的最高总金额只和该房屋的前两间房屋的最高总金额相关，因此可以使用滚动数组，在每个时刻只需要存储前两间房屋的最高总金额。

```
class Solution {
    public int rob(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0;
        }
        int length = nums.length;
        if (length == 1) {
            return nums[0];
        }
        int first = nums[0], second = Math.max(nums[0], nums[1]);
        for (int i = 2; i < length; i++) {
            int temp = second;
            second = Math.max(first + nums[i], second);
            first = temp;
        }
        return second;
    }
}


```

#### [221. 最大正方形](https://leetcode-cn.com/problems/maximal-square/)

```
class Solution {
        //动态规划
        public int maximalSquare(char[][] matrix) {
            int maxSide = 0;
            if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
                return maxSide;
            }
            int rows = matrix.length, columns = matrix[0].length;
            for (int i = 0; i < rows; i++) {
                for (int j = 0; j < columns; j++) {
                    if (matrix[i][j] == '1') {
                        // 遇到一个 1 作为正方形的左上角
                        maxSide = Math.max(maxSide, 1);
                        // 计算可能的最大正方形边长
                        int currentMaxSide = Math.min(rows - i, columns - j);
                        for (int k = 1; k < currentMaxSide; k++) {
                            // 判断新增的一行一列是否均为 1
                            boolean flag = true;
                            if (matrix[i + k][j + k] == '0') {
                                break;
                            }
                            for (int m = 0; m < k; m++) {
                                if (matrix[i + k][j + m] == '0' || matrix[i + m][j + k] == '0') {
                                    flag = false;
                                    break;
                                }
                            }
                            if (flag) {
                                maxSide = Math.max(maxSide, k + 1);
                            } else {
                                break;
                            }
                        }
                    }
                }
            }
            int maxSquare = maxSide * maxSide;
            return maxSquare;
        }
    }
```





## 三、KMP算法：

**部分匹配表**

![image-20200514130139201](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514130139201.png)

代码实现

![image-20200514132626858](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514132626858.png)

看av16828557，亲测有效，解释了为什么用到next[j-1]

![image-20200514133715769](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514133715769.png)



## 四、贪心算法

![image-20200514134337641](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514134337641.png)

![image-20200514134435925](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514134435925.png)

也就是每次选当前的最优解

老师的if语句上面少了一句 broadcasts.get(maxKey).retainAll(allAreas);

不要求交集呀 ，hashset是不会存在相同的元素的，如果maxkey里面存在已经选择的地区，那么这个地区在add进selects的时候是重复的不会加进去的



![image-20200816101125889](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816101125889.png)

![image-20200816104511536](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816104511536.png)

![image-20200816104543215](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816104543215.png)

![image-20200816104558079](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816104558079.png)











#### 贪心算法的基本要素

![image-20200816104446705](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816104446705.png)



#### 2.背包问题

不是0-1背包问题，0-1背包问题不能用动态规划

![image-20200816104703276](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816104703276.png)

![image-20200816104750827](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816104750827.png)

![image-20200816104825481](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816104825481.png)

![image-20200816105401948](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200816105753231.png)
![image-20200816105735177](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816105735177.png)

![image-20200816105713708](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816105713708.png)











#### 3.活动安排问题

![image-20200816101318177](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816101318177.png)

![image-20200816101437766](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816101437766.png)

![image-20200816101833522](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816101833522.png)

![image-20200816102158298](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816102158298.png)

![image-20200816102321372](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816102321372.png)



![image-20200816102415712](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816102415712.png)

![image-20200816102609099](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816102609099.png)

![image-20200816102840852](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816102840852.png)
![image-20200816102857663](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200816102857663.png)

![image-20200816103843396](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816103843396.png)

![image-20200816104041782](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816104041782.png)

![image-20200816104301387](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816104301387.png)

#### 4.最优装载问题

![image-20200816105927644](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816105927644.png)

![image-20200816110035933](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816110035933.png)

![image-20200816110305919](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816110305919.png)

![image-20200816110400792](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200816110400792.png)



#### [406.](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)[根据身高重建队列](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

```
* 该策略可以递归进行：
*(h,k)
* 将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。
*按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。
* 直到完成为止。
*排序：
* 按高度降序排列。
* 在同一高度的人中，按 k 值的升序排列。
* 逐个地把它们放在输出队列中，索引等于它们的 k 值。
* 返回输出队列
*核心思路就是先排高个子的人，因为低个子的人的顺序对高个子的k值无影响，然后按照h的降序将低个子按k值插入到高个子中，就是最终的排序。
```

```java
class Solution {
        public int[][] reconstructQueue(int[][] people) {
            Arrays.sort(people, new Comparator<int[]>() {
                @Override
                public int compare(int[] o1, int[] o2) {
                    // if the heights are equal, compare k-values
                    // 先按身高h的降序排列，h相同的话按k的升序排列
                    // 先按身高降序排序，相同身高按k升序排序，经过此次排序后高的人一定在矮的人的前面并且相同高度的人的相对顺序就是最终结果的相对顺序。请记住这两点，敲黑板
                    return o1[0] == o2[0] ? o1[1] - o2[1] : o2[0] - o1[0];
                }
            });
//            创建一个集合，这个集合的每个元素是一个一维数组，也就是我们二维数组的一行。
            List<int[]> output = new LinkedList<>();
//            以行为单位遍历排好序的people[][]数组，假设每行数据是p[], 把每行元素插入到集合的索引为p[1]的位置，
            for (int[] p : people) {
                output.add(p[1], p);
            }
//            把集合中的数据转换为一个二维数组，返回即是正确结果
            int n = people.length;
            return output.toArray(new int[n][2]);
        }
    }
```

#### [55. 跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

![image-20200822214206285](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822214206285.png)

![image-20200822214306774](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822214306774.png)

在遍历完成之后，位置 4仍然不可达，因此我们返回 `False`。

```
public class Solution {
    public boolean canJump(int[] nums) {
        int n = nums.length;
        int rightmost = 0;
        for (int i = 0; i < n; ++i) {
            if (i <= rightmost) {
                rightmost = Math.max(rightmost, i + nums[i]);
                if (rightmost >= n - 1) {
                    return true;
                }
            }
        }
        return false;
    }
}
```

![image-20200822215124133](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822215124133.png)



java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0  at line 6, Solution.minPathSum  at line 57, __DriverSolution__.__helper__

## 五、普利姆算法

最小生成树

![image-20200514181754026](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514181754026.png)

![image-20200514181834669](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514181834669.png)

![image-20200514182435014](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514182435014.png)

![image-20200514182420745](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514182420745.png)

![image-20200514183748791](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514183748791.png)

## 六、克鲁斯卡尔算法

![image-20200514202432145](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514202432145.png)

公交站问题

![image-20200514202641214](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514202641214.png)

![image-20200514202717106](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514202717106.png)



![image-20200514202817542](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514202817542.png)

![image-20200514202907603](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514202907603.png)

![image-20200514202944434](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514202944434.png)

![image-20200514204527045](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514204527045.png)

![image-20200514203807469](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514203807469.png)

哈哈，谁误导呢，前面老师不是说按字母顺序看终点吗，乐死我了

B加入之后进行排序，变成B,C,D,E,F,因此B的终点是F

这个描述的确是并查集



邻接矩阵



## 七、回溯算法

回溯其实是“深度优先遍历”特有的一种现象。之所以是“深度优先遍历”，是因为我们要解决的问题通常是在一棵树上完成的，在这棵树上搜索需要的答案，一般使用深度优先遍历。

“全排列”就是一个非常经典的“回溯”算法的应用。我们知道，N 个数字的全排列一共有 N!N! 这么多个。

大家可以尝试一下在纸上写 3 个数字、4 个数字、5 个数字的全排列，相信不难找到这样的方法。

以数组 [1, 2, 3] 的全排列为例。

我们先写以 1 开头的全排列，它们是：[1, 2, 3], [1, 3, 2]；
再写以 2 开头的全排列，它们是：[2, 1, 3], [2, 3, 1]；
最后写以 3 开头的全排列，它们是：[3, 1, 2], [3, 2, 1]。
我们只需要按顺序枚举每一位可能出现的情况，已经选择的数字在接下来要确定的数字中不能出现。按照这种策略选取就能够做到不重不漏，把可能的全排列都枚举出来。

在枚举第一位的时候，有 3 种情况。
在枚举第二位的时候，前面已经出现过的数字就不能再被选取了；
在枚举第三位的时候，前面 2 个已经选择过的数字就不能再被选取了。
这样的思路，我们可以用一个树形结构表示。看到这里的朋友，建议自己先尝试画一下“全排列”问题的树形结构。

使用编程的方法得到全排列，就是在这样的一个树形结构中进行编程，具体来说，就是执行一次深度优先遍历，从树的根结点到叶子结点形成的路径就是一个全排列。

![image-20200822104144948](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822104144948.png)



说明：

1、每一个结点表示了“全排列”问题求解的不同阶段，这些阶段通过变量的“不同的值”体现；
2、这些变量的不同的值，也称之为“状态”；
3、使用深度优先遍历有“回头”的过程，在“回头”以后，状态变量需要设置成为和先前一样；
4、因此在回到上一层结点的过程中，需要撤销上一次选择，这个操作也称之为“状态重置”；
5、深度优先遍历，可以直接借助系统栈空间，为我们保存所需要的状态变量，在编码中只需要注意遍历到相应的结点的时候，状态变量的值是正确的，具体的做法是：往下走一层的时候，path 变量在尾部追加，而往回走的时候，需要撤销上一次的选择，也是在尾部操作，因此 path 变量是一个栈。
6、深度优先遍历通过“回溯”操作，实现了全局使用一份状态变量的效果。

下面我们解释如何编码：

1、首先这棵树除了根结点和叶子结点以外，每一个结点做的事情其实是一样的，即在已经选了一些数的前提，我们需要在剩下还没有选择的数中按照顺序依次选择一个数，这显然是一个递归结构；

2、递归的终止条件是，数已经选够了，因此我们需要一个变量来表示当前递归到第几层，我们把这个变量叫做 depth；

3、这些结点实际上表示了搜索（查找）全排列问题的不同阶段，为了区分这些不同阶段，我们就需要一些变量来记录为了得到一个全排列，程序进行到哪一步了，在这里我们需要两个变量：

（1）已经选了哪些数，到叶子结点时候，这些已经选择的数就构成了一个全排列；
（2）一个布尔数组 used，初始化的时候都为 false 表示这些数还没有被选择，当我们选定一个数的时候，就将这个数组的相应位置设置为 true ，这样在考虑下一个位置的时候，就能够以 O(1)O(1) 的时间复杂度判断这个数是否被选择过，这是一种“以空间换时间”的思想。

我们把这两个变量称之为“状态变量”，它们表示了我们在求解一个问题的时候所处的阶段。

4、在非叶子结点处，产生不同的分支，这一操作的语义是：在还未选择的数中依次选择一个元素作为下一个位置的元素，这显然得通过一个循环实现。

5、另外，因为是执行深度优先遍历，从较深层的结点返回到较浅层结点的时候，需要做“状态重置”，即“回到过去”、“恢复现场”，我们举一个例子。

从 [1, 2, 3] 到 [1, 3, 2] ，深度优先遍历是这样做的，从 [1, 2, 3] 回到 [1, 2] 的时候，需要撤销刚刚已经选择的数 3，因为在这一层只有一个数 3 我们已经尝试过了，因此程序回到上一层，需要撤销对 2 的选择，好让后面的程序知道，选择 3 了以后还能够选择 2。

这种在遍历的过程中，从深层结点回到浅层结点的过程中所做的操作就叫“回溯”。

下面来看看代码应该如何编写：

```
import java.util.ArrayList;
import java.util.List;


public class Solution {

    public List<List<Integer>> permute(int[] nums) {
        // 首先是特判
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List<List<Integer>> res = new ArrayList<>();

        if (len == 0) {
            return res;
        }

        boolean[] used = new boolean[len];
        List<Integer> path = new ArrayList<>();

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     List<Integer> path, boolean[] used,
                     List<List<Integer>> res) {
        if (depth == len) {
            res.add(path);
            return;
        }

        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                path.add(nums[i]);
                used[i] = true;

                dfs(nums, len, depth + 1, path, used, res);
                // 注意：这里是状态重置，是从深层结点回到浅层结点的过程，代码在形式上和递归之前是对称的
                used[i] = false;
                path.remove(path.size() - 1);
            }
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        Solution solution = new Solution();
        List<List<Integer>> lists = solution.permute(nums);
        System.out.println(lists);
    }
}

```

这段代码在运行的时候输出如下：

```
[[], [], [], [], [], []]
```

原因出现在递归终止条件这里：



if (depth == len) {
    res.add(path);
    return;
}
path 这个变量所指向的对象在递归的过程中只有一份，深度优先遍历完成以后，因为回到了根结点（因为我们之前说了，从深层结点回到浅层结点的时候，需要撤销之前的选择），因此 path 这个变量回到根结点以后都为空。

在 Java 中，因为都是值传递，对象类型变量在传参的过程中，复制的都是变量的地址。（Python 我不是很清楚 Python 中方法变量的传递机制，所以暂时没有写，欢迎知道的朋友补充，但是从实验的结果上看和 Java 很像。）这些地址被添加到 res 变量，但实际上指向的是同一块内存地址，因此我们会看到 6 个空的列表对象。解决的方法很简单，在 res.add(path); 这里做一次拷贝即可。

修改的部分：

JavaPython

if (depth == len) {
    res.add(new ArrayList<>(path));
    return;
}
此时再提交到「力扣」上就能得到一个 Accept 了。

![image-20200822110409574](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822110409574.png)

![image-20200822110420894](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822110420894.png)



```
import java.util.ArrayList;
import java.util.List;


public class Solution {

    public List<List<Integer>> permute(int[] nums) {
        // 首先是特判
        int len = nums.length;
        // 使用一个动态数组保存所有可能的全排列
        List<List<Integer>> res = new ArrayList<>();

        if (len == 0) {
            return res;
        }

        boolean[] used = new boolean[len];
        List<Integer> path = new ArrayList<>();

        dfs(nums, len, 0, path, used, res);
        return res;
    }

    private void dfs(int[] nums, int len, int depth,
                     List<Integer> path, boolean[] used,
                     List<List<Integer>> res) {
        if (depth == len) {
            // 3、不用拷贝，因为每一层传递下来的 path 变量都是新建的
            res.add(path);
            return;
        }

        for (int i = 0; i < len; i++) {
            if (!used[i]) {
                // 1、每一次尝试都创建新的变量表示当前的"状态"
                List<Integer> newPath = new ArrayList<>(path);
                newPath.add(nums[i]);

                boolean[] newUsed = new boolean[len];
                System.arraycopy(used, 0, newUsed, 0, len);
                newUsed[i] = true;

                dfs(nums, len, depth + 1, newPath, newUsed, res);
                // 2、无需回溯
            }
        }
    }
}

```

这就好比我们在实验室里做“对比实验”，每一个步骤的尝试都要保证使用的材料是一样的。我们有两种办法：

（1）每做完一种尝试，都把实验材料恢复成做上一个实验之前的样子，只有这样做出的对比才有意义；
（2）每一次尝试都使用同样的新的材料做实验。

在生活中做实验对材料有破坏性，这个过程通常不可逆。而在计算机的世界里，“恢复现场”和“回到过去”是相对容易的。

在一些字符串的“回溯”问题中，有时不需要回溯的原因是这样的：字符串变量在拼接的过程中会产生新的对象（针对 Java 和 Python 语言，其它语言我并不清楚）。

如果你使用 Python 语言，会知道有这样一种语法：[1, 2, 3] + [4] 也是创建了一个新的列表对象，我们已经在“参考代码 2”中展示这种写法。

2、也可以不使用 used 数组，在遍历的过程中，对于一个数是否使用过，就得遍历 path 里的每一个元素，这个操作的时间复杂度是 O(N)O(N)，整体复杂度变大。一般情况下，没有必要节约这个空间。“全排列”问题还有一种经典的实现方式，是基于交换实现的，可以节约 used 数组，其他朋友写的题解中有这种做法，欢迎大家查看。

3、ArrayList 是 Java 中的动态数组，Java 建议我们如果一开始就知道这个集合里需要保存元素的大小，可以在初始化的时候直接传入。

在 res 变量初始化的时候，最好传入 len 的阶乘，让 ArrayList 在代码执行的过程中不发生扩容行为。同理，在 path 变量初始化的时候，最好传入 len，这个路径变量最长也就到 len 为止。

4、path 变量我们发现只是对它的末尾位置进行增加和删除的操作，显然它是一个栈，因此，使用栈语义会更清晰。但同时 Stack 这个类的文档我们，由于一些设计上的问题，建议我们使用：

Java

Deque<Integer> stack = new ArrayDeque<Integer>();
这一点让我很奔溃，Deque 是双端队列，它提供了更灵活的接口，同时破坏了语义，一不小心，如果用错了接口，就会导致程序错误。我采用的做法是接受官方的建议，但是在程序变量命名和使用的接口时让语义清晰：

这里 path 我需要表示它是从根结点到叶子结点的路径，我认为这个语义更重要，因此不改名为 stack。而在末尾添加元素和删除元素的时候，分别使用 addLast() 和 removeLast() 方法这两个最直接的方法强调只在 path 变量的末尾操作。

5、布尔数组在这题里的作用是判断某个位置上的元素是否已经使用过。有两种等价的替换方式：

（1）哈希表；
（2）位掩码，即使用一个整数表示布尔数组。此时可以将空间复杂度降到 O(1)O(1)（不包括 path 变量和 res 变量和递归栈空间消耗）。

参考代码 3：

JavaPython

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.HashSet;
import java.util.List;
import java.util.Set;

public class Solution {

    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
    
        List<List<Integer>> res = new ArrayList<>(factorial(len));
        if (len == 0) {
            return res;
        }
    
        // 使用哈希表检测一个数字是否使用过
        Set<Integer> used = new HashSet<>(len);
        Deque<Integer> path = new ArrayDeque<>(len);
    
        dfs(nums, len, 0, path, used, res);
        return res;
    }
    
    private int factorial(int n) {
        int res = 1;
        for (int i = 2; i <= n; i++) {
            res *= i;
        }
        return res;
    }
    
    private void dfs(int[] nums, int len, int depth,
                     Deque<Integer> path, Set<Integer> used,
                     List<List<Integer>> res) {
        if (depth == len) {
            res.add(new ArrayList<>(path));
            return;
        }
    
        for (int i = 0; i < len; i++) {
            if (!used.contains(i)) {
                used.add(i);
                path.addLast(nums[i]);
    
                dfs(nums, len, depth + 1, path, used, res);
    
                path.removeLast();
                used.remove(i);
            }
        }
    }

}
参考代码 4：

JavaPython

import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Deque;
import java.util.List;


public class Solution {

    public List<List<Integer>> permute(int[] nums) {
        int len = nums.length;
        List<List<Integer>> res = new ArrayList<>(factorial(len));
        if (len == 0) {
            return res;
        }
    
        int used = 0;
        Deque<Integer> path = new ArrayDeque<>(len);
        dfs(nums, len, 0, path, used, res);
        return res;
    }
    
    private int factorial(int n) {
        int res = 1;
        for (int i = 2; i <= n; i++) {
            res *= i;
        }
        return res;
    }
    
    private void dfs(int[] nums, int len, int depth,
                     Deque<Integer> path, int used,
                     List<List<Integer>> res) {
        if (depth == len) {
            res.add(new ArrayList<>(path));
            return;
        }
    
        for (int i = 0; i < len; i++) {
            if (((used >> i) & 1) == 0) {
                path.addLast(nums[i]);
                used ^= (1 << i);
    
                dfs(nums, len, depth + 1, path, used, res);
                used ^= (1 << i);
                path.removeLast();
            }
        }
    }

}
总结
下面回答在最开始提出的问题，其实我们上面的说明中也已经回答了。

1、为什么使用深度优先遍历？

（1）首先是正确性，只有遍历状态空间，才能得到所有符合条件的解；

（2）在深度优先遍历的时候，不同状态之间的切换很容易，可以再看一下上面有很多箭头的那张图，每两个状态之间的差别只有 1 处，因此回退非常方便，这样全局才能使用一份状态变量完成搜索；

（3）如果使用广度优先遍历，从浅层转到深层，状态的变化就很大，此时我们不得不在每一个状态都新建变量去保存它，从性能来说是不划算的；

（4）如果使用广度优先遍历就得使用队列，然后编写结点类。使用深度优先遍历，我们是直接使用了系统栈，系统栈帮助我们保存了每一个结点的状态信息。于是我们不用编写结点类，不必手动编写栈完成深度优先遍历。大家可以尝试使用广度优先遍历实现一下，就能体会到这一点。

2、不回溯可不可以？

可以。搜索问题的状态空间一般很大，如果每一个状态都去创建新的变量，时间复杂度是 O(N)O(N)。在候选数比较多的时候，在非叶子结点上创建新的状态变量的性能消耗就很严重。

就本题而言，只需要叶子结点的那个状态，在叶子结点执行拷贝，时间复杂度是 O(N)O(N)。路径变量在深度优先遍历的时候，结点之间的转换只需要 O(1)O(1)。

最后，由于回溯算法的时间复杂度很高，因此，如果在遍历的时候，如果能够提前知道这一条分支不能搜索到满意的结果，就可以提前结束，这一步操作称之为剪枝。

回溯算法会大量应用“剪枝”技巧达到以加快搜索速度。有些时候，需要做一些预处理工作（例如排序）才能达到剪枝的目的。预处理工作虽然也消耗时间，但一般而且能够剪枝节约的时间更多。还有正是因为回溯问题本身时间复杂度就很高，所以能用空间换时间就尽量使用空间。否则时间消耗又上去了。

下面提供一些我做过的“回溯”算法的问题，以便大家学习和理解“回溯”算法。

我做题的时候，第 1 步都是先画图，画图是非常重要的，只有画图才能帮助我们想清楚递归结构，想清楚如何剪枝。就拿题目中的示例，想一想人手动操作是怎么做的，一般这样下来，这棵递归树都不难画出。

即在画图的过程中思考清楚：

1、分支如何产生；

2、题目需要的解在哪里？是在叶子结点、还是在非叶子结点、还是在从跟结点到叶子结点的路径？

3、哪些搜索是会产生不需要的解的？例如：产生重复是什么原因，如果在浅层就知道这个分支不能产生需要的结果，应该提前剪枝，剪枝的条件是什么，代码怎么写？

![image.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/6a464ba95a7ad1c247aa39610535984c241e6b95148f8bc36b02908a190b1d54-image.png)



题目	提示

47. 全排列 II	思考一下，为什么造成了重复，如何在搜索之前就判断这一支会产生重复，从而“剪枝”。
    17 .电话号码的字母组合	
48. 括号生成	这是字符串问题，没有显式回溯的过程。这道题广度优先遍历也很好写，可以通过这个问题理解一下为什么回溯算法都是深度优先遍历，并且都用递归来写。
49. 组合总和	使用题目给的示例，画图分析。
50. 组合总和 II	
51. N皇后	其实就是全排列问题，注意设计清楚状态变量。
52. 第k个排列	利用了剪枝的思想，减去了大量枝叶，直接来到需要的叶子结点。
53. 组合	组合问题按顺序找，就不会重复。并且举一个中等规模的例子，找到如何剪枝，这道题思想不难，难在编码。
54. 子集	为数不多的，解不在叶子结点上的回溯搜索问题。解法比较多，注意对比。
55. 子集 II	剪枝技巧同 47 题、39 题、40 题。
56. 复原IP地址	
57. 字母大小写全排列	



作者：liweiwei1419
链接：https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 1.骑士回溯问题

深度优先算法

![image-20200514222601917](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200514222601917.png)

![image-20200515090843924](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200515090843924.png)



定义布尔变量一定要在前面加个is，否则工作会被鄙视

finished的作用是在找到解时结束递归



**深度用递归，广度用队列**

### 2.[括号生成](https://leetcode-cn.com/problems/generate-parentheses/)

1.暴力破解

![image-20200803153424047](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803153424047.png)

![image-20200803153442470](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803153442470.png)

2.回溯法

![image-20200803155028493](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200803155028493.png)





```java
class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> ans = new ArrayList();
        backtrack(ans, new StringBuilder(), 0, 0, n);
        return ans;
    }

    public void backtrack(List<String> ans, StringBuilder cur, int open, int close, int max){
        if (cur.length() == max * 2) {
            ans.add(cur.toString());
            return;
        }

        if (open < max) {
            cur.append('(');
            backtrack(ans, cur, open+1, close, max);
            cur.deleteCharAt(cur.length() - 1);
        }
        if (close < open) {
            cur.append(')');
            backtrack(ans, cur, open, close+1, max);
            cur.deleteCharAt(cur.length() - 1);
        }
    }
}

作者：LeetCode-Solution
链接：https://leetcode-cn.com/problems/generate-parentheses/solution/gua-hao-sheng-cheng-by-leetcode-solution/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

难度中等831

思路：根据示例 1：输入: candidates = [2,3,6,7]，target = 7。

候选数组里有 2 ，如果找到了 7 - 2 = 5 的所有组合，再在之前加上 2 ，就是 7 的所有组合；
同理考虑 3，如果找到了 7 - 3 = 4 的所有组合，再在之前加上 3 ，就是 7 的所有组合，依次这样找下去；
上面的思路就可以画成下面的树形图。

![39-1.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/fe32ae9cee9ec8e2545d038d80a8da70d809eed01c153c6f0076801baab5010d-39-1.png)

说明：

蓝色结点表示：尝试找到组合之和为该数的所有组合，怎么找呢？逐个减掉候选数组中的元素即可；
以 target = 7 为根结点，每一个分支做减法；
减到 00 或者负数的时候，到了叶子结点；
减到 00 的时候结算，这里 “结算” 的意思是添加到结果集；
从根结点到叶子结点（必须为 0）的路径，就是题目要我们找的一个组合。
把文字的部分去掉。

![39-3.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/ade93b4f0678b2b1385ad1362ff426ce0a5a800a5b0ae07dfb65f58677374559-39-3.png)

去重复
在搜索的时候，需要设置搜索起点的下标 begin ，由于一个数可以使用多次，下一层的结点从这个搜索起点开始搜索；
在搜索起点 begin 之前的数因为以前的分支搜索过了，所以一定会产生重复。
剪枝提速
如果一个数位搜索起点都不能搜索到结果，那么比它还大的数肯定搜索不到结果，基于这个想法，我们可以对输入数组进行排序，以减少搜索的分支；

排序是为了提高搜索速度，非必要；

搜索问题一般复杂度较高，能剪枝就尽量需要剪枝。把候选数组排个序，遇到一个较大的数，如果以这个数为起点都搜索不到结果，后面的数就更搜索不到结果了。

![image.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/deb490e7454ecf7954c494e6b53ce6c76b6065bd49639692886b5aec8d9a0f23-image.png)

```java 
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Deque;
import java.util.List;

public class Solution {

    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> res = new ArrayList<>();
        int len = candidates.length;

        // 排序是为了提前终止搜索，把候选数组排个序，遇到一个较大的数，如果以这个数为起点都搜索不到结果，后面的数就更搜索不到结果了。
        Arrays.sort(candidates);

        dfs(candidates, len, target, 0, new ArrayDeque<>(), res);
        return res;
    }

    /**
     * @param candidates 数组输入
     * @param len        输入数组的长度，冗余变量
     * @param residue    剩余数值
     * @param begin      本轮搜索的起点下标
     * @param path       从根结点到任意结点的路径
     * @param res        结果集变量
     */
    private void dfs(int[] candidates,
                     int len,
                     int residue,
                     int begin,
                     Deque<Integer> path,
                     List<List<Integer>> res) {
        if (residue == 0) {
            // 由于 path 全局只使用一份，到叶子结点的时候需要做一个拷贝
            res.add(new ArrayList<>(path));
            return;
        }

        for (int i = begin; i < len; i++) {
 //数组是经过排序的，因此，直接不考虑begin位置之前的数字，从begin往后进行递归，这样就不会出现类似[2,3,3] [2,3,2][3,2,2]的重复了，指挥出现[3,2,2]，强制函数只能“往后选择”，这将不会出现重复答案。
            // 在数组有序的前提下，剪枝
            if (residue - candidates[i] < 0) {
                break;
            }

            path.addLast(candidates[i]);
            dfs(candidates, len, residue - candidates[i], i, path, res);
           
            path.removeLast();

        }
    }
}

```

#### [39. 组合总和](https://leetcode-cn.com/problems/combination-sum/)

```
public class 组合综合_39 {
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        List<List<Integer>> ans = new ArrayList<List<Integer>>();
        List<Integer> combine = new ArrayList<Integer>();
        dfs(candidates, target, ans, combine, 0);
        return ans;
    }

    public void dfs(int[] candidates, int target, List<List<Integer>> ans, List<Integer> combine, int idx) {
        if (idx == candidates.length) {
            return;//到最后一个+1的位置，说明前面已经遍历结束，仍然没有凑成，直接返回
        }
        if (target == 0) {//上一步没结束，说明还没遍历结束，这个时候如果 target=0说明凑成了，将结果集加入到ans中
            ans.add(new ArrayList<Integer>(combine));
            return;
        }
        // 不选idx位置的数，往下走
        dfs(candidates, target, ans, combine, idx + 1);
        // 选择当idx位置的数
        if (target - candidates[idx] >= 0) {//满足这个数比剩下的target才能选，大于的话没法选
            combine.add(candidates[idx]);
            dfs(candidates, target - candidates[idx], ans, combine, idx);
            combine.remove(combine.size() - 1);//回溯到上一步，将combine中的加入的这个数删去，加了才删，不加不用删
        }
    }

}
```



### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

![image-20200822102046108](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822102046108.png)

![image-20200822102403252](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822102403252.png)

![image-20200822103401826](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822103401826.png)

![image-20200822103416627](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822103416627.png)

```
  class Solution {
        public List<List<Integer>> permute(int[] nums) {
            int len=nums.length;
            List<List<Integer>> ans=new ArrayList<>();
            if (len<=0) return ans;
            boolean[] used=new boolean[len];
            dfs(ans,nums,  len, 0,new ArrayDeque<>(),used);
            return ans;

        }
        //ans 保存的结果
        //level 第几层 path:保存的路径
//        Len路径的总长度

        public void dfs(List<List<Integer>> ans,int[] nums, int len,int depth, Deque<Integer> path,boolean[] used){

            if (depth==len){
                ans.add(new ArrayList<>(path));
                return;
            }
            for(int i=0;i<len ;i++){
                if (used[i]){
                    continue;
                }
                used[i]= true;
                path.addLast(nums[i]);
                dfs(ans,nums,  len, depth+1,path,used);
                path.removeLast();
                used[i]=false;


            }
        }
    }
```

方法二：动态数组，填入

![image-20200822103823240](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822103823240.png)

![image-20200822103834630](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822103834630.png)

![image-20200822103900285](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822103900285.png)



```java
class Solution {
  public void backtrack(int n,
                        ArrayList<Integer> output,
                        List<List<Integer>> res,
                        int first) {
    // 所有数都填完了
    if (first == n)
      res.add(new ArrayList<Integer>(output));
    for (int i = first; i < n; i++) {
      // 动态维护数组
      Collections.swap(output, first, i);
      // 继续递归填下一个数
      backtrack(n, output, res, first + 1);
      // 撤销操作
      Collections.swap(output, first, i);
    }
  }

  public List<List<Integer>> permute(int[] nums) {
    List<List<Integer>> res = new LinkedList();

    ArrayList<Integer> output = new ArrayList<Integer>();
    for (int num : nums)
      output.add(num);

    int n = nums.length;
    backtrack(n, output, res, 0);
    return res;
  }
}



```



### [78. 子集](https://leetcode-cn.com/problems/subsets/)

#### 方法一：递归

开始假设输出子集为空，每一步都向子集添加新的整数，并生成新的子集。

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/recursion.png)

```
 class Solution2 {
        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> output = new ArrayList();
            output.add(new ArrayList<Integer>());//先加一个空的

            for (int num : nums) {
                List<List<Integer>> newSubsets = new ArrayList();
                //挨个将新的num加到 output，每一个子串的后面，保存到一个新的List<List<Integer>>中，
                // 再将这个新的list元素挨个加入到output中，相当于是按顺序加入output中每个以num[i]结尾的子串
                for (List<Integer> curr : output) {
                    newSubsets.add(new ArrayList<Integer>(curr) {{ //挨个将新的num加到 output，
                        add(num);
                    }});
                }
                for (List<Integer> curr : newSubsets) { // 再将这个新的list元素挨个加入到output中
                    output.add(curr);
                }
            }
            return output;
        }
    }
```

#### 方法二：回溯

算法

幂集是所有长度从 0 到 n 所有子集的组合。

根据定义，该问题可以看作是从序列中生成幂集。

遍历 子集长度，通过 回溯 生成所有给定长度的子集。

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/combinations.png)

[回溯法](https://baike.baidu.com/item/回溯法/86074?fr=aladdin)是一种探索所有潜在可能性找到解决方案的算法。如果当前方案不是正确的解决方案，或者不是最后一个正确的解决方案，则回溯法通过修改上一步的值继续寻找解决方案。

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/backtracking.png)

![image-20200823214218611](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823214218611.png)

```
class Solution {
  List<List<Integer>> output = new ArrayList();
  int n, k;

  public void backtrack(int first, ArrayList<Integer> curr, int[] nums) {
    // if the combination is done
    if (curr.size() == k)
      output.add(new ArrayList(curr));

    for (int i = first; i < n; ++i) {
      // add i into the current combination
      curr.add(nums[i]);
      // use next integers to complete the combination
      backtrack(i + 1, curr, nums);
      // backtrack
      curr.remove(curr.size() - 1);
    }
  }

  public List<List<Integer>> subsets(int[] nums) {
    n = nums.length;
    for (k = 0; k < n + 1; ++k) {
      backtrack(0, new ArrayList<Integer>(), nums);
    }
    return output;
  }
}


```

#### 方法三：字典排序（二进制排序） 子集

![image-20200823220355638](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823220355638.png)

因此要生成所有子集，只需要生成从 0..00 到 1..11 的所有 n 位掩码。

乍看起来生成二进制数很简单，但如何处理左边填充 0 是一个问题。因为必须生成固定长度的位掩码：例如 001，而不是 1。因此可以使用一些位操作技巧：

```java
int nthBit = 1 << n;//1左移n个位置，成为10000..，有n个0
//Math.*pow*(2, 3)); 2的3次方  
for (int i = 0; i < (int)Math.pow(2, n); ++i) {
    // generate bitmask, from 0..00 to 1..11
    // substring (int beginIndex)从beginIndex开始截取字符串到字符串结尾
    //toBinaryString一个二进制字符串.
    String bitmask = Integer.toBinaryString(i | nthBit).substring(1);
```


或者使用简单但低效的迭代进行控制：

```java
for (int i = (int)Math.pow(2, n); i < (int)Math.pow(2, n + 1); ++i) {
  // generate bitmask, from 0..00 to 1..11
  String bitmask = Integer.toBinaryString(i).substring(1);
```

算法

生成所有长度为 n 的二进制位掩码。

将每个子集都映射到一个位掩码数：位掩码中第 i 位如果是 1 表示子集中存在 nums[i]，0 表示子集中不存在 nums[i]。

返回子集列表。




    class Solution {
      public List<List<Integer>> subsets(int[] nums) {
        List<List<Integer>> output = new ArrayList();
        int n = nums.length;
    for (int i = (int)Math.pow(2, n); i < (int)Math.pow(2, n + 1); ++i) {
      // generate bitmask, from 0..00 to 1..11
      String bitmask = Integer.toBinaryString(i).substring(1);
    
      // append subset corresponding to that bitmask
      List<Integer> curr = new ArrayList();
      for (int j = 0; j < n; ++j) {
        if (bitmask.charAt(j) == '1') curr.add(nums[j]);
      }
      output.add(curr);
    }
    return output;
      }
    }


### [79. 单词搜索](https://leetcode-cn.com/problems/word-search/)

单词必须按照字母顺序

同一个单元格内的字母不允许被重复使用。

可以从任意一个位置开始

![image-20200823222713352](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823222713352.png)

![image-20200823222740041](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823222740041.png)

### 





### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)

方法一：深度优先搜索
我们可以将二维网格看成一个无向图，竖直或水平相邻的 11 之间有边相连。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则以其为起始节点开始进行深度优先搜索。在深度优先搜索的过程中，每个搜索到的 11 都会被重新标记为 00。

最终岛屿的数量就是我们进行深度优先搜索的次数。

```
class Solution {
    void dfs(char[][] grid, int r, int c) {
        int nr = grid.length;
        int nc = grid[0].length;

        if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {
            return;
        }

        grid[r][c] = '0';
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int nr = grid.length;
        int nc = grid[0].length;
        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    dfs(grid, r, c);
                }
            }
        }

        return num_islands;
    }
}


```

方法二：广度优先搜索
同样地，我们也可以使用广度优先搜索代替深度优先搜索。

为了求出岛屿的数量，我们可以扫描整个二维网格。如果一个位置为 11，则将其加入队列，开始进行广度优先搜索。在广度优先搜索的过程中，每个搜索到的 11 都会被重新标记为 00。直到队列为空，搜索结束。

最终岛屿的数量就是我们进行广度优先搜索的次数。





```
class Solution {
    void dfs(char[][] grid, int r, int c) {
        int nr = grid.length;
        int nc = grid[0].length;

        if (r < 0 || c < 0 || r >= nr || c >= nc || grid[r][c] == '0') {
            return;
        }

        grid[r][c] = '0';
        dfs(grid, r - 1, c);
        dfs(grid, r + 1, c);
        dfs(grid, r, c - 1);
        dfs(grid, r, c + 1);
    }

    public int numIslands(char[][] grid) {
        if (grid == null || grid.length == 0) {
            return 0;
        }

        int nr = grid.length;
        int nc = grid[0].length;
        int num_islands = 0;
        for (int r = 0; r < nr; ++r) {
            for (int c = 0; c < nc; ++c) {
                if (grid[r][c] == '1') {
                    ++num_islands;
                    dfs(grid, r, c);
                }
            }
        }

        return num_islands;
    }
}

```



## 八、二分查找

只针对有序数列有用

![image-20200515145241782](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200515145241782.png)

![image-20200515145307078](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200515145307078.png)

![image-20200515145641413](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200515145641413.png)



#### [33. 搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)

![image-20200821092838736](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821092838736.png)

```java
class Solution {
    public int search(int[] nums, int target) {
int n = nums.length;
            if (n == 0) return -1;
            if (n == 1) return nums[0] == target ? 0 : -1;

            int l = 0, r = n - 1;
            while (l <= r) {
                int mid = (l + r) / 2;
                if (nums[mid] == target) return mid;
                // 左半边有序
                if (nums[0] <= nums[mid]) {
                    // target的值在左半边
                    if (nums[0] <= target && target < nums[mid]) {
                        r = mid - 1;
                    } else {
                        l = mid + 1;
                    }
                }// 右半边有序
                else {
                    // target的值在右半边
                    if (nums[mid] < target && target <= nums[n - 1]) {
                        l = mid + 1;
                    } else {
                        r = mid - 1;
                    }
                }
            }
            return -1;
    }
}
```

#### [34. 在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/)

```
package com.Leetcode_top100.二分查找;

/**
 * # @author  chilcyWind
 * # @Time   2020/8/21 9:45
 * # @version 1.0
 * # @File : 在排序数组中查找元素的第一个和最后一个位置34.java
 * # @Software: IntelliJ IDEA
 * 　>> :
 * <p>
 * 　　　　负数右移用1补位
 * <p>
 * 　　　　正数右移用0补位
 * <p>
 * 　　>>>:
 * <p>
 * 　　　　无论正负，都用0补位
 */
public class 在排序数组中查找元素的第一个和最后一个位置34 {
    class Solution {
        //这里的二分法，用的全部都是闭区间，搜索的范围为【left，right】，【left，mid】【left，mid】
        // returns leftmost (or rightmost) index at which `target` should be
        // inserted in sorted array `nums` via binary search.
        private int leftBound(int[] nums, int target) {
            int lo = 0;
            int hi = nums.length-1;


            while (lo <= hi) {
                int mid = (lo + hi) / 2;
                if (nums[mid] == target) {
                    hi = mid - 1;
                } else if (nums[mid] > target) {
                    hi = mid - 1;
                } else if (nums[mid] < target) {
                    lo = mid + 1;
                }


            }
            if (lo >= nums.length || nums[lo] != target)
                return -1;
            return lo;
        }
        private int rightBound(int[] nums, int target) {
            int lo = 0;
            int hi = nums.length-1;

            while (lo <= hi) {
                int mid = (lo + hi) / 2;
                if (nums[mid] == target) {
                    lo = mid + 1;
                } else if (nums[mid] > target) {
                    hi = mid - 1;
                } else if (nums[mid] < target) {
                    lo = mid + 1;
                }


            }
            // 最后要检查 right 越界的情况
            if (hi < 0 || nums[hi] != target)
                return -1;
            return hi;
        }
        public int[] searchRange(int[] nums, int target) {
            int[] targetRange = {-1, -1};
            if (nums.length<=1) return targetRange;


            int leftIdx = leftBound(nums, target);
            if(leftIdx==-1) return targetRange;
            targetRange[0] = leftIdx;
            targetRange[1] = rightBound(nums, target) ;

            return targetRange;
        }
    }
}
```

#### 二分查找详解

##### 零、二分查找框架



```
int binarySearch(int[] nums, int target) {
    int left = 0, right = ...;

    while(...) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            ...
        } else if (nums[mid] < target) {
            left = ...
        } else if (nums[mid] > target) {
            right = ...
        }
    }
    return ...;
}
```

**分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节**。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。

其中 `...` 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。

另外声明一下，计算 mid 时需要防止溢出，代码中 `left + (right - left) / 2` 就和 `(left + right) / 2` 的结果相同，但是有效防止了 `left` 和 `right` 太大直接相加导致溢出。

##### 一、寻找一个数（基本的二分搜索）

```
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 注意

    while(left <= right) {
        int mid = left + (right - left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 注意
        else if (nums[mid] > target)
            right = mid - 1; // 注意
    }
    return -1;
}
```

**1、为什么 while 循环的条件中是 <=，而不是 <**？

答：因为初始化 `right` 的赋值是 `nums.length - 1`，即最后一个元素的索引，而不是 `nums.length`。

这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 `[left, right]`，后者相当于左闭右开区间 `[left, right)`，因为索引大小为 `nums.length` 是越界的。

我们这个算法中使用的是前者 `[left, right]` 两端都闭的区间。**这个区间其实就是每次进行搜索的区间**。

什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：



```
    if(nums[mid] == target)
        return mid;
```

但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？**搜索区间为空的时候应该终止**，意味着你没得找了，就等于没找到嘛。

`while(left <= right)` 的终止条件是 `left == right + 1`，写成区间的形式就是 `[right + 1, right]`，或者带个具体的数字进去 `[3, 2]`，可见**这时候区间为空**，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。

`while(left < right)` 的终止条件是 `left == right`，写成区间的形式就是 `[left, right]`，或者带个具体的数字进去 `[2, 2]`，**这时候区间非空**，还有一个数 2，但此时 while 循环终止了。也就是说这区间 `[2, 2]` 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。

当然，如果你非要用 `while(left < right)` 也可以，我们已经知道了出错的原因，就打个补丁好了：



```
    //...
    while(left < right) {
        // ...
    }
    return nums[left] == target ? left : -1;
```

**2、为什么** **`left = mid + 1`****，****`right = mid - 1`****？我看有的代码是** **`right = mid`** **或者** **`left = mid`****，没有这些加加减减，到底怎么回事，怎么判断**？

答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。

刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 `[left, right]`。那么当我们发现索引 `mid` 不是要找的 `target` 时，下一步应该去搜索哪里呢？

当然是去搜索 `[left, mid-1]` 或者 `[mid+1, right]` 对不对？**因为** **`mid`** **已经搜索过，应该从搜索区间中去除**。

**3、此算法有什么缺陷**？

答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。

比如说给你有序数组 `nums = [1,2,2,2,3]`，`target` 为 2，此算法返回的索引是 2，没错。但是如果我想得到 `target` 的左侧边界，即索引 1，或者我想得到 `target` 的右侧边界，即索引 3，这样的话此算法是无法处理的。

这样的需求很常见，**你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了**。

##### 二、寻找左侧边界的二分搜索

以下是最常见的代码形式，其中的标记是需要注意的细节：



```
int left_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0;
    int right = nums.length; // 注意

    while (left < right) { // 注意
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            right = mid;
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid; // 注意
        }
    }
    return left;
}
```

**1、为什么 while 中是** **`<`** **而不是** **`<=`**?

答：用相同的方法分析，因为 `right = nums.length` 而不是 `nums.length - 1`。因此每次循环的「搜索区间」是 `[left, right)` 左闭右开。

`while(left < right)` 终止的条件是 `left == right`，此时搜索区间 `[left, left)` 为空，所以可以正确终止。

PS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：**刚才的** **`right`** **不是** **`nums.length - 1`** **吗，为啥这里非要写成** **`nums.length`** **使得「搜索区间」变成左闭右开呢**？

因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。

**2、为什么没有返回 -1 的操作？如果** **`nums`** **中不存在** **`target`** **这个值，怎么办**？

答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：

![image-20200821102905463](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200821102905463.png)

```
while (left < right) {
    //...
}
// target 比所有数都大
if (left == nums.length) return -1;
// 类似之前算法的处理方式
return nums[left] == target ? left : -1;
```

**3、为什么** **`left = mid + 1`****，****`right = mid`** **？和之前的算法不一样**？

答：这个很好解释，因为我们的「搜索区间」是 `[left, right)` 左闭右开，所以当 `nums[mid]` 被检测之后，下一步的搜索区间应该去掉 `mid` 分割成两个区间，即 `[left, mid)` 或 `[mid + 1, right)`。

**4、为什么该算法能够搜索左侧边界**？

答：关键在于对于 `nums[mid] == target` 这种情况的处理：



```
    if (nums[mid] == target)
        right = mid;
```

可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 `right`，在区间 `[left, mid)` 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。

**5、为什么返回** **`left`** **而不是** **`right`**？

答：都是一样的，因为 while 终止的条件是 `left == right`。

**6、能不能想办法把** **`right`** **变成** **`nums.length - 1`****，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了**。

答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：

因为你非要让搜索区间两端都闭，所以 `right` 应该初始化为 `nums.length - 1`，while 的终止条件应该是 `left == right + 1`，也就是其中应该用 `<=`：

```
int left_bound(int[] nums, int target) {
    // 搜索区间为 [left, right]
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        // if else ...
    }
```

因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 `left` 和 `right` 的更新逻辑如下：

```
if (nums[mid] < target) {
    // 搜索区间变为 [mid+1, right]
    left = mid + 1;
} else if (nums[mid] > target) {
    // 搜索区间变为 [left, mid-1]
    right = mid - 1;
} else if (nums[mid] == target) {
    // 收缩右侧边界
    right = mid - 1;
}
```

由于 while 的退出条件是 `left == right + 1`，所以当 `target` 比 `nums` 中所有元素都大时，会存在以下情况使得索引越界：

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/6865c24b1317f1f65f02348fe622c829c71219c1.jpg)

因此，最后返回结果的代码应该检查越界情况：



```
if (left >= nums.length || nums[left] != target)
    return -1;
return left;
```

至此，整个算法就写完了，完整代码如下：

```
int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    // 搜索区间为 [left, right]
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            // 搜索区间变为 [mid+1, right]
            left = mid + 1;
        } else if (nums[mid] > target) {
            // 搜索区间变为 [left, mid-1]
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 收缩右侧边界
            right = mid - 1;
        }
    }
    // 检查出界情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}
```

这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 `left` 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。

##### 三、寻找右侧边界的二分查找

类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：

```
int right_bound(int[] nums, int target) {
    if (nums.length == 0) return -1;
    int left = 0, right = nums.length;

    while (left < right) {
        int mid = (left + right) / 2;
        if (nums[mid] == target) {
            left = mid + 1; // 注意
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return left - 1; // 注意
}
```

**1、为什么这个算法能够找到右侧边界**？

答：类似地，关键点还是这里：



```
if (nums[mid] == target) {
    left = mid + 1;
```

当 `nums[mid] == target` 时，不要立即返回，而是增大「搜索区间」的下界 `left`，使得区间不断向右收缩，达到锁定右侧边界的目的。

**2、为什么最后返回** **`left - 1`** **而不像左侧边界的函数，返回** **`left`****？而且我觉得这里既然是搜索右侧边界，应该返回** **`right`** **才对**。

答：首先，while 循环的终止条件是 `left == right`，所以 `left` 和 `right` 是一样的，你非要体现右侧的特点，返回 `right - 1` 好了。

至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：



```
if (nums[mid] == target) {
    left = mid + 1;
    // 这样想: mid = left - 1
```

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/a360ba87672e68434224884dfc1393a6039f8130.jpg)

因为我们对 `left` 的更新必须是 `left = mid + 1`，就是说 while 循环结束时，`nums[left]` 一定不等于 `target` 了，而 `nums[left-1]` 可能是 `target`。

至于为什么 `left` 的更新必须是 `left = mid + 1`，同左侧边界搜索，就不再赘述。

**3、为什么没有返回 -1 的操作？如果** **`nums`** **中不存在** **`target`** **这个值，怎么办**？

答：类似之前的左侧边界搜索，因为 while 的终止条件是 `left == right`，就是说 `left` 的取值范围是 `[0, nums.length]`，所以可以添加两行代码，正确地返回 -1：



```
while (left < right) {
    // ...
}
if (left == 0) return -1;
return nums[left-1] == target ? (left-1) : -1;
```

**4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了**。

答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：

```
int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 这里改成收缩左侧边界即可
            left = mid + 1;
        }
    }
    // 这里改为检查 right 越界的情况，见下图
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```



当 `target` 比所有元素都小时，`right` 会被减到 -1，所以需要在最后防止越界：

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/35e46116bf1634c51c039873136c5478600ef028.jpg)

至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？

##### 四、逻辑统一

来梳理一下这些细节差异的因果逻辑：

**第一个，最基本的二分查找算法**：



```
因为我们初始化 right = nums.length - 1所以决定了我们的「搜索区间」是 [left, right]所以决定了 while (left <= right)同时也决定了 left = mid+1 和 right = mid-1
因为我们只需找到一个 target 的索引即可所以当 nums[mid] == target 时可以立即返回
```

**第二个，寻找左侧边界的二分查找**：



```
因为我们初始化 right = nums.length所以决定了我们的「搜索区间」是 [left, right)所以决定了 while (left < right)同时也决定了 left = mid + 1 和 right = mid
因为我们需找到 target 的最左侧索引所以当 nums[mid] == target 时不要立即返回而要收紧右侧边界以锁定左侧边界
```

**第三个，寻找右侧边界的二分查找**：



```
因为我们初始化 right = nums.length
所以决定了我们的「搜索区间」是 [left, right)
所以决定了 while (left < right)
同时也决定了 left = mid + 1 和 right = mid
因为我们需找到 target 的最右侧索引
所以当 nums[mid] == target 时不要立即返回而要收紧左侧边界以锁定右侧边界
又因为收紧左侧边界时必须 left = mid + 1
所以最后无论返回 left 还是 right，必须减一
```

对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，**我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法**：

```java
int binary_search(int[] nums, int target) {
    int left = 0, right = nums.length - 1; 
    while(left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1; 
        } else if(nums[mid] == target) {
            // 直接返回
            return mid;
        }
    }
    // 直接返回
    return -1;
}

int left_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定左侧边界
            right = mid - 1;
        }
    }
    // 最后要检查 left 越界的情况
    if (left >= nums.length || nums[left] != target)
        return -1;
    return left;
}


int right_bound(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else if (nums[mid] == target) {
            // 别返回，锁定右侧边界
            left = mid + 1;
        }
    }
    // 最后要检查 right 越界的情况
    if (right < 0 || nums[right] != target)
        return -1;
    return right;
}
```





## 九、图

### 1.深度优先遍历DFS

![image-20200515135645048](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200515135645048.png)



![image-20200515135724790](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200515135724790.png)



这里难道不是B走完了才又回溯到A继续走吗？这样完全能把整张图给走完而不需要后面的重载

重载是考虑了不连通图，例如a-b-c连通，d-e连通，但是abcde整体并不连通，只用上边的方法并不能完整遍历，需要用到下边的重载方法！

### 2.广度优先搜索BFS

![image-20200515141205399](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200515141205399.png)





### [图的表示](https://www.cnblogs.com/liushang0419/archive/2011/05/06/2039386.html)

（i）邻接矩阵表示法，如图：

 ![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/2011050620274397.png)![img](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/2011050620285367.png)

　　也就是说，如果两节点之间有一条弧，则邻接矩阵中对应的元素为1；否则为0。可以看出，这种表示法非常简单、直接。但是，在邻接矩阵的所有 个元素中，只有 个为非零元。如果网络比较稀疏，这种表示法浪费大量的存储空间，从而增加了在网络中查找弧的时间。

　　同样，对于网络中的权，也可以用类似邻接矩阵的 矩阵表示。只是此时一条弧所对应的元素不再是1，而是相应的权而已。如果网络中每条弧赋有多种权，则可以用多个矩阵表示这些权。

（ii）关联矩阵表示法

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/2011050620274397.png)![img](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/2011050620305033.png)

　　也就是说，在关联矩阵中，每行对应于图的一个节点，每列对应于图的一条弧。如果一个节点是一条弧的起点，则关联矩阵中对应的元素为1；如果一个节点是一条弧的终点，则关联矩阵中对应的元素为 -1；如果一个节点与一条弧不关联，则关联矩阵中对应的元素为0。对于简单图，关联矩阵每列只含有两个非零元（一个 1，一个-1）可以看出，这种表示法也非常简单、直接。但是，在关联矩阵的所有mn 个元素中，只有 2m个为非零元。如果网络比较稀疏，这种表示法也会浪费大量的存储空间。但由于关联矩阵有许多特别重要的理论性质，因此它在网络优化中是非常重要的概念。

　　同样，对于网络中的权，也可以通过对关联矩阵的扩展来表示。例如，如果网络中每条弧有一个权，我们可以把关联矩阵增加一行，把每一条弧所对应的权存储在增加的行中。如果网络中每条弧赋有多个权，我们可以把关联矩阵增加相应的行数，把每一条弧所对应的权存储在增加的行中。

（iii）弧表示法

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/2011050620274397.png)

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/2011050620342548.png)

例如，例7所示的图，假设弧(1,2)，(1,3)，(2,4)，(3,2)，(4,3)，(4,5)，(5,3)和(5,4)上的权分别为8，9，6，4，0，3，6和7，则弧表表示如上：

为了便于检索，一般按照起点、终点的字典序顺序存储弧表，如上面的弧表就是按照这样的顺序存储的。

（iv）邻接表表示法

　　邻接表表示法将图以邻接表（adjacency lists）的形式存储在计算机中。所谓图的邻接表，也就是图的所有节点的邻接表的集合；而对每个节点，它的邻接表就是它的所有出弧。邻接表表示法就是对图的每个节点，用一个单向链表列出从该节点出发的所有弧，链表中每个单元对应于一条出弧。为了记录弧上的权，链表中每个单元除列出弧的另一个端点外，还可以包含弧上的权等作为数据域。图的整个邻接表可以用一个指针数组表示。例如，例7所示的图，邻接表表示为

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/2011050620274397.png)![img](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/2011050620362625.png)

（v）星形表示法

星形（star）表示法的思想与邻接表表示法的思想有一定的相似之处。对每个节点，它也是记录从该节点出发的所有弧，但它不是采用单向链表而是采用一个单一的数组表示。也就是说，在该数组中首先存放从节点1出发的所有弧，然后接着存放从节点2出发的所有孤，依此类推，最后存放从节点 出发的所有孤。对每条弧，要依次存放其起点、终点、权的数值等有关信息。这实际上相当于对所有弧给出了一个顺序和编号，只是从同一节点出发的弧的顺序可以任意排列。此外，为了能够快速检索从每个节点出发的所有弧，我们一般还用一个数组记录每个节点出发的弧的起始地址（即弧的编号）。在这种表示法中，可以快速检索从每个节点出发的所有弧，这种星形表示法称为前向星形（forward star）表示法。

例如，在例7所示的图中，仍然假设弧（1,2），（l,3），（2,4），（3,2），（4,3），（4,5），（5,3）和（5,4）上的权分别为8，9，6，4，0，3，6和7。此时该网络图可以用前向星形表示法表示如下：

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/2011050620394337.png)

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/2011050620274397.png)

《星形表示法详解及其转化算法》

注意：上面的第一张表实际上有个错误，仔细看的童鞋应该能发现，起始地址point(i) : 1 , 3 , 4 , 5 , 7 , 9 ,那个6应该是5

通常情况下会设置一个st[i] 数组，和STL类似， [st[i],st[i+1]) 恰好为以结点i开头的边下标。对应于上个例子的第一张表，则该数组为：

st[6]={1,3,4,5,7,9};

还会有一个数组对应于第二张表，主要使用第三行数据，

v[8]={2,3,4,2,3,5,3,4};

下面的程序把树的前向星表示转化成左儿子-右兄弟表示，以方便后续算法实现。

注意：上面的第一张表实际上有个错误，仔细看的童鞋应该能发现，起始地址point(i) : 1 , 3 , 4 , 5 , 7 , 9 ,那个6应该是5

通常情况下会设置一个st[i] 数组，和STL类似， [st[i],st[i+1]) 恰好为以结点i开头的边下标。对应于上个例子的第一张表，则该数组为：

st[6]={1,3,4,5,7,9};

还会有一个数组对应于第二张表，主要使用第三行数据，

v[8]={2,3,4,2,3,5,3,4};

下面的程序把树的前向星表示转化成左儿子-右兄弟表示，以方便后续算法实现。

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

```
 1 void star2lsrs ()
 2 {
 3     memset (son , 0 , sizeof (son )); /*清零， 为零代表链表为空son */
 4     for(i = 1; i <= n; i ++)
 5     /*按逆序考虑各个结点，则最后的链表是顺序的*/
 6     for(j = st[i +1] -1; j >= st[i ]; j --)
 7         {
 8             bro[j ] = son[i];
 9             son[i ] = v[j ]; /*插到链表首部*/
10         }
11 }
```

[![复制代码](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/copycode.gif)](javascript:void(0);)

图最常用的表示法是邻接矩阵和邻接表。对于静态图（建图完毕后不再修改图的结构）往往用前向星来代替邻接表，节省空间和时间。

邻接矩阵不管输入格式如何，总是很容易得到邻接矩阵，只需要注意平行边的情况。
前向星邻接矩阵本身就包含了顶点序，因此很容易转化为前向星：

把邻接矩阵转换为前向星表示法：



```
 1 void matrix2star ()
 2 {
 3     /*上一条的第一端点初始化为（表示未出现），边数初始化为u0m0 */
 4     u = m = 0;
 5     for(i = 1; i <= n; i ++)
 6     for(j = 1; j <= n; j ++)
 7         {
 8             if(a[i][j])
 9             {
10                 v[++m ] = j;
11                 while (u < i)
12                 st [++u ] = m;
13             }
14         }
15 }
16  /*
17 在程序中，u代表上一条边的第一个顶点编号，当u < i时代表这条边的第一端点还
18 没有出现过，设置st[u + 1] : : : st[i]为m。
19  */
```



把边列表转化成前向星的方法类似，只需要把第一顶点相同的结点串成链表，用计数器法进行结点编号分配，和前向星转化成左儿子-右兄弟一样每次插入到链表首部，在O(m)时间内可以建立前向星表示。当然，也可以按第一顶点为关键字直接进行快速排序，不过速度稍微慢一些

### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

### 拓扑排序

https://blog.csdn.net/qq_41713256/article/details/80805338

对一个[有向无环图](https://baike.baidu.com/item/有向无环图/10972513)(Directed Acyclic Graph简称DAG)G进行拓扑排序，是将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u,v>∈E(G)，则u在线性序列中出现在v之前。通常，这样的线性序列称为满足拓扑次序(Topological Order)的序列，简称拓扑序列。简单的说，由某个集合上的一个[偏序](https://baike.baidu.com/item/偏序/2439087)得到该集合上的一个[全序](https://baike.baidu.com/item/全序/10577699)，这个操作称之为拓扑排序。 [1]

## 十、二分查找

#### [287. 寻找重复数](https://leetcode-cn.com/problems/find-the-duplicate-number/)

https://leetcode-cn.com/problems/find-the-duplicate-number/solution/er-fen-fa-si-lu-ji-dai-ma-python-by-liweiwei1419/





## 十一、二叉树的遍历

二叉搜索树的中序遍历是一个递增的序列，这个可以用来判断一个树是不是二叉搜索树



一、前序遍历

　　访问顺序：先根节点，再左子树，最后右子树；上图的访问结果为：GDAFEMHZ。

　　1）递归实现

```
    public void preOrderTraverse1(TreeNode root) {
        if (root != null) {
            System.out.print(root.val + "->");
            preOrderTraverse1(root.left);
            preOrderTraverse1(root.right);
        }
    }
```

　　2）非递归实现

```
    public void preOrderTraverse2(TreeNode root) {
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;
        while (node != null || !stack.empty()) {
            if (node != null) {
                System.out.print(node.val + "->");
                stack.push(node);
                node = node.left;
            } else {
                TreeNode tem = stack.pop();
                node = tem.right;
            }
        }
    }
```



二、中序遍历

　　访问顺序：先左子树，再根节点，最后右子树；上图的访问结果为：ADEFGHMZ。

　　1）递归实现

```
    public void inOrderTraverse(TreeNode root) {
        if (root != null) {
            inOrderTraverse(root.left);
            System.out.print(root.val + "->");
            inOrderTraverse(root.right);
        }
    }
```

　　2）非递归实现

```
        public List < Integer > inorderTraversal(TreeNode root) {
            List < Integer > res = new ArrayList < > ();
            Stack < TreeNode > stack = new Stack < > ();
            TreeNode curr = root;
            while (curr != null || !stack.isEmpty()) {
                while (curr != null) {
                    stack.push(curr);
                    curr = curr.left;
                }
                curr = stack.pop();
                res.add(curr.val);
                curr = curr.right;
            }
            return res;
        }
    }
```



三、后序遍历

　　访问顺序：先左子树，再右子树，最后根节点，上图的访问结果为：AEFDHZMG。

　　1）递归实现

```
    public void postOrderTraverse(TreeNode root) {
        if (root != null) {
            postOrderTraverse(root.left);
            postOrderTraverse(root.right);
            System.out.print(root.val + "->");
        }
    }
```

 　2）非递归实现

```
    public void postOrderTraverse(TreeNode root) {
        TreeNode cur, pre = null;

        Stack<TreeNode> stack = new Stack<>();
        stack.push(root);

        while (!stack.empty()) {
            cur = stack.peek();
            if ((cur.left == null && cur.right == null) || (pre != null && (pre == cur.left || pre == cur.right))) {
                System.out.print(cur.val + "->");
                stack.pop();
                pre = cur;
            } else {
                if (cur.right != null)
                    stack.push(cur.right);
                if (cur.left != null)
                    stack.push(cur.left);
            }
        }
    }
```



 四、层次遍历

　　访问结果：GDMAFHZE。



```
    public void levelOrderTraverse(TreeNode root) {
        if (root == null) {
            return;
        }
        Queue<TreeNode> queue = new LinkedList<TreeNode>();
        queue.add(root);

        while (!queue.isEmpty()) {
            TreeNode node = queue.poll();
            System.out.print(node.val + "->");

            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
    }
```

#### 1.递归遍历：

![image-20200526111233605](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200526111233605.png)

#### 2.非递归遍历

借助一个栈 stack

https://www.bilibili.com/video/BV1oV411d7U5?from=search&seid=442638324986400538

前序遍历：

![image-20200526111435341](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200526111435341.png)

中序遍历：

先找到最左边的节点，然后一路一直放入stack中，然后找到最左边的节点以后，将这个节点当成根节点，即它只有或则没有右子树，访问他，然后将右子树放入栈中，然后再pop出来这个节点的根节点，然后再将右节点放入栈中，开始第二次循环，将右节点当成跟节点继续循环。

![image-20200526111941078](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200526111941078.png)

https://blog.csdn.net/z_ryan/article/details/80854233

后序遍历：

#### 3.相关算法题

##### 3.1深度优先搜索

###### [543. 二叉树的直径](https://leetcode-cn.com/problems/diameter-of-binary-tree/)

深度优先搜索

![image-20200814112837329](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814112837329.png)

![image-20200814112935600](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814112935600.png)

![image-20200814113114059](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814113114059.png)

![image-20200814113135360](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814113135360.png)

#### 3.2反序中序遍历 

这个算法的基本思想是遍历一个没有遍历过的节点之前，先将大于点值的点都遍历一遍。

在递归方法中，我们维护一些递归调用过程中可以访问和修改的全局变量。首先我们判断当前访问的节点是否存在，如果存在就递归右子树，递归回来的时候更新总和和当前点的值，然后递归左子树。如果我们分别正确地递归 root.right 和 root.left ，那么我们就能正确地用大于某个节点的值去更新此节点，然后才遍历比它小的值。





    class Solution {
        private int sum = 0;
    public TreeNode convertBST(TreeNode root) {
        if (root != null) {
            convertBST(root.right);
            sum += root.val;
            root.val = sum;
            convertBST(root.left);
        }
        return root;
    }
    }


初始化一个空的栈并把根节点作为当前节点。然后只要在栈中有未遍历节点或者 node 节点不为空，我们就将当前节点到最右边叶子路径上的点全部压入栈中。这与递归过程中我们总是先走右子树的思路是一致的，这个思路确保我们总是降序遍历所有节点的值。接下来，我们访问栈顶节点，并考虑它的左子树，这就像我们递归中先遍历当前节点再遍历它的左子树的思路。最后，我们的栈为空并且 node 指向树中最小节点的左孩子 null ，循环结束。

```
class Solution {
    public TreeNode convertBST(TreeNode root) {
        int sum = 0;
        TreeNode node = root;
        Stack<TreeNode> stack = new Stack<TreeNode>();

        while (!stack.isEmpty() || node != null) {
            /* push all nodes up to (and including) this subtree's maximum on
             * the stack. */
            while (node != null) {
                stack.add(node);
                node = node.right;
            }

            node = stack.pop();
            sum += node.val;
            node.val = sum;

            /* all nodes with values between the current and its parent lie in
             * the left subtree. */
            node = node.left;
        }

        return root;
    }
}


```



####  莫里斯中序遍历

[https://leetcode-cn.com/problems/binary-tree-inorder-traversal/solution/er-cha-shu-de-zhong-xu-bian-li-by-leetcode/]

```java
// 莫里斯中序遍历
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> ldr = new ArrayList<Integer>();
        TreeNode cur = root;
        TreeNode pre = null;
        while(cur!=null){
            if(cur.left==null){//左子树为空，输出当前节点，将其右孩子作为当前节点
                ldr.add(cur.val);
                cur = cur.right;
            }
            else{
                pre = cur.left;//左子树
                while(pre.right!=null&&pre.right!=cur){//找到前驱节点，即左子树中的最右节点
                    pre = pre.right;
                }
            //如果前驱节点的右孩子为空，将它的右孩子设置为当前节点。当前节点更新为当前节点的左孩子。
                if(pre.right==null){
                    pre.right = cur;
                    cur = cur.left;
                }
            //如果前驱节点的右孩子为当前节点，将它的右孩子重新设为空（恢复树的形状）。输出当前节点。当前节点更新为当前节点的右孩子。
                if(pre.right==cur){
                    pre.right = null;
                    ldr.add(cur.val);
                    cur = cur.right;
                }
            }
        }
        return ldr;
    }
}
```

### 98. [验证二叉搜索树](https://leetcode-cn.com/problems/validate-binary-search-tree/)

![image-20200824150946307](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824150946307.png)

方法一、bfs:广度优先搜索

![image-20200824152654879](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824152654879.png)

![image-20200824151839356](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824151839356.png)

方法三：迭代

相当于层次遍历

![image-20200824154235971](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824154235971.png)

![image-20200824154349261](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824154349261.png)

![image-20200824154405291](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824154405291.png)

方法三：中序遍历
思路和算法

基于方法一中提及的性质，我们可以进一步知道二叉搜索树「中序遍历」得到的值构成的序列一定是升序的，这启示我们在中序遍历的时候实时检查当前节点的值是否大于前一个中序遍历到的节点的值即可。如果均大于说明这个序列是升序的，整棵树是二叉搜索树，否则不是，下面的代码我们使用栈来模拟中序遍历的过程。

可能由读者不知道中序遍历是什么，我们这里简单提及一下，中序遍历是二叉树的一种遍历方式，它先遍历左子树，再遍历根节点，最后遍历右子树。而我们二叉搜索树保证了左子树的节点的值均小于根节点的值，根节点的值均小于右子树的值，因此中序遍历以后得到的序列一定是升序序列。

```
  class Solution3 {
//        二叉搜索树的中序遍历是一个递增的序列，这个可以用来判断一个树是不是二叉搜索树
        public boolean isValidBST(TreeNode root) {
            Stack<TreeNode> stack = new Stack();
            double inorder = - Double.MAX_VALUE;

            while (!stack.isEmpty() || root != null) {
                while (root != null) {
                    stack.push(root);
                    root = root.left;
                }
                root = stack.pop();
                // 如果中序遍历得到的节点的值小于等于前一个 inorder，说明不是二叉搜索树
                if (root.val <= inorder) return false;
                inorder = root.val;
                root = root.right;
            }
            return true;
        }
    }
```



### [101. 对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/)

#### 方法一：递归

**思路和算法**

如果同时满足下面的条件，两个树互为镜像：

- 它们的两个根结点具有相同的值
- 每个树的右子树都与另一个树的左子树镜像对称

我们可以实现这样一个递归函数，通过「同步移动」两个指针的方法来遍历这棵树，pp 指针和 qq 指针一开始都指向这棵树的根，随后 pp 右移时，qq 左移，pp 左移时，qq 右移。每次检查当前 pp 和 qq 节点的值是否相等，如果相等再判断左右子树是否对称。

```java 
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root, root);
    }

    public boolean check(TreeNode p, TreeNode q) {
        if (p == null && q == null) {
            return true;
        }
        if (p == null || q == null) {
            return false;
        }
        return p.val == q.val && check(p.left, q.right) && check(p.right, q.left);
    }
}

```

#### 方法二：迭代

思路和算法

「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），然后将两个结点的左右子结点按相反的顺序插入队列中。当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。

```
    class Solution2 {
//        「方法一」中我们用递归的方法实现了对称性的判断，那么如何用迭代的方法实现呢？首先我们引入一个队列，
//        这是把递归程序改写成迭代程序的常用方法。初始化时我们把根节点入队两次。
//        每次提取两个结点并比较它们的值（队列中每两个连续的结点应该是相等的，而且它们的子树互为镜像），
//        然后将两个结点的左右子结点按相反的顺序插入队列中。
//        当队列为空时，或者我们检测到树不对称（即从队列中取出两个不相等的连续结点）时，该算法结束。


        public boolean isSymmetric(TreeNode root) {
            return check(root, root);
        }

        public boolean check(TreeNode u, TreeNode v) {
            Queue<TreeNode> q = new LinkedList<TreeNode>();

            q.offer(u);
            q.offer(v);
            while (!q.isEmpty()) {
                u = q.poll();
                v = q.poll();
                if (u == null && v == null) {
                    continue;
                }
                if ((u == null || v == null) || (u.val != v.val)) {
                    return false;
                }

                q.offer(u.left);
                q.offer(v.right);

                q.offer(u.right);
                q.offer(v.left);
            }
            return true;
        }
    }
```



### [102. 二叉树的层序遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal/)

#### 方法一：迭代

![image-20200824170507774](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824170507774.png)

![image-20200824170802994](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824170802994.png)

![image-20200824170703927](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824170703927.png)



```
public List<List<Integer>> levelOrder(TreeNode root) {
        //按层遍历即可
        //1.
        List<List<Integer>> lists = new ArrayList<>();
        if (root == null) {
            return lists;
        }
        //2.
        List<TreeNode> nodes = new ArrayList<>();
        nodes.add(root);
        while (!nodes.isEmpty()) {
            int size = nodes.size();
            List<Integer> list = new ArrayList<>();
            for (int i = 0; i < size; i++) {
                TreeNode remove = nodes.remove(0);
                list.add(remove.val);
                if (remove.left != null) {
                    nodes.add(remove.left);
                }
                if (remove.right != null) {
                    nodes.add(remove.right);
                }
            }
            lists.add(list);
        }
        return lists;
    }
```



```
层次遍历Java解法（附注解

public List<List<Integer>> levelOrder(TreeNode root) {

        List<List<Integer>> ans = new ArrayList<>();
        // 层次数组
        List<Integer> level = new ArrayList<>();
        // 辅助遍历的队列
        LinkedList<TreeNode> help = new LinkedList<>();
        // 分节符，用于区分层次结构
        TreeNode dummyNode = new TreeNode(Integer.MIN_VALUE);
        help.addLast(root);
        // 如果为空则直接返回
        if (root == null){
            return ans;
        }
        // 根节点直接推入分界符
        help.addLast(dummyNode);
        // 当辅助队列不为空
        while (help.size()>0){
            // 从队列中取出头节点
             TreeNode node = help.getFirst();
             help.removeFirst();
            // 如果当前节点是分界符
             if (node == dummyNode){
                 // 说明这一层遍历完毕，将数组加入结果
                 ans.add(level);
                 // 创建新数组
                 level = new ArrayList<>();
                 // 此时下一层所有节点应该都进入了队列
                 // 当队列非空插入分界符
                 if (!help.isEmpty()){
                     help.addLast(dummyNode);
                 }
             }else {
                 // 未到分界符就不断加入数
                 level.add(node.val);
                 // 节点左右不为空则入队
                 if (node.left!=null){
                     help.addLast(node.left);
                 }
                 if (node.right!=null){
                     help.addLast(node.right);
                 }
             }

        }
        return ans;
    }
```

我自己想的双队列

```
  class Solution {
        //广度优先搜索
        public List<List<Integer>> levelOrder(TreeNode root) {
            List<List<Integer>> ans = new ArrayList<>();
            Queue<TreeNode> q1 = new LinkedList<>();
            Queue<TreeNode> q2 = new LinkedList<>();
            if (root == null) return ans;
            q1.offer(root);
            while (!q1.isEmpty() || !q2.isEmpty()) {

                if (q1.isEmpty()) {


                    List<Integer> list = new ArrayList<>();
                    while (!q2.isEmpty()) {
                        TreeNode cur = q2.poll();
                        list.add(cur.val);
                        if (cur.left != null)
                            q1.offer(cur.left);
                        if (cur.right != null) {
                            q1.offer(cur.right);
                        }
                    }
                    ans.add(list);
                } else {
                    Queue<TreeNode> tem = q2;
                    q2 = q1;
                    q1 = tem;
                }
            }
            return ans;
        }
    }
```

#### 方法二、递归解法：

![image-20200824164653607](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824164653607.png)

```
 class Solution2 {
        //递归解法
        List<List<Integer>> levels = new ArrayList<>();

        public List<List<Integer>> levelOrder(TreeNode root) {
            if (root == null) return levels;
            helper(root, 0);//root是第0层
            return levels;  
        }

        public void helper(TreeNode node, int level) {
            if (levels.size() == level) {
                levels.add(new ArrayList<Integer>());
                //level从0层开始，如果levels的数量和level相等，说明levels中没有level对应的层
                //例如，根节点是第0层。而levels.size 为0的话，说明它是空的
            }
            levels.get(level).add(node.val);
            if (node.left != null) {
                helper(node.left, level + 1);
            }
            if (node.right != null) {
                helper(node.right, level + 1);
            }
        }

    }
```

### [104. 二叉树的最大深度](https://leetcode-cn.com/problems/maximum-depth-of-binary-tree/)

#### 方法一：递归

思路与算法

如果我们知道了左子树和右子树的最大深度 l 和 r，那么该二叉树的最大深度即为
					max(l,r)+1

而左子树和右子树的最大深度又可以以同样的方式进行计算。因此我们在计算当前二叉树的最大深度时，可以先递归计算出其左子树和右子树的最大深度，然后在 O(1) 时间内计算出当前二叉树的最大深度。递归在访问到空节点时退出。

![image-20200824173803997](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824173803997.png)



### [105. 从前序与中序遍历序列构造二叉树](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

![image-20200824203544471](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824203544471.png)

![image-20200824203721814](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824203721814.png)

![image-20200824204028691](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824204028691.png)

![image-20200824204224238](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200824204224238.png)
![image-20200824204638581](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200824204638581.png)
![image-20200824204747037](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824204747037.png)

```
    class Solution {
        //递归一
        public TreeNode buildTree(int[] preorder, int[] inorder) {
            int preLen = preorder.length;
            int inLen = inorder.length;
            if (preLen != inLen) return null;
            Map<Integer, Integer> map = new HashMap<>();
            for (int i = 0; i < inLen; i++) {
                map.put(inorder[i], i);//快速定位前序排列元素在中序排序中的序号
            }
            return buildTree(preorder, 0, preLen - 1, map, 0, inLen - 1);

        }

        //这里的范围都是闭区间
        private TreeNode buildTree(int[] preorder, int preLeft, int preRight,
                                   Map<Integer, Integer> map, int inLeft, int inRight) {

            if (preLeft > preRight || inLeft > inRight) {
                return null;
            }
            int rootVal = preorder[preLeft];
            TreeNode root = new TreeNode(rootVal);
            int preIndex = map.get(rootVal);//返回根节点在中序遍历的位置
            root.left = buildTree(preorder, preLeft + 1, preIndex - inLeft + preLeft, map, inLeft, preIndex - 1);
            root.right = buildTree(preorder, preIndex - inLeft + preLeft + 1, preRight, map, preIndex + 1, inRight);
            return root;
        }
    }
    /**
     * Definition for a binary tree node.
     * public class TreeNode {
     *     int val;
     *     TreeNode left;
     *     TreeNode right;
     *     TreeNode(int x) { val = x; }
     * }
     */
    class Solution2 {
        //递归2
        private Map<Integer, Integer> indexMap;

        public TreeNode myBuildTree(int[] preorder, int[] inorder, int preorder_left, int preorder_right, int inorder_left, int inorder_right) {
            if (preorder_left > preorder_right) {
                return null;
            }

            // 前序遍历中的第一个节点就是根节点
            int preorder_root = preorder_left;
            // 在中序遍历中定位根节点
            int inorder_root = indexMap.get(preorder[preorder_root]);

            // 先把根节点建立出来
            TreeNode root = new TreeNode(preorder[preorder_root]);
            // 得到左子树中的节点数目
            int size_left_subtree = inorder_root - inorder_left;
            // 递归地构造左子树，并连接到根节点
            // 先序遍历中「从 左边界+1 开始的 size_left_subtree」个元素就对应了中序遍历中「从 左边界 开始到 根节点定位-1」的元素
            root.left = myBuildTree(preorder, inorder, preorder_left + 1, preorder_left + size_left_subtree, inorder_left, inorder_root - 1);
            // 递归地构造右子树，并连接到根节点
            // 先序遍历中「从 左边界+1+左子树节点数目 开始到 右边界」的元素就对应了中序遍历中「从 根节点定位+1 到 右边界」的元素
            root.right = myBuildTree(preorder, inorder, preorder_left + size_left_subtree + 1, preorder_right, inorder_root + 1, inorder_right);
            return root;
        }

        public TreeNode buildTree(int[] preorder, int[] inorder) {
            int n = preorder.length;
            // 构造哈希映射，帮助我们快速定位根节点
            indexMap = new HashMap<Integer, Integer>();
            for (int i = 0; i < n; i++) {
                indexMap.put(inorder[i], i);
            }
            return myBuildTree(preorder, inorder, 0, n - 1, 0, n - 1);
        }
    }


```

#### [解法二、迭代 栈](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solution/xiang-xi-tong-su-de-si-lu-fen-xi-duo-jie-fa-by--22/)

```
public TreeNode buildTree(int[] preorder, int[] inorder) {
    if (preorder.length == 0) {
        return null;
    }
    Stack<TreeNode> roots = new Stack<TreeNode>();
    int pre = 0;
    int in = 0;
    //先序遍历第一个值作为根节点
    TreeNode curRoot = new TreeNode(preorder[pre]);
    TreeNode root = curRoot;
    roots.push(curRoot);
    pre++;
    //遍历前序遍历的数组
    while (pre < preorder.length) {
        //出现了当前节点的值和中序遍历数组的值相等，寻找是谁的右子树
        if (curRoot.val == inorder[in]) {
            //每次进行出栈，实现倒着遍历
            while (!roots.isEmpty() && roots.peek().val == inorder[in]) {
                curRoot = roots.peek();
                roots.pop();
                in++;
            }
            //设为当前的右孩子
            curRoot.right = new TreeNode(preorder[pre]);
            //更新 curRoot
            curRoot = curRoot.right;
            roots.push(curRoot);
            pre++;
        } else {
            //否则的话就一直作为左子树
            curRoot.left = new TreeNode(preorder[pre]);
            curRoot = curRoot.left;
            roots.push(curRoot);
            pre++;
        }
    }
    return root;
}


```

### [124. 二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)

![image-20200824213636504](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824213636504.png)

![image-20200824213806746](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824213806746.png)

![image-20200824213848125](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824213848125.png)

![image-20200824213911106](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824213911106.png)

![image-20200824214129461](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824214129461.png)

![image-20200824214517879](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824214517879.png)

![image-20200824214556289](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824214556289.png)



```java 
 class Solution {
        int maxSum = Integer.MIN_VALUE;//记录最大的路径和

        public int maxPathSum(TreeNode root) {
            maxGain(root);
            return maxSum;
        }

        public int maxGain(TreeNode node) {
            if (node == null) {
                return 0;
            }

            // 递归计算左右子节点的最大贡献值
            // 只有在最大贡献值大于 0 时，才会选取对应子节点
            int leftGain = Math.max(maxGain(node.left), 0);
            int rightGain = Math.max(maxGain(node.right), 0);

            // 节点的最大路径和取决于该节点的值与该节点的左右子节点的最大贡献值
            int priceNewpath = node.val + leftGain + rightGain;//这个值是以该节点+左+右子树构成的路径的最大和，
            // 这样计算完每个节点的这个值，然后就能遍历完所有可能的路径

            // 更新答案
            maxSum = Math.max(maxSum, priceNewpath);//递归的最外层就是包含根节点的路径的priceNewpath。递归会遍历所有可能的子树的路径以及根节点的路径

            // 返回节点的最大贡献值
            return node.val + Math.max(leftGain, rightGain);
            //返回的话，只能返回以该节点为起点，在左或者右子树为选出一条路径与根节点形成一条包含根节点的子树最长路径
        }
    }
```



### [94. 二叉树的中序遍历](https://leetcode-cn.com/problems/binary-tree-inorder-traversal/)

```
class Solution2 {
    //迭代的写法
    public List<Integer> inorderTraversal(TreeNode root) {

        List<Integer> list = new ArrayList<>();
        if (root == null) return list;
        Stack<TreeNode> stack = new Stack<>();
        TreeNode node = root;

        while (!stack.empty() || node != null) {
            if (node != null) {
                stack.push(node);
                node = node.left;
            } else {
                node = stack.pop();
                list.add(node.val);
                node = node.right;
            }
        }
        return list;
    }
```

## 十二、堆、排序

##### 1.计算器中缀表达式运算程序，

使用两个stack来进行运算，一个存储数值，一个存储运算符

######   依次获取字符串的的每一个字符

![image-20200129105446596](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129105446596.png)

###### 字符串数字转化为 int类型的数值：

ASCII值-48就是对应的数值

![image-20200129105857335](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129105857335.png)

![image-20200129110012829](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129110012829.png)

![image-20200129110912432](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129110912432.png)

字符串转化为int类型数值的第二种方法 Inter.parseInt(str)

然后再配合字符串拼接 就可以将程序改为可以输入多位数的运算方法

![image-20200129111528609](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129111528609.png)



##### 2.计算器的前缀表达式

![image-20200129111920123](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129111920123.png)

![image-20200129112213906](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129112213906.png)

![image-20200129112307591](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129112307591.png)

![image-20200129112320006](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129112320006.png)

![image-20200129112522175](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129112522175.png)

将整数转为空串、；

![image-20200129120211146](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129120211146.png)

![image-20200129122609520](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129122609520.png)

读取多位数值

![image-20200129144129407](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129144129407.png)

正则表达式匹配字符串中的字符：

![image-20200129144709361](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129144709361.png)

##### 3.递归

![image-20200129153617517](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129153617517.png)

![image-20200129154053878](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129154053878.png)

![image-20200129162857493](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129162857493.png)

   

递归实现回溯法

![image-20200129164351729](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129164351729.png)

![image-20200129164320489](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129164320489.png)

![image-20200129173130328](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129173130328.png)



八皇后问题：

![image-20200129174223952](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129174223952.png)



![image-20200129175045834](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129175045834.png)

![image-20200129182407595](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200129182407595.png)

![image-20200130092435225](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130092435225.png)

##### 4.排序

![image-20200130093237089](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130093237089.png)

![image-20200130095022302](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130095022302.png)



![image-20200130095213789](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130095213789.png)



![image-20200130095224911](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130095224911.png)



![image-20200130095403048](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130095403048.png)

![image-20200130095530423](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130095530423.png)

###### 4.1 冒泡排序

![image-20200130103625238](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130103625238.png)



![image-20200130103826851](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130103826851.png)



![image-20200130104002277](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130104002277.png)



![image-20200130110821165](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130110821165.png)

###### 4.2选择排序

![image-20200130111019531](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130111019531.png)



![image-20200130111247815](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130111247815.png)



![image-20200130111529123](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130111529123.png)



###### 4.3插入排序

![image-20200130115248606](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130115248606.png)



###### 4.4希尔

![image-20200130115559128](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130115559128.png)

![image-20200130115652384](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130115652384.png)



![image-20200130115835089](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130115835089.png)

![image-20200130115858951](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130115858951.png)

![image-20200130125458423](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130125458423.png)



![image-20200130155805652](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130155805652.png)



array转化为字符串：

![image-20200130152009327](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130152009327.png)



###### 4.5 快排：

![image-20200130161006281](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130161006281.png)

快速排序是由冒泡排序改进而得到的，是一种分区交换排序方法。思想如下： 一趟快速排序采用从两头向中间扫描的方法，同时交换与基准记录逆序的记录。

1. 在待排序的N个记录中任取一个元素(通常取第一个记录)作为基准，称为基准记录；
2. 定义两个索引 left 和 right 分别表示“首索引” 和 “尾索引”，key 表示“基准值”；
3. 首先，尾索引向前扫描，直到找到比基准值小的记录(left != righ)，并替换首索引对应的值；
4. 然后，首索引向后扫描，直到找到比基准值大于的记录(left != righ)，并替换尾索引对应的值；
5. 若在扫描过程中首索引等于尾索引(left = right),则一趟排序结束；将基准值(key)替换首索引所对应的值；
6. 再进行下一趟排序时，待排序列被分成两个区:[0,left-1],[righ+1,end]
7. 对每一个分区重复步骤2~6，直到所有分区中的记录都有序，排序成功。

![快速排序-案例](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/1469176-20190324113315624-765058111.png)



```java
/**
 * 快速排序演示
 * @author Lvan
 */
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {5, 1, 7, 3, 1, 6, 9, 4};

        quickSort(arr, 0, arr.length - 1);

        for (int i : arr) {
            System.out.print(i + "\t");
        }
    }

    /**
     * @param arr        待排序列
     * @param leftIndex  待排序列起始位置
     * @param rightIndex 待排序列结束位置
     */
    private static void quickSort(int[] arr, int leftIndex, int rightIndex) {
        if (leftIndex >= rightIndex) {
            return;
        }

        int left = leftIndex;
        int right = rightIndex;
        //待排序的第一个元素作为基准值
        int key = arr[left];

        //从左右两边交替扫描，直到left = right
        while (left < right) {
            while (right > left && arr[right] >= key) {
                //从右往左扫描，找到第一个比基准值小的元素
                right--;
            }

            //找到这种元素将arr[right]放入arr[left]中
            arr[left] = arr[right];

            while (left < right && arr[left] <= key) {
                //从左往右扫描，找到第一个比基准值大的元素
                left++;
            }

            //找到这种元素将arr[left]放入arr[right]中
            arr[right] = arr[left];
        }
        //基准值归位
        arr[left] = key;
        //对基准值左边的元素进行递归排序
        quickSort(arr, leftIndex, left - 1);
        //对基准值右边的元素进行递归排序。
        quickSort(arr, right + 1, rightIndex);
    }
}
```











###### 4.6归并排序



![image-20200130203624149](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130203624149.png)



![image-20200130210221682](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130210221682.png)



![image-20200130211017716](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130211017716.png)



![image-20200130211316577](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130211316577.png)



![image-20200130211431740](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130211431740.png)

![image-20200130213436768](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130213436768.png)

![image-20200130213931652](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130213931652.png)

###### 4.7基数排序

![image-20200130222318391](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200130222318391.png)

![image-20200131101217545](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131101217545.png)

![image-20200131100749271](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131100749271.png)







![image-20200131095632377](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131095632377.png)

![image-20200131100934922](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131100934922.png)





![image-20200131095834611](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131095834611.png)



![image-20200131101318701](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131101318701.png)

、

##### 5查找

![image-20200131101349665](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131101349665.png)



![image-20200131101431007](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131101431007.png)



![image-20200131102122096](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131102122096.png)

![image-20200131102343170](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131102343170.png)



![image-20200131102430612](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131102430612.png)



![image-20200131102535634](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131102535634.png)



![image-20200131102709361](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131102709361.png)

![image-20200131103127026](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131103127026.png)

![image-20200131103013996](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131103013996.png)

![image-20200131103212078](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131103212078.png)



![image-20200131103447483](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131103447483.png)

5.2插值查算法

![image-20200131103637748](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131103637748.png)



![image-20200131115232807](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131115232807.png)

![image-20200131151449937](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131151449937.png)



![image-20200131151556987](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131151556987.png)



![image-20200131155504091](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131155504091.png)



![image-20200131170645847](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131170645847.png)

![image-20200131171024840](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131171024840.png)



![image-20200131171100822](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131171100822.png)

##### 6哈希 散列表

![image-20200131204919794](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131204919794.png)



![image-20200131211103956](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200131211103956.png)



![image-20200201100809632](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201100809632.png)



![image-20200201101217634](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201101217634.png)

![image-20200201101756033](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201101756033.png)

![image-20200201101949526](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201101949526.png)



![image-20200201102309526](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201102309526.png)

![image-20200201102533323](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201102533323.png)

![image-20200201110045572](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201110045572.png)



![image-20200201104657543](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201104657543.png)

![image-20200201104743129](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201104743129.png)

这个方法将当前运行的Java虚拟结束，非0状态表示非正常退出

说明：

1. System.exit(0)是正常退出程序，会将整个虚拟机里的内容都停掉清空
2. System.exit(1)或者说非0表示非正常退出程序

##### 7.二叉树

![image-20200201151840166](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201151840166.png)



![image-20200201152118893](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201152118893.png)

###### 7.1遍历二叉树

![image-20200201153234481](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201153234481.png)

![image-20200201153733280](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201153733280.png)

```java
public class binaryTreeDemo {
    public static void main(String[] args) {
        BinaryTree binaryTree=new BinaryTree();
        HeroNode root=new HeroNode(1,"li");
        HeroNode root1=new HeroNode(2,"li1");
        HeroNode root2=new HeroNode(3,"li2");
        HeroNode root3=new HeroNode(4,"li3");

        root.setLeft(root1);
        root.setRight(root2);
        root2.setLeft(root3);
        binaryTree.setRoot(root);
        binaryTree.preOrder();


    }
}
class BinaryTree{
    private HeroNode root;

    public void setRoot(HeroNode root) {
        this.root = root;
    }
    public void preOrder(){
        if(this.root!=null){
            this.root.preOrder();
        }else {
            System.out.println("二叉树是空的，无法遍历");
        }
    }
}
class HeroNode {
    private int id;
    private String name;
    private HeroNode left;
    private HeroNode right;

    public HeroNode(int id, String name) {
        this.id = id;
        this.name = name;
    }

    public void preOrder(){
        System.out.println(this);
        if (left!=null){
            left.preOrder();
        }
        if (right!=null){
            right.preOrder();
        }
    }
    public void infixOrder(){
        System.out.println(this);
        if (left!=null){
            left.infixOrder();
        }
        if (right!=null){
            right.infixOrder();
        }
    }

    public void afterOrder(){
        System.out.println(this);
        if (left!=null){
            left.afterOrder();
        }
        if (right!=null){
            right.afterOrder();
        }
    }

    @Override
    public String toString() {
        return "HeroNode{" +
                "id=" + id +
                ", name='" + name + '\'' +
                '}';
    }

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public HeroNode getLeft() {
        return left;
    }

    public void setLeft(HeroNode left) {
        this.left = left;
    }

    public HeroNode getRight() {
        return right;
    }

    public void setRight(HeroNode right) {
        this.right = right;
    }
}
```

###### 7.2查找二叉树

![image-20200201155302826](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201155302826.png)



![image-20200201155344961](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201155344961.png)

​	

![image-20200201165232478](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201165232478.png)

![image-20200201165656784](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201165656784.png)



![image-20200201165756011](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201165756011.png)



![image-20200201165932039](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201165932039.png)



![image-20200201170031549](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201170031549.png)

一般而言 后序查找一年是最短的

```json
printf 格式化输出的
print 和println不能格式化输出 只能输出普通的字符串
```

###### 7.3二叉树的删除

![image-20200201171512922](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201171512922.png)



![image-20200201172228503](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201172228503.png)



![image-20200201173252970](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201173252970.png)

![image-20200201173433964](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201173433964.png)

![image-20200201174119781](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201174119781.png)



![image-20200201175302148](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201175302148.png)



![image-20200201182624221](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201182624221.png)



![image-20200201182635733](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200201182635733.png)



###### 7.4顺序二叉树

![image-20200202143301004](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202143301004.png)



![image-20200202143453814](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202143453814.png)

![image-20200202143606374](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202143606374.png)



![image-20200202143807925](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202143807925.png)



重载方法

![image-20200202144205535](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202144205535.png)

###### 7.5线索化的二叉树

![image-20200202174719341](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202174719341.png)

![image-20200202174752013](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202174752013.png)

![image-20200202180920426](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202180920426.png)



![image-20200202181100926](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202181100926.png)



![image-20200202182815742](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202182815742.png)

![image-20200202182831009](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202182831009.png)

![image-20200202185342294](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202185342294.png)

![image-20200202185507594](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202185507594.png)



![image-20200202213625210](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202213625210.png)



![image-20200202222508706](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202222508706.png)



![image-20200202222525727](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200202222525727.png)



![image-20200203111119887](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203111119887.png)

###### 7.6堆排序：

![image-20200203112408927](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203112408927.png)

![image-20200203112426445](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203112426445.png)

![image-20200203113256973](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203113256973.png)

![image-20200203114209043](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203114209043.png)

![image-20200203115131200](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203115131200.png)

![image-20200203115223323](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203115223323.png)

![image-20200203115322953](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203115322953.png)



![image-20200203115354514](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203115354514.png)



![image-20200203144906913](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203144906913.png)

![image-20200203151150656](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203151150656.png)

![image-20200203194555125](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200203194555125.png)



###### 	7.7赫夫曼树：

![image-20200204230352668](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200204230352668.png)

### 7.8二叉排序树（二叉查找树、二叉搜索树）

什么是二叉查找树：
根节点的值大于其左子树中任意一个节点的值，小于其右节点中任意一节点的值，这一规则适用于二叉查找树中的每一个节点。

二叉搜索树，是指一棵空树或者具有下列性质的二叉树：

1. 若任意节点的左子树不空，则**左子树**上所有节点的值均**小于**它的**根节点**的值；

2. 若任意节点的右子树不空，则**右子树**上所有节点的值均**大于**它的**根节点**的值；

3. 任意节点的左，右子树也分别为二叉搜索树；

4. **没有键值相等的节点。**

   二叉搜索树中序遍历就是他的按大小排序的结果

   你会发现，按照中序遍历的规则将一个二叉搜索树输入，结果为按照正序排列。

   ```
    public void preOrder(Node root)
       { // 前序遍历,"中左右"
           if (root != null)
           {
               System.out.print(root.data + " ");
               preOrder(root.left);
               preOrder(root.right);
           }
       }
   
       public void inOrder(Node root)
       { // 中序遍历,"左中右"
           if (root != null)
           {
               inOrder(root.left);
               System.out.print(root.data + " ");
               inOrder(root.right);
           }
       }
   
       public void postOrder(Node root)
       { // 后序遍历,"左右中"
           if (root != null)
           {
               postOrder(root.left);
               postOrder(root.right);
               System.out.print(root.data + " ");
           }
       }
   
       public void traverse(int traverseType)
       {    // 选择以何种方式遍历
           switch (traverseType)
           {
           case 1:
               System.out.print("preOrder traversal ");
               preOrder(root);
               System.out.println();
               break;
           case 2:
               System.out.print("inOrder traversal ");
               inOrder(root);
               System.out.println();
               break;
           case 3:
               System.out.print("postOrder traversal ");
               postOrder(root);
               System.out.println();
               break;
           }
       }
   ```

   

本文章重点来讨论一下关于二叉查找树删除节点的问题。
有一下二叉查找树，如图：

![image-20200529114458081](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200529114458081.png)

在删除节点的时候我们只需考虑一下三种情况：
（1）要删除的节点是叶子结点，如图：

![image-20200529114509680](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200529114509680.png)

（2）要删除的节点有左节点但是没有右节点，或者有右节点但是没有左节点，如图：

![image-20200529114536604](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200529114536604.png)

（3）要删除的节点既有左节点又有右节点，在这种情况下，我们只需要将找到待删节点的右子树中值最小的节点，将其删除并且获取其值，并用其值替换待删节点的值即可。如图：

![image-20200529114617022](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200529114617022.png)

如上图所示，如果要删除节点7，则需寻找其右子树中节点值最小的9，并且该值一定位于该右子树的最左子节点；但是还有一种情况，如图一右子树没有左节点，但是只有右节点，这种情况就回到了前面的第二种情况。

具体代码如下：注意Node类是一个内部类，在使用时注意方法。

```java
package com.zc.algorithm;

public class BinarySortTree {

    public class Node{
        int value;
        Node left;
        Node right;

        public Node(int  value)
        {
            this.value = value;
        }
        public void add(Node node)
        {
            if(node == null)
            {
                return;
            }
            //判断传入的节点的值比当前子树的根节点的值大还是小
            if(node.value < this.value)
            {
                //如果左节点为空
                if(this.left == null)
                {
                    this.left = node;
                }
                else
                {
                    this.left.add(node);
                }
            }
            else
            {
                if(this.right == null)
                {
                    this.right =node;
                }
                else
                {
                    this.right.add(node);
                }

            }
        }

        /**
         * 前序遍历二叉排序树
         * @param node
         */
        public void middleOder(Node node)
        {
            if(node == null)
            {
                return;
            }
            middleOder(node.left);
            System.out.println(node.value);
            middleOder(node.right);
        }

        /**
         * 查找某一节点
         * @param value
         * @return
         */
        public Node search(int value)
        {
            if(this.value == value)
            {
                return this;
            }
            else if(value < this.value)
            {
                if(this.left == null)
                {
                    return null;
                }
                 return this.left.search(value);
            }
            else
            {
                if(this.right == null)
                {
                    return null;
                }
                return  this.right.search(value);
            }

        }
        public Node searchParent(int value) {
            if((this.left != null && this.left.value == value) || (this.right != null && this.right.value == value))
            {
                return this;
            }
            else
            {
                if(this.value > value&& this.left != null)
                {
                    return this.left.searchParent(value);
                }
                else if(this.value < value && this.right !=null)
                {
                    return this.right.searchParent(value);
                }
            }
            return null;
        }
      }


    Node root;
    /**
     * 向二叉排序树中添加节点
     * @param node
     */
    public void add(Node node)
    {
        if(root == null)
        {
            root = node;
        }
      else
        {
            root.add(node);
        }
    }
    public void frontShow()
    {
        if(root != null)
        {
            this.root.middleOder(root);
        }
    }
    public Node SearchNode(int value)
    {
        if(root == null)
            return null;
        else
        {
            return root.search(value);
        }
    }

    public void delete(int value) {
        if (root == null)
            return;
        else
        {
            Node target = SearchNode(value);
            //如果没有这个节点
            if(target == null)
            {
                return;
            }
            //找到他的父节点
            Node parent = searchParent(value);
            //要删除的节点是叶子结点
            if(target.left == null && target.right == null)
            {
                //要删除的节点是节点的左子节点
                if(parent.left.value == value)
                {
                    parent.left =null;
                }
                else
                {
                    parent.right = null;
                }
            }
            //要删除的节点有两个子节点的情况
            else if(target.left != null && target.right != null)
            {
                   //删除右子树中值最小的节点，并获取到该节点的值
                int min = minDelete(target.right);
                //替换目标节点中的值
                target.value = min;
            }
            else
            {
                //需要删除的目标节点的左节点不为空
                if(target.left != null)
                {
                    //要删除的子节点是其父节点的左子节点，并且有左节点而没有有节点
                    if(parent.left.value == value)
                    {
                        parent.left = target.left;
                    }
                    //要删除的子节点是其父节点的右子节点，并且有左节点而没有有节点
                    else
                    {
                        parent.right = target.left;
                    }
                }
                //需要删除的目标节点的右节点不为空
                else
                {
                    //要删除的节点是父节点的左节点，并且有右节点儿没有左节点
                    if(parent.left.value == value)
                    {
                        parent.left = target.right;
                    }
                    //要删除的节点是其父节点的右节点，并且有右孩子没有左孩子
                    else
                    {
                        parent.right = target.right;
                    }
                }


            }

        }
    }

    /**
     * 删除一颗树中最小的节点
     * @param node
     * @return
     */
    public int minDelete(Node node)
    {
        Node target = node;
        while(target.left != null)
        {
            target = target.left;
        }
       delete(target.value);
        return target.value;

    }
    /**
     * 查找父节点
     * @param value
     * @return
     */
    public Node searchParent(int value)
    {
        if(root == null)
        {
            return null;
        }
        else
        {
            return root.searchParent(value);
        }
    }
    public static void main(String[] args)
    {
        int[] arr = new int[]{7,3,10,12,5,1,9};
        BinarySortTree binTree = new BinarySortTree();
        for(int i : arr)
        {
            binTree.add(binTree.new Node(i));
        }
        binTree.delete(7);
        //查看树中的值
        binTree.frontShow();
        //查找
      //  Node node = binTree.new Node(3);
        //Node res = binTree.SearchNode(node.value);
        //System.out.println(res.value);
       // Node temp = binTree.SearchNode(20);
        //System.out.println(temp.value);
    }
}


```

### Java实现：在N个乱序的数组中找第K大的数







## 十三、单调栈算法：

![image-20200823231528681](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823231528681.png)

![image-20200823235722413](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823235722413.png)

#### 739.每日温度

![image-20200813112802383](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200813112802383.png)

![image-20200813113207303](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200813113207303.png)



#### [84. 柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)

![image-20200823225421119](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823225421119.png)

为此，我们需要：

​		左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；

​		右边看一下，看最多能向右延伸多长；找到大于等于当前柱形高度的最右边元素的下标。

对于每一个位置，我们都这样操作，得到一个矩形面积，求出它们的最大值。



```
public class Solution {

    public int largestRectangleArea(int[] heights) {
        int len = heights.length;
        // 特判
        if (len == 0) {
            return 0;
        }

        int res = 0;
        for (int i = 0; i < len; i++) {

            // 找左边最后 1 个大于等于 heights[i] 的下标
            int left = i;
            int curHeight = heights[i];
            while (left > 0 && heights[left - 1] >= curHeight) {
                left--;
            }

            // 找右边最后 1 个大于等于 heights[i] 的索引
            int right = i;
            while (right < len - 1 && heights[right + 1] >= curHeight) {
                right++;
            }

            int width = right - left + 1;
            res = Math.max(res, width * curHeight);
        }
        return res;
    }
}

```

![image-20200823225639404](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823225639404.png)

将一个位置存入到栈中，表示以当前位置的值为高度的矩形还不能确定宽度，就是还没有遇见比他小的高度

将一个位置出栈，表示以当前位置的值为高度的矩形已经能确定宽度，就是遇见了比他小的高度



![image-20200823230032109](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823230032109.png)

数组遍历完成以后，栈中剩余部分的面积的计算方法

右边界为数组的最后一位，左边界为该元素出栈以后栈顶的元素的位置（不含）

![image-20200823230143894](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823230143894.png)

栈中的最后一个元素表示它是最低点，可以直接乘以数组的长度为宽度

![image-20200823230333035](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823230333035.png)

![image-20200823230829137](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200823230829137.png)
![image-20200823230945315](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823230945315.png)

https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/bao-li-jie-fa-zhan-by-liweiwei1419/

```
import java.util.ArrayDeque;
import java.util.Deque;

public class Solution {

    public int largestRectangleArea(int[] heights) {
        int len = heights.length;
        if (len == 0) {
            return 0;
        }
        if (len == 1) {
            return heights[0];
        }

        int res = 0;
        Deque<Integer> stack = new ArrayDeque<>(len);
        for (int i = 0; i < len; i++) {
            // 这个 while 很关键，因为有可能不止一个柱形的最大宽度可以被计算出来
            while (!stack.isEmpty() && heights[i] < heights[stack.peekLast()]) {
                int curHeight = heights[stack.pollLast()];
                while (!stack.isEmpty() && heights[stack.peekLast()] == curHeight) {
                    stack.pollLast();
                }

                int curWidth;
                if (stack.isEmpty()) {
                    curWidth = i;
                } else {
                    curWidth = i - stack.peekLast() - 1;
                }

                // System.out.println("curIndex = " + curIndex + " " + curHeight * curWidth);
                res = Math.max(res, curHeight * curWidth);
            }
            stack.addLast(i);
        }

        while (!stack.isEmpty()) {
            int curHeight = heights[stack.pollLast()];
            while (!stack.isEmpty() && heights[stack.peekLast()] == curHeight) {
                stack.pollLast();
            }
            int curWidth;
            if (stack.isEmpty()) {
                curWidth = len;
            } else {
                curWidth = len - stack.peekLast() - 1;
            }
            res = Math.max(res, curHeight * curWidth);
        }
        return res;
    }
}


```

添加哨兵优化

![image-20200823231046276](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823231046276.png)

![image-20200823231112069](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823231112069.png)

![image-20200823231456490](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823231456490.png)




## 十四、优先队列（堆）相关

#### 1.任务调度

在选择每一轮中的任务时，我们也可以用优先队列（堆）来代替排序。在一开始，我们把所有的任务加入到优先队列中。在每一轮，我们从优先队列中选择最多 n + 1 个任务，把它们的数量减去 1，再放回堆中（如果数量不为 0），直到堆为空。

![image-20200813181457447](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200813181457447.png)



```java
 public class Solution2 {
        public int leastInterval(char[] tasks, int n) {
            int[] map = new int[26];
            for (char c: tasks)
                map[c - 'A']++;
            PriorityQueue < Integer > queue = new PriorityQueue < > (26, Collections.reverseOrder());
            for (int f: map) {
                if (f > 0)
                    queue.add(f);
            }
            int time = 0;
            while (!queue.isEmpty()) {
                int i = 0;//i为每轮执行的任务计数
                List< Integer > temp = new ArrayList< >();//队列里面存放取出来的元素，等一趟走完，再放进去
                while (i <= n) {//i从0到n。走n+1个元素出来
                    if (!queue.isEmpty()) {
                        if (queue.peek() > 1)
                            temp.add(queue.poll() - 1);
                        else
                            queue.poll();
                    }
                    time++;
                    if (queue.isEmpty() && temp.size() == 0)//如果大堆和队列都为空，说明任务已经被执行完了
                        break;
                    i++;
                }
                for (int l: temp)//一个周期循环完了以后，将list中的元素加入堆中，进行排序
                    queue.add(l);
            }
            return time;
        }
    }
```



### 十五、数组相关算法

#### 1.前缀和哈希表

![image-20200814103107851](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814103107851.png)

![image-20200814103449104](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814103449104.png)

![image-20200814103922667](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200814103922667.png)



```java
public class Solution {
    public int subarraySum(int[] nums, int k) {
        int count = 0, pre = 0;
        HashMap < Integer, Integer > mp = new HashMap < > ();
        mp.put(0, 1);
        for (int i = 0; i < nums.length; i++) {
            pre += nums[i];
            if (mp.containsKey(pre - k))
                count += mp.get(pre - k);
            mp.put(pre, mp.getOrDefault(pre, 0) + 1);
        }
        return count;
    }
}

```

## 十五、字符串相关

### 1.字母异位词

所谓字母以为词就是两个字符串里面的字符的出现次数一样，也就是这两个字符串的字符组成一样，但是字符的顺序是打乱的。若两个字符相等，也算是互为字母异位词

```java
 class Solution2 {
        public List<Integer> findAnagrams(String s, String p) {
            if (s.length()<p.length()) return null;
            List<Integer> list = new LinkedList<>();
            for (int i = 0; i < s.length()-p.length()+1; i++) {
                if (IsAnagram(s.substring(i,i+p.length()), p)) {
                    list.add(i);
                }
            }
            return list;

        }
        public boolean IsAnagram(String s, String t) {
            int[] arr = new int[26];
            for(char c : s.toCharArray())
                arr[c - 'a']++;
            for(char c : t.toCharArray())
                arr[c - 'a']--;
            for(int i : arr)
                if(i != 0)
                    return false;
            return true;
        }
    }
```



### **2**.滑动窗口相关



![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/8d7be984b81c96f0438c6ef3343fcf219e39482d7cdae8f2de9d06fa23fb88c5.png)





## 十六、并查集

 并查集是一种数据结构, 常用于描述集合,经常用于解决此类问题:某个元素是否属于某个集合,或者 某个元素 和 另一个元素是否同属于一个集合，用于处理一些不相交[集合](https://baike.baidu.com/item/集合/2908117)（Disjoint Sets）的合并及查询问题。常常在使用中以森林来表示。

并查集主要涉及到两种操作，合并和查找。

我们实现一个并查集的时候首先要考虑的就是存储结构，一般情况下有两种：数组和链表。现在我们使用数组来实现一下。

#### 初始化

- **先初始化所有的结点，将每一个结点的父结点都指向自己，这时候我们就构建好了一颗颗只有一个结点的树**

```cpp
for(int i=1;i<=n;i++)
    pre[i]=i;//使每一个点的父结点都指向自己  
```

 

#### 查找

- **查找：我们根据某个点的父结点是否是它本身来判断其是否是根结点，如果有 pre[ i ] = i  ，那么它就是父结点**

```cpp
//递归写法
int find(int k)
{
    if(pre[k]==k)    return k;
    return find(pre[k]);
}
 
//非递归
int find_(int x)
{
  int r=x;//将当前位置记录
  while(pre[r]!=r)//如果不是根节点
    r=pre[r];//继续向上查找,r的值更新为其父结点
  return r;
}
```

#### 路径压缩优化

- **所以我们新学一招：\**路径压缩\**————将某个根结点下的所有子结点都指向该根结点**
- **如此一来，我们就可以直接从目标结点的位置一步找到其根结点**

```
//递归
int find(int k)   //寻找k的根结点 
{
	if(pre[k]==k)	return k; //我们以pre的值是否是自身下标来判断根结点 
	return pre[k]=find(pre[k]); //递归路径压缩 
}
 
//非递归
int find_(int x)
{
    int r=x;
    while(pre[r]!=r)
        r=pre[r];
    int i=x,j;//i记录当前点，j记录i的上家
    while(i!=r)//若当前点不为根节点
    {
        j=pre[i];//记录上家
        pre[i]=r;//使当前点直接指向根节点
        i=j;//当前点移动到上家
    }
    return r;
}
```

**别忘了还有一个重要步骤，如果要将两个集合合并起来，我们也需要一个函数**

```
void merge(int x,int y)    //合并集合 
{
    int t1 = find(x);    //找到x和y的根结点 
    int t2 = find(y);
    if(t1!=t2)    pre[t1] = t2; //所在集合不同，将其中一个作为另一个集合的子集(根结点一样)
}
```



#### [394. 字符串解码](https://leetcode-cn.com/problems/decode-string/)



```java
package com.Leetcode_top100;

import java.util.HashMap;
import java.util.List;
import java.util.Map;

/**
 * # @author  chilcyWind
 * # @Time   2020/8/16 15:00
 * # @version 1.0
 * # @File : 除法求值399.java
 * # @Software: IntelliJ IDEA
 *[["a","b"],["b","c"]]
 * [2.0,3.0]
 * [["a","c"],["b","a"],["a","e"],["a","a"],["x","x"]]
 *
 */
public class 除法求值399 {
    class Solution {
        /**
         * key : 当前节点
         * value : 其父节点
         */
        private Map<String, String> parents = new HashMap<>();
        /**
         * key : 当前节点
         * value : 父节点/当前节点
         */
        private Map<String, Double> values = new HashMap<>();

        public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
            for (int i = 0; i < equations.size(); i++) {
                union(equations.get(i).get(0), equations.get(i).get(1), values[i]);
            }
            double[] result = new double[queries.size()];
            for (int i = 0; i < queries.size(); i++) {
                String e = queries.get(i).get(0);
                String q = queries.get(i).get(1);
                if (!(parents.containsKey(e) && parents.containsKey(q))) {
                    result[i] = -1;
                    continue;
                }
                if (e.equals(q)) {
                    result[i] = 1;
                    continue;
                }
                String r1 = root(e);
                String r2 = root(q);
                if (!r1.equals(r2)) {
                    // 如果两者不相等，说明两个节点是不连通的
                    result[i] = -1;
                    continue;
                }
                result[i] = pm(q)/pm(e);
            }
            return result;
        }

        private void union(String parent, String child, double value) {
            add(parent);//不包含，就是自己是自己的父节点，parents.put(x, x);
            add(child);//不包含，就是自己是自己的父节点，parents.put(x, x);
            String r1 = root(parent);//找到x的根节点
            String r2 = root(child);//找到x的根节点
            if (!r1.equals(r2)) {
                parents.put(r2, r1);
                values.put(r2, value * (pm(parent)/pm(child)));
            }
        }
        private void add(String x) {
            if (!parents.containsKey(x)) {
                parents.put(x, x);
                values.put(x, 1.0);
            }
        }



        /**
         * 找到x的根节点
         */
        private String root(String x) {
            while (!parents.get(x).equals(x)) {
                x = parents.get(x);
            }
            return x;
        }


        /**
         * 循环的pm函数
         */
        private double pm(String x) {
            double v = 1;
            while (!parents.get(x).equals(x)) {
                v*= values.get(x);
                x = parents.get(x);
            }
            return v;
        }

//    /**
//     * 递归的pm函数
//     * @param x
//     * @return
//     */
//    private double pm(String x){
//        return parents.get(x).equals(x)?1:values.get(x)*pm(parents.get(x));
//    }

    }
    class Solution3 {
         Map<String, String> parents;
         Map<String, Double> val;
//        首先如果有a/b = 3，我们令parent[a] = b，即让b成为a的父亲，同时让val[a] = 3。
//        所以此处的定义非常重要：即val[]数组存放的是节点与他直接父节点的关系


        public String find(String x) {

            if (!x.equals(parents.get(x))) {
                String tmpParent = parents.get(x);
                String root = find(tmpParent);
                double oldVal = val.get(x);
                val.put(x, oldVal * val.get(tmpParent));
                parents.put(x, root);
            }
            return parents.get(x);
        }

        public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {
            parents = new HashMap<>();
            val = new HashMap<>();
            int i = 0;
            for (List<String> equation : equations) {
                String from = equation.get(0);
                String to = equation.get(1);
                double cur = values[i];
                if (!parents.containsKey(from) && !parents.containsKey(to)) {
                    parents.put(from, to);
                    val.put(from, cur);
                    parents.put(to, to);
                    val.put(to, 1.0);
                } else if (!parents.containsKey(from)) {
                    parents.put(from, to);
                    val.put(from, cur);
                } else if (!parents.containsKey(to)) {
                    parents.put(to, from);
                    val.put(to, 1 / cur);
                } else {
                    String pa = find(from);
                    String pb = find(to);
                    if (!pa.equals(pb)) {
                        parents.put(pa, pb);
                        val.put(pa, cur * val.get(to) / val.get(from));
                    }
                }
                i++;
            }
            i = 0;
            double[] res = new double[queries.size()];
            for (List<String> query : queries) {
                String from = query.get(0);
                String to = query.get(1);
                if (!parents.containsKey(from) || !parents.containsKey(to)) {
                    res[i++] = -1;
                    continue;
                }
                String pa = find(from);
                String pb = find(to);
                if (!pa.equals(pb)) res[i] = -1;
                else {
                    res[i] = val.get(from) / val.get(to);
                }
                i++;
            }
            return res;
        }
    }

//    作者：kevincxks
//    链接：https://leetcode-cn.com/problems/evaluate-division/solution/zhen-zheng-de-xiao-bai-du-neng-kan-dong-de-bing-ch/
//    来源：力扣（LeetCode）
//    著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

}

```



#### [128. 最长连续序列](https://leetcode-cn.com/problems/longest-consecutive-sequence/)

![image-20200824220414744](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200824220414744.png)
![image-20200824220628157](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824220628157.png)

```java 
 class Solution {
        public int longestConsecutive(int[] nums) {
            Set<Integer> num_set = new HashSet<Integer>();
            //set可以完成去重的目的
            for (int num : nums) {
                num_set.add(num);
            }

            int longestStreak = 0;

            for (int num : num_set) {
                //如果这个数有比他小1位的，直接跳过，因为遍历到比他小1位的会找到他作为子序列的一部分。遍历的目的就是为了
                // 发现各个起点元素，然后由起点元素寻找连续子序列
                if (!num_set.contains(num - 1)) {//先找到一个num是连续序列的起点，也就是hashset中不存在比这个数小1的前一个数，
                    // 作为起点，遍历一遍就能确定所有可能的起点
                    int currentNum = num;
                    int currentStreak = 1;

                    while (num_set.contains(currentNum + 1)) {//然后往后挨个找连成的序列
                        currentNum += 1;
                        currentStreak += 1;
                    }

                    longestStreak = Math.max(longestStreak, currentStreak);
                }
            }

            return longestStreak;
        }
    }
```





## 十七、桶排序

#### [347. 前 K 个高频元素](https://leetcode-cn.com/problems/top-k-frequent-elements/)

```
//基于桶排序求解「前 K 个高频元素」
class Solution3 {
    public int[] topKFrequent(int[] nums, int k) {

        // 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值
        HashMap<Integer,Integer> map = new HashMap();
        for(int num : nums){
            if (map.containsKey(num)) {
                map.put(num, map.get(num) + 1);
            } else {
                map.put(num, 1);
            }
        }

        //桶排序
        //将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标
        List<Integer>[] list = new List[nums.length+1];
        for(int key : map.keySet()){
            // 获取出现的次数作为下标
            int i = map.get(key);
            if(list[i] == null){
                list[i] = new ArrayList();
            }
            list[i].add(key);
        }
        int[] res=new int[k];
        int j=0;

        // 倒序遍历数组获取出现顺序从大到小的排列
        for(int i = list.length - 1;i >= 0 && j < k;i--){
            if(list[i] == null) continue;
            for(int n=0;n<list[i].size() ;n++){
                res[j++]=list[i].get(n);

            }
        }
        return res;
    }
}
```

## 十八、[popcount 算法分析](https://www.cnblogs.com/Martinium/archive/2013/03/01/popcount.html)

在二进制表示中，数字 n 中最低位的11总是对应 n - 1中的 0 。因此，将 n和 n - 1 与运算总是能把 n 中最低位的 1 变成 0 ，并保持其他位不变。



```
 我们不再检查数字的每一个位，而是不断把数字最后一个 1 反转，并把答案加一。当数字变成 0的时候偶，我们就知道它没有 1的位了，此时返回答案。
//        这里关键的想法是对于任意数字 n ，将 n 和 n - 1 做与运算，会把最后一个 1 的位变成 0 。为什么？考虑 n 和 n - 1的二进制表示。
//        相当于把n的最后一位1移动到最低位，而对高位的1没有影响

//        6-> 1 1 0
//        5-> 1 0 1
//        &-> 1 0 1 相当于把6的最低位1 移到第一位，其他位置的1保持不变
```

## 十九、数组矩阵操作

#### [48. 旋转图像](https://leetcode-cn.com/problems/rotate-image/)

![image-20200822144755254](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822144755254.png)

旋转的时候，每四个矩阵块作为一组进行相应的旋转

![图片.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/9862d85a4282a4914bb0b3d480a3286307723f9ef27e295b6353e41e01bed63d-%E5%9B%BE%E7%89%87.png)

可以看出，第二次旋转的时候比第一次旋转偏移了一格，这里我们使用add变量来记录矩阵块的偏移量，首先不考虑偏移量的时候写出左上角的坐标为(pos1,pos1),右上角的坐标为(pos1,pos2),左下角的坐标为(pos2,pos1),右下角的坐标为(pos2,pos2),则能够写出偏移之后对应的坐标

![坐标变换.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/58c76a0a3b1fed08f9546aa0993c99f3d1fff08a63987c960a5ccf23f7c71678-image.png)

![image-20200822144855902](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200822144855902.png)

```java
 public void rotate(int[][] matrix) {
        int add = 0;
        int temp = 0;
        int pos1 = 0;
        int pos2 = matrix[0].length - 1;
        while (pos1 < pos2){
            add = 0;
            while (add < pos2 - pos1){
                temp = matrix[pos1][pos1 + add];
                matrix[pos1][pos1 + add] = matrix[pos2 - add][pos1];
                matrix[pos2 - add][pos1] = matrix[pos2][pos2 -add];
                matrix[pos2][pos2 -add] = matrix[pos1 + add][pos2];
                matrix[pos1 + add][pos2] = temp;
                add++;
            }
            pos1++;
            pos2--;

        }
    }
```

其他方法见官方题解，不看了。

方法 1 ：转置加翻转
最直接的想法是先转置矩阵，然后翻转每一行。这个简单的方法已经能达到最优的时间复杂度O(N^2)O(N 
2
 )。





```java
class Solution {
  public void rotate(int[][] matrix) {
    int n = matrix.length;
    // transpose matrix
for (int i = 0; i < n; i++) {
  for (int j = i; j < n; j++) {
    int tmp = matrix[j][i];
    matrix[j][i] = matrix[i][j];
    matrix[i][j] = tmp;
  }
}
// reverse each row
for (int i = 0; i < n; i++) {
  for (int j = 0; j < n / 2; j++) {
    int tmp = matrix[i][j];
    matrix[i][j] = matrix[i][n - j - 1];
    matrix[i][n - j - 1] = tmp;
  }
}
  }
}


```

## 二十、hash表相关

#### [146. LRU缓存机制](https://leetcode-cn.com/problems/lru-cache/)

![image-20200825161238790](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200825161238790.png)

在 Java 语言中，同样有类似的数据结构 LinkedHashMap。这些做法都不会符合面试官的要求，因此下面只给出使用封装好的数据结构实现的代码，而不多做任何阐述。

```
class LRUCache extends LinkedHashMap<Integer, Integer>{
    private int capacity;
    
    public LRUCache(int capacity) {
        super(capacity, 0.75F, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity; 
    }
}

```

方法一：哈希表 + 双向链表
算法

LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。

双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。

哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。

这样以来，我们首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部，即可在 O(1)O(1) 的时间内完成 get 或者 put 操作。具体的方法如下：

对于 get 操作，首先判断 key 是否存在：

如果 key 不存在，则返回 -1−1；

如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。

对于 put 操作，首先判断 key 是否存在：

如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项；

如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。

上述各项操作中，访问哈希表的时间复杂度为 O(1)O(1)，在双向链表的头部添加节点、在双向链表的尾部删除节点的复杂度也为 O(1)O(1)。而将一个节点移到双向链表的头部，可以分成「删除该节点」和「在双向链表的头部添加节点」两步操作，都可以在 O(1)O(1) 时间内完成。

小贴士

在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。

```
 class solution {
        public class LRUCache {
            //定义一个双向链表
            //双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。
            class DLinkedNode {//
                int key;
                int value;
                DLinkedNode prev;
                DLinkedNode next;

                public DLinkedNode() {
                }

                public DLinkedNode(int _key, int _value) {
                    key = _key;
                    value = _value;
                }
            }

//            哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。
            private Map<Integer, DLinkedNode> cache = new HashMap<Integer, DLinkedNode>();
            private int size;
            private int capacity;
            private DLinkedNode head, tail;

            public LRUCache(int capacity) {
                this.size = 0;
                this.capacity = capacity;
                // 使用伪头部和伪尾部节点
                head = new DLinkedNode();
                tail = new DLinkedNode();
                head.next = tail;
                tail.prev = head;
            }

            public int get(int key) {
                DLinkedNode node = cache.get(key);//根据hash表在 o(1)的时间获取对应的链表中的节点
                if (node == null) {
                    return -1;
                }
                // 如果 key 存在，先通过哈希表定位，再移到头部
                moveToHead(node);
                return node.value;
            }

            public void put(int key, int value) {
                DLinkedNode node = cache.get(key);
                if (node == null) {
                    // 如果 key 不存在，创建一个新的节点
                    DLinkedNode newNode = new DLinkedNode(key, value);
                    // 添加进哈希表
                    cache.put(key, newNode);
                    // 添加至双向链表的头部
                    addToHead(newNode);
                    ++size;
                    if (size > capacity) {
                        // 如果超出容量，删除双向链表的尾部节点
                        DLinkedNode tail = removeTail();
                        // 删除哈希表中对应的项
                        cache.remove(tail.key);
                        --size;
                    }
                } else {
                    // 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部
                    node.value = value;
                    moveToHead(node);
                }
            }

            private void addToHead(DLinkedNode node) {
                node.prev = head;
                node.next = head.next;
                head.next.prev = node;
                head.next = node;
            }

            private void removeNode(DLinkedNode node) {
                node.prev.next = node.next;
                node.next.prev = node.prev;
            }

            private void moveToHead(DLinkedNode node) {
                removeNode(node);
                addToHead(node);
            }

            private DLinkedNode removeTail() {
                DLinkedNode res = tail.prev;
                removeNode(res);
                return res;
            }
        }

    }
```

## 二十一、双指针和滑动窗口

#### 我写了一首诗，把滑动窗口算法变成了默写题

https://leetcode-cn.com/problems/minimum-window-substring/solution/hua-dong-chuang-kou-suan-fa-tong-yong-si-xiang-by-/



决策单调性

![image-20200823161926645](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823161926645.png)

#### [75. 颜色分类](https://leetcode-cn.com/problems/sort-colors/)

关键点：只有三个颜色，只用0,1,2表示

此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。



![image-20200823165642506](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200823165642506.png)
![image-20200823165717353](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823165717353.png)

```java
class Solution {
  /*
  荷兰三色旗问题解
  */
  public void sortColors(int[] nums) {
    // 对于所有 idx < i : nums[idx < i] = 0
    // j是当前考虑元素的下标
    int p0 = 0, curr = 0;
    // 对于所有 idx > k : nums[idx > k] = 2
    int p2 = nums.length - 1;

    int tmp;
    while (curr <= p2) {
      if (nums[curr] == 0) {
        // 交换第 p0个和第curr个元素
        // i++，j++
        tmp = nums[p0];
        nums[p0++] = nums[curr];
        nums[curr++] = tmp;
      }
      else if (nums[curr] == 2) {
        // 交换第k个和第curr个元素
        // p2--
        tmp = nums[curr];
        nums[curr] = nums[p2];
        nums[p2--] = tmp;
      }
      else curr++;
    }
  }
}

```







#### [76. 最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)

![image-20200823153518022](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823153518022.png)

![image-20200823153734812](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823153734812.png)

![image-20200823153820660](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823153820660.png)

![image-20200823154016886](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823154016886.png)



汉明距离表示a是否包含b所有的字符，包括频率都是一样的

![image-20200823154802530](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823154802530.png)

![image-20200823160310645](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823160310645.png)
![image-20200823162514191](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200823162514191.png)

```
class Solution {
    public String minWindow(String s, String t) {
        if (s == null || s == "" || t == null || t == "" || s.length() < t.length()) {
            return "";
        }
        //维护两个数组，记录已有字符串指定字符的出现次数，和目标字符串指定字符的出现次数
        //ASCII表总长128
        int[] need = new int[128];
        int[] have = new int[128];

        //将目标字符串指定字符的出现次数记录
        for (int i = 0; i < t.length(); i++) {
            need[t.charAt(i)]++;
        }

        //分别为左指针，右指针，最小长度(初始值为一定不可达到的长度)
        //已有字符串中目标字符串指定字符的出现总频次以及最小覆盖子串在原字符串中的起始位置
        int left = 0, right = 0, min = s.length() + 1, count = 0, start = 0;
        while (right < s.length()) {
            char r = s.charAt(right);
            //说明该字符不被目标字符串需要，此时有两种情况
            // 1.循环刚开始，那么直接移动右指针即可，不需要做多余判断
            // 2.循环已经开始一段时间，此处又有两种情况
            //  2.1 上一次条件不满足，已有字符串指定字符出现次数不满足目标字符串指定字符出现次数，那么此时
            //      如果该字符还不被目标字符串需要，就不需要进行多余判断，右指针移动即可
            //  2.2 左指针已经移动完毕，那么此时就相当于循环刚开始，同理直接移动右指针
            if (need[r] == 0) {
                right++;
                continue;
            }
            //当且仅当已有字符串目标字符出现的次数小于目标字符串字符的出现次数时，count才会+1
            //是为了后续能直接判断已有字符串是否已经包含了目标字符串的所有字符，不需要挨个比对字符出现的次数
            if (have[r] < need[r]) {
                count++;
            }
            //已有字符串中目标字符出现的次数+1
            have[r]++;
            //移动右指针
            right++;
            //当且仅当已有字符串已经包含了所有目标字符串的字符，且出现频次一定大于或等于指定频次
            while (count == t.length()) {
                //挡窗口的长度比已有的最短值小时，更改最小值，并记录起始位置
                if (right - left < min) {
                    min = right - left;
                    start = left;
                }
                char l = s.charAt(left);
                //如果左边即将要去掉的字符不被目标字符串需要，那么不需要多余判断，直接可以移动左指针
                if (need[l] == 0) {
                    left++;
                    continue;
                }
                //如果左边即将要去掉的字符被目标字符串需要，且出现的频次正好等于指定频次，那么如果去掉了这个字符，
                //就不满足覆盖子串的条件，此时要破坏循环条件跳出循环，即控制目标字符串指定字符的出现总频次(count）-1
                if (have[l] == need[l]) {
                    count--;
                }
                //已有字符串中目标字符出现的次数-1
                have[l]--;
                //移动左指针
                left++;
            }
        }
        //如果最小长度还为初始值，说明没有符合条件的子串
        if (min == s.length() + 1) {
            return "";
        }
        //返回的为以记录的起始位置为起点，记录的最短长度为距离的指定字符串中截取的子串
        return s.substring(start, start + min);
    }
}
```

![image-20200823161906329](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823161906329.png)



方法一：滑动窗口
思路和算法

本问题要求我们返回字符串 ss 中包含字符串 tt 的全部字符的最小窗口。我们称包含 tt 的全部字母的窗口为「可行」窗口。

我们可以用滑动窗口的思想解决这个问题，在滑动窗口类型的问题中都会有两个指针。一个用于「延伸」现有窗口的 rr 指针，和一个用于「收缩」窗口的 ll 指针。在任意时刻，只有一个指针运动，而另一个保持静止。我们在 ss 上滑动窗口，通过移动 rr 指针不断扩张窗口。当窗口包含 tt 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。

![image-20200823161812069](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200823161812069.png)

```
 class Solution {
        Map<Character, Integer> ori = new HashMap<Character, Integer>();//记录模式 t 中的字符频数
        Map<Character, Integer> cnt = new HashMap<Character, Integer>();//记录字符串 s 中的窗口l到r 中的 字符频数

        public String minWindow(String s, String t) {
            //t中有重复的字符
            int tLen = t.length();
            for (int i = 0; i < tLen; i++) {
                char c = t.charAt(i);
                ori.put(c, ori.getOrDefault(c, 0) + 1);//记录模式 t 中的字符频数
            }
            int l = 0, r = -1;//窗口的范围
            // ansL ansR记录最小窗口范围 的左右边界 ， len记录最小子串的长度
            int len = Integer.MAX_VALUE,
                    ansL = -1,
                    ansR = -1;
            int sLen = s.length();
            //这里窗口的范围为闭区间，即[l,r],因此长度为 r-l+1
            while (r < sLen) {//r < sLen 遍历结束的标志
                ++r;//在s的窗口没有包含t所有字符的时候，先固定左边指针，移动右边指针，扩大范围
                if (r < sLen && ori.containsKey(s.charAt(r))) {//如果右边边界r的字符在 t中，更新 cnt
                    cnt.put(s.charAt(r), cnt.getOrDefault(s.charAt(r), 0) + 1);
                }
                while (check() && l <= r) {
                    //如果窗口包含了t所有字符，则固定右边指针，移动左边指针缩小窗口，结束的标志是[l,r]字符串没有包含t中的所有字符，
                    // 然后可以固定l,开始移动r,继续到下一个符合的位置
                    if (r - l + 1 < len) {
                        //看当前位置是不是最短的子字符串，是的话更新 len l ，r
                        len = r - l + 1;
                        ansL = l;
                        ansR = l + len;
                    }
                    if (ori.containsKey(s.charAt(l))) {//如果缩小的l位置是t中的字符，则对应位置减一，
                        cnt.put(s.charAt(l), cnt.getOrDefault(s.charAt(l), 0) - 1);
                    }
                    ++l;
                }
            }
            return ansL == -1 ? "" : s.substring(ansL, ansR);//如果没有更新ans，说明没找到，直接返回空
        }

        public boolean check() {
            //检查字符s窗口的字符串是不是包含了 t所有的字符
            Iterator iter = ori.entrySet().iterator();
            while (iter.hasNext()) {
                Map.Entry entry = (Map.Entry) iter.next();
                Character key = (Character) entry.getKey();
                Integer val = (Integer) entry.getValue();
                if (cnt.getOrDefault(key, 0) < val) {
                    return false;
                }
            }
            return true;
        }
    }
```

#### [141. 环形链表](https://leetcode-cn.com/problems/linked-list-cycle/)

##### 方法一：哈希表

思路

我们可以通过检查一个结点此前是否被访问过来判断链表是否为环形链表。常用的方法是使用哈希表。

算法

我们遍历所有结点并在哈希表中存储每个结点的引用（或内存地址）。如果当前结点为空结点 null（即已检测到链表尾部的下一个结点），那么我们已经遍历完整个链表，并且该链表不是环形链表。如果当前结点的引用已经存在于哈希表中，那么返回 true（即该链表为环形链表）。





```
public boolean hasCycle(ListNode head) {
    Set<ListNode> nodesSeen = new HashSet<>();
    while (head != null) {
        if (nodesSeen.contains(head)) {
            return true;
        } else {
            nodesSeen.add(head);
        }
        head = head.next;
    }
    return false;
}
```

##### 方法二：快慢指针

思路

想象一下，两名运动员以不同的速度在环形赛道上跑步会发生什么？

算法

通过使用具有 不同速度 的快、慢两个指针遍历链表，空间复杂度可以被降低至 O(1)O(1)。慢指针每次移动一步，而快指针每次移动两步。

如果列表中不存在环，最终快指针将会最先到达尾部，此时我们可以返回 false。

现在考虑一个环形链表，把慢指针和快指针想象成两个在环形赛道上跑步的运动员（分别称之为慢跑者与快跑者）。而快跑者最终一定会追上慢跑者。这是为什么呢？考虑下面这种情况（记作情况 A）- 假如快跑者只落后慢跑者一步，在下一次迭代中，它们就会分别跑了一步或两步并相遇。

其他情况又会怎样呢？例如，我们没有考虑快跑者在慢跑者之后两步或三步的情况。但其实不难想到，因为在下一次或者下下次迭代后，又会变成上面提到的情况 A。

```
public boolean hasCycle(ListNode head) {
    if (head == null || head.next == null) {
        return false;
    }
    ListNode slow = head;
    ListNode fast = head.next;
    while (slow != fast) {
        if (fast == null || fast.next == null) {
            return false;
        }
        slow = slow.next;
        fast = fast.next.next;
    }
    return true;
}

```

![image-20200824231224437](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824231224437.png)



#### [142. 环形链表 II](https://leetcode-cn.com/problems/linked-list-cycle-ii/)

如果我们用一个 `Set` 保存已经访问过的节点，我们可以遍历整个列表并返回第一个出现重复的节点。

**算法**

```
public class Solution {
    public ListNode detectCycle(ListNode head) {
        Set<ListNode> visited = new HashSet<ListNode>();

        ListNode node = head;
        while (node != null) {
            if (visited.contains(node)) {
                return node;
            }
            visited.add(node);
            node = node.next;
        }

        return null;
    }
}


```

##### 方法 2：Floyd 算法

慢指针走一步，快指针走两步，然后走到相遇的位置，快指针走一步，慢指针从头开始走，就能相遇在环的入口处

https://leetcode-cn.com/problems/linked-list-cycle-ii/solution/huan-xing-lian-biao-ii-by-leetcode/

```java
public class Solution {
    private ListNode getIntersect(ListNode head) {
        ListNode tortoise = head;
        ListNode hare = head;
        // A fast pointer will either loop around a cycle and meet the slow
        // pointer or reach the `null` at the end of a non-cyclic list.
        while (hare != null && hare.next != null) {
            tortoise = tortoise.next;
            hare = hare.next.next;
            if (tortoise == hare) {
                return tortoise;
            }
        }
        return null;
}
    public ListNode detectCycle(ListNode head) {
        if (head == null) {
            return null;
        }

        // If there is a cycle, the fast/slow pointers will intersect at some
        // node. Otherwise, there is no cycle, so we cannot find an e***ance to
        // a cycle.
        ListNode intersect = getIntersect(head);
        if (intersect == null) {
            return null;
        }

        // To find the e***ance to the cycle, we have two pointers traverse at
        // the same speed -- one from the front of the list, and the other from
        // the point of intersection.
        ListNode ptr1 = head;
        ListNode ptr2 = intersect;
        while (ptr1 != ptr2) {
            ptr1 = ptr1.next;
            ptr2 = ptr2.next;
        }

        return ptr1;
    }
}
```



## 二十二、ASCII

![img](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/f50f83c1b74a18a0538541481bc647e2.jpg)

| **ASCII****值** | **控制字符** | **ASCII****值** | **控制字符** | **ASCII****值** | **控制字符** | **ASCII****值** | **控制字符** |
| --------------- | ------------ | --------------- | ------------ | --------------- | ------------ | --------------- | ------------ |
| 0               | NUL          | 32              | (space)      | 64              | @            | 96              | 、           |
| 1               | SOH          | 33              | ！           | 65              | A            | 97              | a            |
| 2               | STX          | 34              | ”            | 66              | B            | 98              | b            |
| 3               | ETX          | 35              | #            | 67              | C            | 99              | c            |
| 4               | EOT          | 36              | $            | 68              | D            | 100             | d            |
| 5               | ENQ          | 37              | %            | 69              | E            | 101             | e            |
| 6               | ACK          | 38              | &            | 70              | F            | 102             | f            |
| 7               | BEL          | 39              | '            | 71              | G            | 103             | g            |
| 8               | BS           | 40              | (            | 72              | H            | 104             | h            |
| 9               | HT           | 41              | )            | 73              | I            | 105             | i            |
| 10              | LF           | 42              | *            | 74              | J            | 106             | j            |
| 11              | VT           | 43              | +            | 75              | K            | 107             | k            |
| 12              | FF           | 44              | ,            | 76              | L            | 108             | l            |
| 13              | CR           | 45              | -            | 77              | M            | 109             | m            |
| 14              | SO           | 46              | .            | 78              | N            | 110             | n            |
| 15              | SI           | 47              | /            | 79              | O            | 111             | o            |
| 16              | DLE          | 48              | 0            | 80              | P            | 112             | p            |
| 17              | DCI          | 49              | 1            | 81              | Q            | 113             | q            |
| 18              | DC2          | 50              | 2            | 82              | R            | 114             | r            |
| 19              | DC3          | 51              | 3            | 83              | X            | 115             | s            |
| 20              | DC4          | 52              | 4            | 84              | T            | 116             | t            |
| 21              | NAK          | 53              | 5            | 85              | U            | 117             | u            |
| 22              | SYN          | 54              | 6            | 86              | V            | 118             | v            |
| 23              | TB           | 55              | 7            | 87              | W            | 119             | w            |
| 24              | CAN          | 56              | 8            | 88              | X            | 120             | x            |
| 25              | EM           | 57              | 9            | 89              | Y            | 121             | y            |
| 26              | SUB          | 58              | :            | 90              | Z            | 122             | z            |
| 27              | ESC          | 59              | ;            | 91              | [            | 123             | {            |
| 28              | FS           | 60              | <            | 92              | \            | 124             | \|           |
| 29              | GS           | 61              | =            | 93              | ]            | 125             | }            |
| 30              | RS           | 62              | >            | 94              | ^            | 126             | ~            |
| 31              | US           | 63              | ?            | 95              | —            | 127             | DEL          |

**1.ASCII****中的****0~31****为控制字符；****32~126****为打印字符；****127****为****Delete(****删除****)****命令。下表为控制字符释义。**

| **十进制** | **十六进制** | **字符**   | **十进制** | **十六进制** | **字符**     |
| ---------- | ------------ | ---------- | ---------- | ------------ | ------------ |
| 0          | 00           | 空         | 16         | 10           | 数据链路转意 |
| 1          | 01           | 头标开始   | 17         | 11           | 设备控制 1   |
| 2          | 02           | 正文开始   | 18         | 12           | 设备控制 2   |
| 3          | 03           | 正文结束   | 19         | 13           | 设备控制 3   |
| 4          | 04           | 传输结束   | 20         | 14           | 设备控制 4   |
| 5          | 05           | 查询       | 21         | 15           | 反确认       |
| 6          | 06           | 确认       | 22         | 16           | 同步空闲     |
| 7          | 07           | 震铃       | 23         | 17           | 传输块结束   |
| 8          | 08           | backspace  | 24         | 18           | 取消         |
| 9          | 09           | 水平制表符 | 25         | 19           | 媒体结束     |
| 10         | 0A           | 换行/新行  | 26         | 1A           | 替换         |
| 11         | 0B           | 竖直制表符 | 27         | 1B           | 转意         |
| 12         | 0C           | 换页/新页  | 28         | 1C           | 文件分隔符   |
| 13         | 0D           | 回车       | 29         | 1D           | 组分隔符     |
| 14         | 0E           | 移出       | 30         | 1E           | 记录分隔符   |
| 15         | 0F           | 移入       | 31         | 1F           | 单元分隔符   |

**2.ASCII****扩展字符****——****（为了适应更多字符）****128~255****，或者****-128~-1,****其中，****-128****对应****128****，依次递增对应。**

| **十进制** | **十六进制** | **字符** | **十进制** | **十六进制** | **字符** |
| ---------- | ------------ | -------- | ---------- | ------------ | -------- |
| 128        | 80           | &Ccedil; | 192        | C0           | └        |
| 129        | 81           | ü        | 193        | C1           | ┴        |
| 130        | 82           | é        | 194        | C2           | ┬        |
| 131        | 83           | &acirc;  | 195        | C3           | ├        |
| 132        | 84           | &auml;   | 196        | C4           | ─        |
| 133        | 85           | à        | 197        | C5           | ┼        |
| 134        | 86           | &aring;  | 198        | C6           | ╞        |
| 135        | 87           | &ccedil; | 199        | C7           | ╟        |
| 136        | 88           | ê        | 200        | C8           | ╚        |
| 137        | 89           | &euml;   | 201        | C9           | ╔        |
| 138        | 8A           | è        | 202        | CA           | ╩        |
| 139        | 8B           | &iuml;   | 203        | CB           | ╦        |
| 140        | 8C           | &icirc;  | 204        | CC           | ╠        |
| 141        | 8D           | ì        | 205        | CD           | ═        |
| 142        | 8E           | &Auml;   | 206        | CE           | ╬        |
| 143        | 8F           | &Aring;  | 207        | CF           | ╧        |
| 144        | 90           | &Eacute; | 208        | D0           | ╨        |
| 145        | 91           | &aelig;  | 209        | D1           | ╤        |
| 146        | 92           | &AElig;  | 210        | D2           | ╥        |
| 147        | 93           | &ocirc;  | 211        | D3           | ╙        |
| 148        | 94           | &ouml;   | 212        | D4           | &Ocirc;  |
| 149        | 95           | ò        | 213        | D5           | ╒        |
| 150        | 96           | &ucirc;  | 214        | D6           | ╓        |
| 151        | 97           | ù        | 215        | D7           | ╫        |
| 152        | 98           | &yuml;   | 216        | D8           | ╪        |
| 153        | 99           | &Ouml;   | 217        | D9           | ┘        |
| 154        | 9A           | &Uuml;   | 218        | DA           | ┌        |
| 155        | 9B           | &cent;   | 219        | DB           | █        |
| 156        | 9C           | &pound;  | 220        | DC           | ▄        |
| 157        | 9D           | &yen;    | 221        | DD           | ▌        |
| 158        | 9E           | ?        | 222        | DE           | ?        |
| 159        | 9F           | ƒ        | 223        | DF           | ?        |
| 160        | A0           | á        | 224        | E0           | α        |
| 161        | A1           | í        | 225        | E1           | &szlig;  |
| 162        | A2           | ó        | 226        | E2           | Γ        |
| 163        | A3           | ú        | 227        | E3           | π        |
| 164        | A4           | &ntilde; | 228        | E4           | Σ        |
| 165        | A5           | &Ntilde; | 229        | E5           | σ        |
| 166        | A6           | &ordf;   | 230        | E6           | &micro;  |
| 167        | A7           | &ordm;   | 231        | E7           | τ        |
| 168        | A8           | &iquest; | 232        | E8           | Φ        |
| 169        | A9           | ?        | 233        | E9           | Θ        |
| 170        | AA           | &not;    | 234        | EA           | Ω        |
| 171        | AB           | &frac12; | 235        | EB           | δ        |
| 172        | AC           | &frac14; | 236        | EC           | ∞        |
| 173        | AD           | &iexcl;  | 237        | ED           | φ        |
| 174        | AE           | &laquo;  | 238        | EE           | ε        |
| 175        | AF           | &raquo;  | 239        | EF           | ∩        |
| 176        | B0           | ?        | 240        | F0           | ≡        |
| 177        | B1           | ?        | 241        | F1           | ±        |
| 178        | B2           | ▓        | 242        | F2           | ≥        |
| 179        | B3           | │        | 243        | F3           | ≤        |
| 180        | B4           | ┤        | 244        | F4           | ?        |
| 181        | B5           | ╡        | 245        | F5           | ?        |
| 182        | B6           | ╢        | 246        | F6           | ÷        |
| 183        | B7           | ╖        | 247        | F7           | ≈        |
| 184        | B8           | ╕        | 248        | F8           | ≈        |
| 185        | B9           | ╣        | 249        | F9           | ?        |
| 186        | BA           | ║        | 250        | FA           | ·        |
| 187        | BB           | ╗        | 251        | FB           | √        |
| 188        | BC           | ╝        | 252        | FC           | ?        |
| 189        | BD           | ╜        | 253        | FD           | &sup2;   |
| 190        | BE           | ╛        | FE         | ■            |          |
| 191        | BF           | ┐        | 255        | FF           | ÿ        |

## 二十三、递归和迭代

#### [206. 反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)

方法一：迭代
假设存在链表 1 → 2 → 3 → Ø，我们想要把它改成 Ø ← 1 ← 2 ← 3。

在遍历列表时，将当前节点的 next 指针改为指向前一个元素。由于节点没有引用其上一个节点，因此必须事先存储其前一个元素。在更改引用之前，还需要另一个指针来存储下一个节点。不要忘记在最后返回新的头引用！

```
public ListNode reverseList(ListNode head) {
    ListNode prev = null;
    ListNode curr = head;
    while (curr != null) {
        ListNode nextTemp = curr.next;
        curr.next = prev;
        prev = curr;
        curr = nextTemp;
    }
    return prev;
}
```

方法二：递归
递归版本稍微复杂一些，其关键在于反向工作。假设列表的其余部分已经被反转，现在我该如何反转它前面的部分？

假设列表为：

n_{1}\rightarrow ... \rightarrow n_{k-1} \rightarrow n_{k} \rightarrow n_{k+1} \rightarrow ... \rightarrow n_{m} \rightarrow \varnothing
n 
1
	
 →...→n 
k−1
	
 →n 
k
	
 →n 
k+1
	
 →...→n 
m
	
 →∅

若从节点 n_{k+1}n 
k+1
	
  到 n_{m}n 
m
	
  已经被反转，而我们正处于 n_{k}n 
k
	
 。

n_{1}\rightarrow ... \rightarrow n_{k-1} \rightarrow n_{k} \rightarrow n_{k+1} \leftarrow ... \leftarrow n_{m}
n 
1
	
 →...→n 
k−1
	
 →n 
k
	
 →n 
k+1
	
 ←...←n 
m
	


我们希望 n_{k+1}n 
k+1
	
  的下一个节点指向 n_{k}n 
k
	
 。

所以，n_{k}n 
k
	
 .next.next = n_{k}n 
k
	
 。

要小心的是 n_{1}n 
1
	
  的下一个必须指向 Ø 。如果你忽略了这一点，你的链表中可能会产生循环。如果使用大小为 2 的链表测试代码，则可能会捕获此错误。



```
//    看了半个小时可算是把这个递归看懂了！不妨假设链表为1，2，3，4，5。按照递归，当执行reverseList（5）的时候返回了5这个节点，
//    reverseList(4)中的p就是5这个节点，我们看看reverseList（4）接下来执行完之后，5->next = 4, 4->next = null。这时候返回了p这个节点，
//    也就是链表5->4->null，接下来执行reverseList（3），代码解析为4->next = 3,3->next = null，
//    这个时候p就变成了，5->4->3->null, reverseList(2), reverseList(1)依次类推，p就是:5->4->3->2->1->null
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;//最后一个节点和最后一个节点为null的next节点
        ListNode p = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return p;
    }
```





## 二十四、位运算相关

#### 将一个int数字转换为指定位数二进制的字符串形式

```
    /**
     * 将一个int数字转换为二进制的字符串形式。
     * @param num 需要转换的int类型数据
     * @param digits 要转换的二进制位数，位数不足则在前面补0
     * @return 二进制的字符串形式
     */
    public static String toBinary(int num, int digits) {
        int value = 1 << digits | num;
        String bs = Integer.toBinaryString(value); //0x20 | 这个是为了保证这个string长度是6位数
        return  bs.substring(1);
    }
```

```
/**
 * 将一个int数字转换为二进制的字符串形式。
 * @param num 需要转换的int类型数据
 * @param digits 要转换的二进制位数，位数不足则在前面补0
 * @return 二进制的字符串形式
 */
public static String toBinary(int num, int digits) {
    String cover = Integer.toBinaryString(1 << digits).substring(1);
    String s = Integer.toBinaryString(num);
    return s.length() < digits ? cover.substring(s.length()) + s : s;
}
```







#### 异或 xor

二进制位相同是0，不同是1

![image-20200824225226150](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824225226150.png)

![image-20200824225413574](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824225413574.png)

![image-20200824225455527](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824225455527.png)



#### [136. 只出现一次的数字](https://leetcode-cn.com/problems/single-number/)

![image-20200824225038671](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824225038671.png)

![image-20200824225058051](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200824225058051.png)

```
class Solution {
    public int singleNumber(int[] nums) {
        int single = 0;
        for (int num : nums) {
            single ^= num;
        }
        return single;
    }
}


```

#### 将整型数字转换为二进制字符串，一共32位，不舍弃前面的0

```java
 /**
     * 将整型数字转换为二进制字符串，一共32位，不舍弃前面的0
     *
     * @param number 整型数字
     * @return 二进制字符串
     */
    private static String get32BitBinString(int number) {
        StringBuilder sBuilder = new StringBuilder();
        for (int i = 0; i < 32; i++) {
            sBuilder.append(number & 1);
            number = number >>> 1;
        }
        return sBuilder.reverse().toString();
    }

```



## 二十五、排序

#### Java常见的几种排序算法-插入、选择、冒泡、快排、堆排等

![image-20200829152218023](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200829152218023.png)



三、快速排序（O(nlogn)、不稳定）

快速排序简称快排，是一种比较快的排序，适合基本无序的数据，为什么这么说呢？下面我说下快排的思路：

设置两个指针：i和j，分别指向第一个和最后一个，i像后移动，j向前移动，选第一个数为标准（一般这样做，当然快排的关键就是这个“标准”的选取），从后面开始，找到第一个比标准小的数，互换位置，然后再从前面，找到第一个比标准大的数，互换位置，第一趟的结果就是标准左边的都小于标准，右边的都大于标准（但不一定有序），分成两拨后，继续递归的使用上述方法，最终有序！代码如下：

```java
三、快速排序（O(nlogn)、不稳定）

快速排序简称快排，是一种比较快的排序，适合基本无序的数据，为什么这么说呢？下面我说下快排的思路：

设置两个指针：i和j，分别指向第一个和最后一个，i像后移动，j向前移动，选第一个数为标准（一般这样做，当然快排的关键就是这个“标准”的选取），从后面开始，找到第一个比标准小的数，互换位置，然后再从前面，找到第一个比标准大的数，互换位置，第一趟的结果就是标准左边的都小于标准，右边的都大于标准（但不一定有序），分成两拨后，继续递归的使用上述方法，最终有序！代码如下：

package com.xtfggef.algo.sort;  
public class QuickSortTest {  
    static class QuickSort {  
        public int data[];  
        private int partition(int array[], int low, int high) {  
            int key = array[low];  
            while (low < high) {  
                while (low < high && array[high] >= key)  
                    high--;  
                array[low] = array[high];  
                while (low < high && array[low] <= key)  
                    low++;  
                array[high] = array[low];  
            }  
            array[low] = key;  
            return low;  
        }  
  
        public int[] sort(int low, int high) {  
            if (low < high) {  
                int result = partition(data, low, high);  
                sort(low, result - 1);  
                sort(result + 1, high);  
            }  
            return data;  
        }  
    }  
  
    static void print(int data[]) {  
        for (int i = 0; i < data.length; i++) {  
            System.out.print(data[i] + " ");  
        }  
    }  
  
    public static void main(String[] args) {  
        int data[] = { 20, 3, 10, 9, 186, 99, 200, 96, 3000 };  
        print(data);  
        System.out.println();  
        QuickSort qs = new QuickSort();  
        qs.data = data;  
        qs.sort(0, data.length - 1);  
        print(data);  
    }  
}  

```

![image-20200829162412840](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200829162412840.png)

#### 1.归并排序



 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。

首先考虑下如何将将二个有序数列合并。这个非常简单，只要从比较二个数列的第一个数，谁小就先取谁，取了后就在对应数列中删除这个数。然后再进行比较，如果有数列为空，那直接将另一个数列的数据依次取出即可。

```cpp
//将有序数组a[]和b[]合并到c[]中
void MemeryArray(int a[], int n, int b[], int m, int c[])
{
	int i, j, k;
 
	i = j = k = 0;
	while (i < n && j < m)
	{
		if (a[i] < b[j])
			c[k++] = a[i++];
		else
			c[k++] = b[j++]; 
	}
 
	while (i < n)
		c[k++] = a[i++];
 
	while (j < m)
		c[k++] = b[j++];
}
```

可以看出合并有序数列的效率是比较高的，可以达到O(n)。

解决了上面的合并有序数列问题，再来看归并排序，其的基本思路就是将数组分成二组A，B，如果这二组组内的数据都是有序的，那么就可以很方便的将这二组数据进行排序。如何让这二组组内数据有序了？

可以将A，B组各自再分成二组。依次类推，当分出来的小组只有一个数据时，可以认为这个小组组内已经达到了有序，然后再合并相邻的二个小组就可以了。这样通过先递归的分解数列，再合并数列就完成了归并排序。

```cpp
//将有二个有序数列a[first...mid]和a[mid...last]合并。
void mergearray(int a[], int first, int mid, int last, int temp[])
{
	int i = first, j = mid + 1;
	int m = mid,   n = last;
	int k = 0;
	
	while (i <= m && j <= n)
	{
		if (a[i] <= a[j])
			temp[k++] = a[i++];
		else
			temp[k++] = a[j++];
	}
	
	while (i <= m)
		temp[k++] = a[i++];
	
	while (j <= n)
		temp[k++] = a[j++];
	
	for (i = 0; i < k; i++)
		a[first + i] = temp[i];
}
void mergesort(int a[], int first, int last, int temp[])
{
	if (first < last)
	{
		int mid = (first + last) / 2;
		mergesort(a, first, mid, temp);    //左边有序
		mergesort(a, mid + 1, last, temp); //右边有序
		mergearray(a, first, mid, last, temp); //再将二个有序数列合并
	}
}
 
bool MergeSort(int a[], int n)
{
	int *p = new int[n];
	if (p == NULL)
		return false;
	mergesort(a, 0, n - 1, p);
	delete[] p;
	return true;
}
```

 

归并排序的效率是比较高的，设数列长为N，将数列分开成小数列一共要logN步，每步都是一个合并有序数列的过程，时间复杂度可以记为O(N)，故一共为O(N*logN)。因为归并排序每次都是在相邻的数据中进行操作，所以归并排序在O(N*logN)的几种排序方法（快速排序，归并排序，希尔排序，堆排序）也是效率比较高的。

```java
 class BoolTest {
        public static void main(String args[]) {
            int a[] = {2, 4, 11, 8, 1, 3, 5, 9};
            int k = 0;
            int temp[] = new int[11];
            mergesort(a, 0, a.length - 1, temp);
            for (int i = 0; i < a.length;
                 i++) {
                System.out.print(a[i]);
            }
        }

        public static void mergearray(int[] a, int first, int mid, int last, int temp[]) {
            int f = first, j = mid + 1;
            int m = mid, l = last;
            int k = 0;
            while (f <= m &&
                    j <= l) {
                if (a[f] <= a[j]) temp[k++] = a[f++];
                else temp[k++] = a[j++];
            }
            while (f <= m) temp[k++] = a[f++];
            while (j <= l) temp[k++] = a[j++];
            for (f = 0; f < k;
                 f++)
                a[first + f] = temp[f];
        }

        public static void mergesort(int[] a, int first, int last, int[] temp) {
            if (first < last) {
                int mid = (first + last) / 2;
                mergesort(a, first, mid, temp); //左边有序 mergesort(a, mid + 1, last, temp); //右边有序 mergearray(a, first, mid, last, temp); //再将二个有序数列合并 } } }
            }
```

```
public class Main {
 
	public static void main(String[] args) {
		int[] arr = {11,44,23,67,88,65,34,48,9,12};
		int[] tmp = new int[arr.length];    //新建一个临时数组存放
		mergeSort(arr,0,arr.length-1,tmp);
		for(int i=0;i<arr.length;i++){
			System.out.print(arr[i]+" ");
		}
	}
	
	public static void merge(int[] arr,int low,int mid,int high,int[] tmp){
		int i = 0;
		int j = low,k = mid+1;  //左边序列和右边序列起始索引
		while(j <= mid && k <= high){
			if(arr[j] < arr[k]){
				tmp[i++] = arr[j++];
			}else{
				tmp[i++] = arr[k++];
			}
		}
		//若左边序列还有剩余，则将其全部拷贝进tmp[]中
		while(j <= mid){    
			tmp[i++] = arr[j++];
		}
		
		while(k <= high){
			tmp[i++] = arr[k++];
		}
		
		for(int t=0;t<i;t++){
			arr[low+t] = tmp[t];
		}
	}
 
	public static void mergeSort(int[] arr,int low,int high,int[] tmp){
		if(low<high){
			int mid = (low+high)/2;
			mergeSort(arr,low,mid,tmp); //对左边序列进行归并排序
			mergeSort(arr,mid+1,high,tmp);  //对右边序列进行归并排序
			merge(arr,low,mid,high,tmp);    //合并两个有序序列
		}
	}
	
}
```

#### [148. 排序链表](https://leetcode-cn.com/problems/sort-list/)

![image-20200825205607691](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200825205607691.png)

![Picture2.png](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/8c47e58b6247676f3ef14e617a4686bc258cc573e36fcf67c1b0712fa7ed1699-Picture2.png)



```
    class Solution3 {
        public ListNode sortList(ListNode head) {

//        4.    cut 递归终止条件： 当head.next == None时，说明只有一个节点了，直接返回此节点。
            if (head == null || head.next == null)
                return head;

            //一、分割 cut 环节： 找到当前链表中点，并从中点将链表断开（以便在下次递归 cut 时，链表片段拥有正确边界）；
            ListNode fast = head.next, slow = head;
            while (fast != null && fast.next != null) {
//                1.我们使用 fast,slow 快慢双指针法，奇数个节点找到中点，偶数个节点找到中心左边的节点。
                slow = slow.next;
                fast = fast.next.next;
            }
//           2. 找到中点 slow 后，执行 slow.next = None 将链表切断。
            ListNode tmp = slow.next;
            slow.next = null;
//        3.    递归分割时，输入当前链表左端点 head 和中心节点 slow 的下一个节点 tmp(因为链表是从 slow 切断的)。
            ListNode left = sortList(head);
            ListNode right = sortList(tmp);

        // 二、合并 merge 环节： 将两个排序链表合并，转化为一个排序链表。
//            1.双指针法合并，建立辅助ListNode h 作为头部。
            ListNode h = new ListNode(0);
            ListNode res = h;
//            设置两指针 left, right 分别指向两链表头部，比较两指针处节点值大小，由小到大加入合并链表头部，指针交替前进，直至添加完两个链表。
            while (left != null && right != null) {
                if (left.val < right.val) {
                    h.next = left;
                    left = left.next;
                } else {
                    h.next = right;
                    right = right.next;
                }
                h = h.next;
            }
            h.next = left != null ? left : right;
//            返回辅助ListNode h 作为头部的下个节点 h.next。
            return res.next;
        }
    }
```



![image-20200825232509993](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200825232509993.png)

```
class Solution {
    public ListNode sortList(ListNode head) {
        ListNode h, h1, h2, pre, res;
        h = head;
        int length = 0, intv = 1;
        while (h != null) {
            h = h.next;
            length++;
        }
        res = new ListNode(0);//头节点
        res.next = head;
        while (intv < length) {
            //两个段长为intv的段合并
            pre = res;
            h = res.next;
            while (h != null) {
                int i = intv;
                h1 = h;//第一段长度为intv的起点
                while (i > 0 && h != null) {
                    h = h.next;//h移动到pre节点的后 intv个节点
                    i--;
                }
                if (i > 0) break;//如果第一段都凑不够intv个长度，不需要排序，经过前面的intv长度排序是有序的
                i = intv;
                h2 = h;//第二段长度为intv的起点
                while (i > 0 && h != null) {
                    h = h.next;//h是下两段长度为intv的节点的起点
                    i--;//i剩余几个，就说明第二段距离intv差几个
                }
                int c1 = intv, c2 = intv - i;//c1,c2代表两段的距离
                //合并intv
                while (c1 > 0 && c2 > 0) {
                    if (h1.val < h2.val) {
                        pre.next = h1;
                        h1 = h1.next;
                        c1--;
                    } else {
                        pre.next = h2;
                        h2 = h2.next;
                        c2--;
                    }
                    pre = pre.next;
                }
                pre.next = c1 == 0 ? h2 : h1;//剩下的部分连接到该段
                while (c1 > 0 || c2 > 0) {//pre移动到这两段排序好的末端
                    pre = pre.next;
                    c1--;
                    c2--;
                }
                pre.next = h;//连接上下一段排序的头节点
            }
            intv *= 2;//将intv增大一段继续排序
        }
        return res.next;
    }
}
```

#### [215. 数组中的第K个最大元素](https://leetcode-cn.com/problems/kth-largest-element-in-an-array/)

![image-20200902110006644](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200902110006644.png)

![image-20200902110043372](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200902110043372.png)

![image-20200902110113633](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200902110113633.png)
![image-20200902110859682](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200902110859682.png)





#### [239. 滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)

```
  class Solution {
        ArrayDeque<Integer> deq = new ArrayDeque<Integer>();//存储的是索引
        int[] nums;

        public void clean_deque(int i, int k) {
//            - 只保留当前滑动窗口中有的元素的索引。
//            - 移除比当前元素小的所有元素，它们不可能是最大的。
            //clean完以后，双端队列中保存的只有比当前元素大的值，因此基本上是降序排列的，因为比后面元素小的值都被清理掉了
            // remove indexes of elements not from sliding window
//            ，从i开始往前的k个元素为[i-k+1,i]
            if (!deq.isEmpty() && deq.getFirst() == i - k)
                deq.removeFirst();

            // remove from deq indexes of all elements
            // which are smaller than current element nums[i]
            while (!deq.isEmpty() && nums[i] > nums[deq.getLast()]) deq.removeLast();
        }

        public int[] maxSlidingWindow(int[] nums, int k) {
            int n = nums.length;
            if (n * k == 0) return new int[0];
            if (k == 1) return nums;

            // init deque and output
            this.nums = nums;
            int max_idx = 0;
            //第一个窗口的初始化，将第一个窗口的，即前 k个元素入双端队列
            for (int i = 0; i < k; i++) {
                clean_deque(i, k);
                //从尾端移除比num[i]小的值，并且将第一个不是从i往前k个序列的元素删掉
                deq.addLast(i);
                // compute max in nums[:k]
                if (nums[i] > nums[max_idx]) max_idx = i;
            }

            int[] output = new int[n - k + 1];
            output[0] = nums[max_idx];

            // build output
            for (int i = k; i < n; i++) {
                clean_deque(i, k);
                deq.addLast(i);
                //第一个元素就是当前窗口的最大值
                output[i - k + 1] = nums[deq.getFirst()];
            }
            return output;
        }
    }
```







## 二十六、设计相关

#### [155. 最小栈](https://leetcode-cn.com/problems/min-stack/)

https://leetcode-cn.com/problems/min-stack/solution/shi-yong-fu-zhu-zhan-tong-bu-he-bu-tong-bu-python-/

方法一、使用辅助栈

![image-20200826004146728](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826004146728.png)

##### 方法一：辅助栈和数据栈同步

```
 import java.util.Stack;

    public class MinStack {

        // 数据栈
        private Stack<Integer> data;
        // 辅助栈
        private Stack<Integer> helper;

        /**
         * initialize your data structure here.
         */
        public MinStack() {
            data = new Stack<>();
            helper = new Stack<>();
        }

        // 思路 1：数据栈和辅助栈在任何时候都同步

        public void push(int x) {
            // 数据栈和辅助栈一定会增加元素
            data.add(x);
            if (helper.isEmpty() || helper.peek() >= x) {
                helper.add(x);
            } else {
                helper.add(helper.peek());
            }
        }

        public void pop() {
            // 两个栈都得 pop
            if (!data.isEmpty()) {
                helper.pop();
                data.pop();
            }
        }

        public int top() {
            if(!data.isEmpty()){
                return data.peek();
            }
            throw new RuntimeException("栈中元素为空，此操作非法");
        }

        public int getMin() {
            if(!helper.isEmpty()){
                return helper.peek();
            }
            throw new RuntimeException("栈中元素为空，此操作非法");
        }
    }
    

```

##### 方法二：辅助栈和数据栈不同步

```
import java.util.Stack;

public class MinStack {

    // 数据栈
    private Stack<Integer> data;
    // 辅助栈
    private Stack<Integer> helper;

    /**
     * initialize your data structure here.
     */
    public MinStack() {
        data = new Stack<>();
        helper = new Stack<>();
    }

    // 思路 2：辅助栈和数据栈不同步
    // 关键 1：辅助栈的元素空的时候，必须放入新进来的数
    // 关键 2：新来的数小于或者等于辅助栈栈顶元素的时候，才放入（特别注意这里等于要考虑进去）
    // 关键 3：出栈的时候，辅助栈的栈顶元素等于数据栈的栈顶元素，才出栈，即"出栈保持同步"就可以了

    public void push(int x) {
        // 辅助栈在必要的时候才增加
        data.add(x);
        // 关键 1 和 关键 2
        if (helper.isEmpty() || helper.peek() >= x) {
            helper.add(x);
        }
    }

    public void pop() {
        // 关键 3：data 一定得 pop()
        if (!data.isEmpty()) {
            // 注意：声明成 int 类型，这里完成了自动拆箱，从 Integer 转成了 int，因此下面的比较可以使用 "==" 运算符
            // 参考资料：https://www.cnblogs.com/GuoYaxiang/p/6931264.html
            // 如果把 top 变量声明成 Integer 类型，下面的比较就得使用 equals 方法
            int top = data.pop();
            if(top == helper.peek()){
                helper.pop();
            }
        }
    }

    public int top() {
        if(!data.isEmpty()){
            return data.peek();
        }
        throw new RuntimeException("栈中元素为空，此操作非法");
    }

    public int getMin() {
        if(!helper.isEmpty()){
            return helper.peek();
        }
        throw new RuntimeException("栈中元素为空，此操作非法");
    }

}

```

方法二：

创建一个node结构，同时保存put的值已经当前对应的最小值

![image-20200826004351620](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826004351620.png)
![image-20200826004432954](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200826004432954.png)
![image-20200826004452671](C:/Users/yang/Desktop/javaweb%25E7%25AC%2594%25E8%25AE%25B0/2.%25E7%25AE%2597%25E6%25B3%2595%25E6%2580%25BB%25E7%25BB%2593.assets/image-20200826004452671.png)

方法三：自定义栈

![image-20200826004525003](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826004525003.png)

![image-20200826004546867](2.%E5%88%B7%E9%A2%98%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.assets/image-20200826004546867.png)

## 二十七、ist相关

### 两个List集合取交集、并集、差集

```
 
import java.util.ArrayList;
import java.util.List;
import static java.util.stream.Collectors.toList;
 
 
public class Test {
 
    public static void main(String[] args) {
        List<String> list1 = new ArrayList<String>();
        list1.add("1");
		list1.add("2");
		list1.add("3");
		list1.add("5");
		list1.add("6");
 
        List<String> list2 = new ArrayList<String>();
        list2.add("2");
		list2.add("3");
		list2.add("7");
		list2.add("8");
 
        // 交集
        List<String> intersection = list1.stream().filter(item -> list2.contains(item)).collect(toList());
        System.out.println("---交集 intersection---");
        intersection.parallelStream().forEach(System.out :: println);
 
        // 差集 (list1 - list2)
        List<String> reduce1 = list1.stream().filter(item -> !list2.contains(item)).collect(toList());
        System.out.println("---差集 reduce1 (list1 - list2)---");
        reduce1.parallelStream().forEach(System.out :: println);
 
        // 差集 (list2 - list1)
        List<String> reduce2 = list2.stream().filter(item -> !list1.contains(item)).collect(toList());
        System.out.println("---差集 reduce2 (list2 - list1)---");
        reduce2.parallelStream().forEach(System.out :: println);
 
        // 并集
        List<String> listAll = list1.parallelStream().collect(toList());
        List<String> listAll2 = list2.parallelStream().collect(toList());
        listAll.addAll(listAll2);
        System.out.println("---并集 listAll---");
        listAll.parallelStream().forEachOrdered(System.out :: println);
 
        // 去重并集
        List<String> listAllDistinct = listAll.stream().distinct().collect(toList());
        System.out.println("---得到去重并集 listAllDistinct---");
        listAllDistinct.parallelStream().forEachOrdered(System.out :: println);
 
        System.out.println("---原来的List1---");
        list1.parallelStream().forEachOrdered(System.out :: println);
        System.out.println("---原来的List2---");
        list2.parallelStream().forEachOrdered(System.out :: println);
 
    }
}
```

